# OOP (Java)

Created: July 14, 2021 3:57 PM
Created By: hyoju son
Last Edited Time: July 26, 2021 5:15 PM
Property: 경기대_이은정T
Type: CS

- Contents

# 1. Java

## Java 언어

- 객체지향
    - 객체 : 데이터와 기능 (연산)을 가지는 개념적인 단위이다.
    ex. 사람(객체) - 이름, 나이, 주소... (데이터)
                          - 일어난다, 먹는다, 잔다... (메소드)
    - 객체지향 프로그램 : 객체가 데이터에 대해 동작을 한다.
    ex. 사람 (객체)를 생성하고, 이름과 생년월일 (데이터)를 넣고, 자료를 입력받아 사주를 출력한다. (메소드)
    - 객체지향 언어 : 클래스를 생성하는 기능을 제공하는 언어이다. (클래스는 객체를 만들기 위한 원형이다.)
    - 클래스 메소드를 이용해서 함수를 호출한다.
    - 상속, 다형성, 참조 등의 기능을 제공한다.
    ex. Java는 객체지향에 충실하게 만들어진 언어이다.
- VM에 의해 실행됨
    - VM (Vertual Machine) : 자바코드를 실행시키는 software 이다. (.java 파일을 컴파일해서 생성된 .class 파일을 VM에 전달하면, VM이 읽고 실행시킴)
    - VM everywhere : 웹브라우저, 핸드폰에 모두 설치되어 있음. 어디서나 실행 가능한 환경
    - Run everywhere : 자바 표준에 의해 동작하는 방식이 결정됨. OS마다 VM 버전에 차이가 있으나 .class 파일을 해석할 때는 표준에 따름

        cf. 직접실행, Native 실행
        - C언어는 프로그램이 컴퓨터 (CPU)에서 바로 실행된다. (C 컴파일해서 생성된 .exe 파일을 CPU에 전달하면, CPU가 코드를 읽고 바로 실행시킴)
           컴파일러의 버전, CPU 환경이 프로그램 실행 여부에 영향을 미침

        ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled.png)

    - Java 프로그램의 실행방식
    - .java 파일을 컴파일하면, .class 파일(BYTE코드 (실행코드)로 구성)이 생성된다.
    - VM은 BYTE코드를 실행시킨다.

        ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%201.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%201.png)

    - VM의 장점
    - 플랫폼 독립성 : 어느 환경에서나 실행 가능하며, 표준에 의해 동일하게 동작함
    - 안전한 실행 : VM이 보안검사를 실행하여 안전한 .class 파일만 실행함 (반면 .exe 파일에 바이러스가 있으면 감지가 어려움)
    - 인터넷 실행 (Executable downloads) : 네트워크 상에서 다운받아 실행 가능함 (CD를 통해 다운받아 설치할 필요가 없음)
- 범용언어
    - 범용언어 : 무슨 작업이든 프로그램으로 작성 가능하다. (프로그램을 통해 사람이 컴퓨터에게 작업을 시킴)
    - 컴퓨터의 구조에 맞는 기본 기능을 제공함 (메모리 + CPU + 입출력(I/O))

        cf. 특수목적언어
        - JavaScript는 웹에서 동작하기 위한 언어이다. (이외 기능은 제외함)
        - 코틀린은 안드로이드 모바일에 특화된 언어이다.

    - C와 Python의 중간에 있는 언어가 Java이다.
    - C : 낮은 수준의 코드. 빠르고 성능이 좋으나 까다로움. 주소나 비트 등 운영체제나 시스템 제어가 가능한 강력한 언어이지만, 기계어에 가까우며 자세하게 지정해야 함
    - Python : 생산성이 좋으나 느리고 메모리 소모가 큼. 사람에 가까운 언어로 구체적인 것을 지정하지 않아도 컴퓨터가 알아서 실행

## Java 프로그램 구조

- Java는 객체지향 언어이며, Class로 프로그램을 구성한다.
    - VM에게 Main Class (MyClass) 실행을 요청하며, 내부의 main 함수를 실행한다.
    - 프로그램을 시작하면 실행할 Class (MyClass)를 지정한다. 
    - 해당 Class는 항상 public이어야 하고, 내부에 main 함수 (public static void main() 형태)가 있어야 한다.

        ```java
        public class MyClass {
        		public static void main(String[] args) {
        		}
        }
        ```

    - 객체로 구성된 프로그램은 C의 프로그래밍 방식과 다르다.
    - 'Java의 main 함수'를 'C의 main 함수'처럼 사용하는 것은 OOP에서 바람직하지 않다. 또한 static 메서드 (Swift에서는 타입 메서드) 사용도 바람직하지 않다.
       객체지향적으로 프로그램을 구성하려면, 객체 메소드 myMain을 통해 기능을 구현하는 것이 좋다. (Swift에서는 인스턴스 메소드. 그리고 인스턴스를 Class 외부에서 생성한다.) 
       즉, Class 필드를 C의 전역변수인 것처럼, myMain을 C의 main인 것처럼 작성하면 된다.

        ```java
        public class MyClass {
        // Class 필드 선언 (Swift에서는 인스턴스 프로퍼티)

        		void myMain() { // 객체 메소드 (Swift에서는 인스턴스 메소드) 
        		}		

        		public static void main(String[] args) { // static main 함수 (Swift에서는 타입 메소드)
        				myClass my = new myClass();  // MyClass Class의 객체 my 생성
        				my.myMain();
        		}
        }
        ```

        - 다른 Class를 사용하는 main
        - main 함수가 들어있는 Main Class와 실제 프로그램의 코드를 가지고 있는 Class가 다른 경우,
          Main Class에는 main 함수만 있고,
          다른 Class에 필드, 메소드가 들어있다. (myMain함수도 다른 Class에 배치할 수 있다.)

# 2. 변수 및 this

- 변수
- 메소드 내부에서만 사용하는 변수는 지역변수로 선언한다. 여러 메소드에서 사용되거나, 다음에 호출할 때까지 값을 기억해야 하는 변수는 필드로 선언한다.
    - 필드 : Class에 선언된 변수 (Swift에서는 인스턴스 프로퍼티). (=Attribute)
    - 지역변수 : 메소드 내부에 선언된 변수
    - 필드는 Class 내부의 모든 메소드에 사용 가능하다.
    - *필드와 지역변수가 충돌할 경우, 가장 가까운 범위의 선언을 적용한다. 즉, Class 필드가 아닌 지역변수로 인식된다. "필드가 가려진다"고 표현함
        이때, this로 객체를 가르켜서 필드를 나타낼 수 있다.

        ```java
        import java.util.Scanner;

        public class FirstProgram {
        		String name; // Class 필드 선언
        		int id;
        		Scanner scan = new Scanner(System.in);
        		
        		public static void main(String args[]) {
        				FirstProgram my = new FirstProgram(); // FirstProgram Class의 객체 my 생성
        				my.run();
        		}

        		void run() { // 객체 메소드
        				int year; // 지역변수
        				int id = 0; // 지역변수 선언. *그런데 Class 필드 id와 충돌하는 경우는? 가장 가까운 id를 찾아서 적용한다.

        				System.out.println("자바 제대로 배워보자!");
        				inputInfo();
        				System.out.printf("이름: %s, 학번: %d\n", name, id); // *즉, 이 경우 id는 지역변수 id로 인식한다. (Class 필드 id가 아님) -> this.id로 수정하면 필드 id로 인식한다.

        				System.out.println("학년을 기입하세요.");
        				year = scan.nextInt();
        				System.out.printf("%d학년\n", year);
        		}

        		void inputInfo() { // 객체 메소드
        				System.out.println("이름과 학번을 기입하세요.");
        				name = scan.next();  // this.name = this.scan.next(); 와 동일 - 평소에는 생략함
        				id = scan.nextInt(); // this.id = this.scan.nextInt(); 와 동일
        		}
        }
        ```

        - 코드 실행 시 Run-time Stack의 구조

            ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%202.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%202.png)

            *this. : 객체를 가르키는 숨겨진 매개변수 (보통 생략함) - Python에서는 생략하지 않고 self.로 명시한다.

- 블록 변수
    - block {} 내부에서 선언된 변수는 블록을 벗어나면 사용할 수 없다. (while, for...)
    ex. while 문에 int i 블록변수를, for 문에 int i 블록변수를 중복 사용해도 문제가 없다.

        단, Java에서 블록변수와 지역변수의 이름이 중복되면 컴파일 에러가 발생한다.

    - 장점 : 가독성이 높다. 코드가 단순하다. 블록 밖에서 문제를 일으키지 않는다.

# 3. Type 및 연산

- Data Type 
- Primitive data types (8개) : 정수 byte-1Byte (1바이트=8비트=256개 숫자=-128~127), short-2Byte, int-4Byte, long-8Byte / 실수 float-4B, double-8B / boolean, char (글자)
- 그외에 java.lang.String class를 통해 string을 지원함 (string은 참조 type)

- 자동변환 (컴파일러가 연산을 위해 Type을 자동으로 변환시켜줌) 
- C는 모든 변환을 허용하지만, Java는 데이터 손실이 없는 경우 (소수점 이하가 짤리지 않음)만 허용함
- (허용) short→int→long, float→double, int,long→float,double 
  (면접 중요. int→float 형변환은 엄밀히 정밀도 손실이 발생한다. 둘다 4Byte (32비트)이지만 int는 부호, 가수부만 표현하고, float은 부호 (1비트), 가수부 (23비트)와 지수부 (8비트)로 나누어 표현한다.
   따라서 float의 가수 부분은 int의 가수 부분보다 적기 때문에 근사치로 변환된다. 유효값의 아래부분이 짤릴 수는 있지만 값이 크게 변하지 않으므로 변환을 허용한다.)
    - [ ]  ?
    - 고정 소수점 방식(Fixed-Point Number Representation) : 부호 (sign) / 정수부 (integer part) / 소수부 (fraction part)
    부동 소수점 방식(Floating-Point Number Representation) : 부호 (sign) / 가수부 (mantissa) / 지수부 (exponent)

    - (불허) float,double→int, 수치형←>char, 수치형→Boolean 
       cf. C는 0/1←>false/true가 가능하지만, Java에서는 휴먼에러 방지를 위해 불허함

- 동일한 Type끼리 연산 가능
- 큰 것에 맞추어 변환하여 연산 (수치연산, 비교연산 등)한다.
   ex. int + float → float + float ⇒ float (연산을 위해 컴파일러가 자동으로 변환시켜줌)

    ```java
    int i, j, k, n, m;
    double a, b, c, d;

    i = 50;
    j = 3;
    k = 0;

    a = i / j; // 16.000000 출력 - (int/int =>) 정수 나누기 정수를 하면 결과값을 double type 변수에 넣더라도 소수점 이하가 짤린다.
    b = (double) i / j; // 16.666667 출력 - (double/int =>) int i를 double로 형변환한 이후에 나누기를 하면, 컴파일러가 int j를 double로 자동변환해서 소수점 이하가 출력된다.

    System.out.println("a = %f, b = %f\n",a,b); // a = 16.000000, b = 16.666667

    k = (int) b % 2; // % 연산을 하기위해 컴파일러가 double b는 int로 자동변환한다.

    System.out.println("k = %d\n",k); // k = 0
    ```

- String과 Int 변환
    - int→string은 자동변환
    - `"" +intNumber`는 컴파일러가 변수 intNumber의 type을 int→string으로 자동변환해서 연산한다.
    - `Integer.toString(intNumber)` 변환함수를 사용하는 것도 가능하다. (마찬가지로 변수 intNumber의 type을 int→string으로 변환한다.)
    - string→int는 함수가 필요
    - `intNumber = integer.parseInt(strNumber)` 또는 `intNumber = integer.valueOf(strNumber)` 함수를 이용한다. 변수 strNumber의 type을 string에서 int로 변환한다.
    - strNumber에 숫자가 아닌 값이 들어있으면 NumberFormatException 에러가 발생한다.
      *Java에서 에러는 Exception임

        ```java
        int age = 20;

        System.out.println(age + 1 + "세"); // 201세 X -> 21세. 순서대로 연산되기 때문이다. (덧셈의 결합방향은 왼쪽=왼쪽부터 연산) 1) int age+1 = 20+1 = 21. 2) int 21+"세" -> string 21으로 자동변환되어 21세가 출력된다.
        System.out.println("나이: " + age + 1 + "세"); // 나이: 201세. 1) "나이: "+int 20 -> string 20으로 자동변환되고, 2) "나이: 20"+int 1->string 1로 자동변환되고, 3) "나이: 201"+"세"이므로 나이: 201세가 출력된다.
        System.out.println("나이: " + age * 2 + "세"); // 나이: 2020세 X -> 나이: 40세. *의 우선순위가 +보다 높으므로 1) int age*2 = 40. 2) "나이: 40"+int 40 -> string 40으로 자동변환되어 3) "나이: 40세"가 출력된다.
        ```

# 4. 입력, Scanner

- 키보드의 표준 입력
    - Stream
    - 입력 buffer : 키보드로부터 입력된 문자들을 저장하는 공간
    - 입력 stream : 입력 buffer의 내용이 흘러들어와서 차례로 쌓이고 순서대로 사용됨
        - 키보드 → 키보드 buffer (장치 드라이버) → flush 이벤트가 발생하면 프로그램에 전달 (Enter key를 입력하면 한 줄씩 전달) → 입력 stream (System.in) → Scanner
    - Scanner Class (입력)
        - 입력 stream
        - 입력 데이터가 연속으로 프로그램에 전달됨
           ex. 1 2 test (EnterKey) 3 4 5 ... 이라면, 1 2 test (EnterKey)까지 한 줄로 입력된다. (3 4 5는 키보드 buffer에 남아있다.)
        - 버퍼에 의한 입력 (키보드 Enter key가 입력되면 한 줄을 입력해줌), 포맷에 의한 입력 (int, string 등 data type에 맞게 입력해줌)
        - 형식에 따른 데이터 변환
        - `scan.next();` string으로 반환, `scan.nextInt();` int로 반환 (int가 아닌 값이 들어오면 InputMismatchException 에러 발생)

            ```java
            // Scanner Class 사용
            Scanner s = null;
            String word = null;

            s = new Scanner(System.in); // 키보드로부터 들어오는 표준입력을 이용하여 Scanner를 만들고, s라는 변수명으로 사용하겠다는 의미

            while(true) {
            		System.out.print("> > ");
            		word = s.next(); // buffer 내용 중에서 "공백이 아닌 것에서부터 공백이 아닌 것까지"의 내용을 string으로 받아서 변수 word에 할당 ("공백 단위로 읽는다"고 표현함)

            		if(word.equals("end"))
            				break;
            		n = s.nextInt(); // buffer 내용 중에서 "공백은 무시하고 정수에서부터 정수까지"의 내용을 int로 받아서 변수 n에 할당
            		System.out.println(n + " : " + word);
            }
            ```

        - Scanner 사용 시 주의사항
        - 키보드 Scanner는 프로그램 전체에 1개만 가능하다. (Scanner scan = new Scanner(System.in); // scan 선언 이후에 추가 선언이 불가하다. ???)
        - scan.nextLine() : \n (new line)이 나올 때까지 읽는다. (공백에 멈추는 `scan.next()` 또는 `scan.nextInt()` 메소드와 함께 사용하면 주의가 필요하다. Enter 입력 전의 데이터가 전달되고, 
           남은 Enter가 바로 scan.nextLine()에 전달되면 공란을 scan 하게 된다.)

# 5. Coding Style

가독성 있는 Code 작성방법에 대한 지침

- 이름의 중요성 
- 코드의 70%이상이 이름 (변수명, 함수명, 클래스명 등)
- Camel 스타일 (ex. midTermScore)
- 양식을 철저히 따름
- 줄바꾸기, 빈칸, 들여쓰기 (ex. functionName() {}, operator 전후)
- Eclipse는 자동 formatting을 지원함 (전체선택 후 Ctrl+Shift+F)
- 가로 스크롤이 생기지 않도록 80칸 이상으로 길어지는 줄은 줄바꾸기 및 들여쓰기를 함

    ```java
    if (w >= namenamenamenamenamename.length() + 2 && (w-2-namenamenamenamenamename.length()) % 2 == 0 && w-namenamenamenamenamename.length() >= w/2) {
    		// ...
    }

    // => Eclipse 자동 formatting
    if (w >= namenamenamenamenamename.length() + 2 && (w - 2 - namenamenamenamenamename.length()) % 2 == 0
    		&& w - namenamenamenamenamename.length() >= w / 2) {
    	// ...
    }
    ```

- if문 작성 시 주의사항
- 불필요한 비교조건식 삭제 : 참인지 비교연산은 필요 없음. Boolean type을 반환하는 함수를 사용 `if(student.isEmpty()~~== true~~)`
- if(!...) 지양 : `if(!student.isEmpty()) {return "Enroll"} else {return "None"}` 보다는 `if(student.isEmpty()) {return "None"} else {return "Enroll"}` 가 좋음
- 진위식을 바로 return : `boolean qualified(int base) {return (getScore() >= base); }`
- 복잡한 진위식을 단순화 : 조건부가 길어지면 함수를 사용하여 그루핑함
- 조건식에서 null 포인터 체크 (단축 계산 기능) : `if(newStudent!= null&&newStudent.isOK()) {}` newStudent가 null 가능성이 있는 경우 먼저 체크
- 항상 {} 사용
- 중첩 레벨이 3이하 : 그 이상의 중첩문들은 따로 함수를 사용하여 그루핑
- break 또는 continue 이후 else가 필요없으면 삭제 :

    ```java
    void run() { 
    		if (조건) {
    		// ... 
    		break; // cut 기능이므로 else가 필요없다.
    		} ~~else {~~
    		k += 100;
    		~~}~~
    }

    void run() { 
    		if (조건) {
    		// ... 
    		break; 
    		} 

    		k += 100;
    }
    ```

- for-each 사용이 권장됨
    - 읽기만 할 때는 사용 가능

        ```java
        // int[] scores = new ... // 변수 scores는 int type Array

        for(int i : scores) // Array scores의 element인 i에 대해서 실행
        		System.out.printf("%d", i); // Array의 모든 element를 출력하는 기능
        ```

    - 요소의 값을 변경할 때는 사용 불가

        ```java
        for(int i = 0; i < scores.length; i++) {
        		scores[i] = scan.nextlnt(); // 쓰기를 할 때는 for-each 사용 불가, for loop를 사용해야 함
        		sum += scores[i];
        }
        ```

# 6. Class Example

## 학생 Class

- Class 생성 방식
- Bottom-up : 입력파일의 Data 기반 ⇒ 요소 Class-Student 객체 (Student Class, read/print 메소드) 생성 ⇒ 요소 Class를 관리하기 위한 메인 Class-Department Class 생성
- Top-down : Data를 보고 전체적으로 무슨 작업을 할지 결정하여 메인 Class 생성 ⇒ 이를 실행하기 위한 요소 Class 생성

- Class 생성 시 참고사항
    1. data로부터 객체가 정해진다. 학생 객체가 가질 데이터를 Class 필드로 선언한다. (예시는 Bottom-up 방식)
    2. 학생 객체가 만들어질 때 필요한 일이 있는지 확인하고 생성자를 만든다.
    3. 학생 객체가 데이터를 읽는 메소드를 만든다. (입력 메소드)
    - Scanner를 parameter로 받음, 필드를 입력 데이터의 순서대로 읽음
    4. 학생 객체가 데이터를 출력하는 메소드를 만든다. (출력 메소드)

        ```java
        // 학생 data
        20161103 손하나 010-5324-0234 2
        20130320 김미미 010-2341-2341 4
        20171203 강천재 010-2341-2342 3
        20140320 JYP 010-2233-2341 4
        20151203 비코천 010-9999-2342 1

        // Class 필드
        class Student { 
        	int id; // 학번
        	String name;
        	String phone;
        	int year; // 학년

        	void read(Scanner scan) { // 객체 메소드 - Scanner Class를 사용하여 입력 메소드 생성
        		id = scan.nextInt();
        		name = scan.next();
        		phone = scan.next();
        		year = scan.nextInt();
        	}

        	void print() {	
        		System.out.format("학번 %d, 이름 %s, 연락처 %s (%d학년)\n", id, name, phone, year);
        	}
        }
        	
        // 이건 Department Class에서 선언
        scan = new Scanner(System.in);
        main 함수
        ```

- Class 설계원칙-1. KISS & Agile
    - KISS (Keep it simple and short)
    - Class나 함수 작성 시 필요한 기능만 포함
    - Agile 개발방식 (Spiral 모델)
    - 최소의 필수 기능만 구현하고, 점점 확장시키는 방식
    - Spec → Class 설계 → 코딩 → 실행을 반복

## 학과 Class

(학생 Class 생성 이후) Main Class 생성

- '프로그램의 목적'이 학과 객체의 역할이다.
- 학생 객체를 만들고, 학생 정보를 읽어 출력함
- 학과 객체는 보통 1개임
- 프로그램을 실행할 때는 프로젝트 파일 또는 Department.java 파일을 우클릭>Run As

    ```java
    import java.util.Scanner;

    public class Department {
    	Scanner scan = new Scanner(System.in); // 입력하는 객체 생성 (굳이 객체를 Student 안에서 할당하지 않고 외부 reference를 이용해서 입력함)
    	
    	void run() { // 실질적으로 myMain 함수
    		Student st = new Student(); // 학생 객체 생성  
    		st.read(scan); // 숨겨진 매개변수 this.scan (즉, Department.scan) - 그래서 호출 Stack 그림에 Department.run에 this가 있음
    		st.print();
    	}

    	public static void main(String args[]) {
    		Department department = new Department(); // 학과 객체 생성  
    		department.run();
    	}
    }
    ```

    - 함수 호출 : 프로그램 실행 시 main 함수 호출 → 내부의 run 함수 호출 → 내부의 read/print 함수 호출
    - 호출 Stack (면접 질문)
        - [ ]  그리는 방법 체크

        ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%203.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%203.png)

        - [x]  Department.run에 this 왜?
            - st.read(scan); // 숨겨진 매개변수 this.scan (즉, Department.scan)
    - 여러 명의 학생 저장하기

        ```java
        import java.util.ArrayList;
        import java.util.Scanner;

        public class Department {
        	Scanner scan = new Scanner(System.in); // 입력하는 객체 생성 (굳이 객체를 Student 안에서 할당하지 않고 외부 reference를 이용해서 입력함)

        	ArrayList<Student> studentList = new ArrayList<>(); // Student Class type의 ArrayList 생성 (ArrayList : Array와 유사하지만 크기를 신경쓰지 않아도 됨)
        	
        	void run() {
        //		Student st = new Student(); // 학생 객체 생성  
        //		st.read(scan);
        //		st.print();
        		
        		Student st = null;
        		
        		for (int i = 0; i < 5; i++) { // *ArrayList로 사용 저장
        			st = new Student(); // 학생 객체 생성 (new)을 5개 해야 해당 메모리가 할당되므로 - 왜 st1...st5가 아니라 st에 계속 할당? -> st는 임시로 쓰기위한 변수임 (Class 필드가 아니라 로컬변수)
        			st.read(scan);
        			studentList.add(st); // 5명의 데이터를 꺼내서 ArrayList에 저장한다.
        		}
        		
        		for (Student st2 : studentList) // *for-each로 출력 - studentList에 있는 st 객체에 대해서 for문을 실행함 (Swift의 for item in itemsArray와 비슷-item은 암시적으로 변수 선언됨)
        			st2.print(); // 5명의 데이터를 출력한다.
        	}

        	public static void main(String args[]) {
        		Department department = new Department(); // 학과 객체 생성  
        		department.run();
        	}
        }
        ```

        - Refactoring - run 함수는 실질적인 myMain 함수 (C의 Main함수 기능)이므로 코드를 최대한 단순화한다.
            - [ ]  printAll(); // 함수를 독립시킨 건 알겠는데, 이건 왜 department.printAll() 이라고 안써도 되지?
                - department.run() 이므로 객체는 run 실행 시점에 결정되니까
                printAll은 객체를 별도로 선택할 필요가 없다?

            ```java
            import java.util.ArrayList;
            import java.util.Scanner;

            public class Department {
            	Scanner scan = new Scanner(System.in);
            	
            	ArrayList<Student> studentList = new ArrayList<>();
            	
            	void run() {
            //		Student st = null;		
            //		for (int i = 0; i < 5; i++) { // *ArrayList로 사용 저장
            //			st = new Student();
            //			st.read(scan);
            //			studentList.add(st);
            //		}
            //		
            //		for (Student st2 : studentList) { // *for-each로 출력  
            //			st2.print();
            //		}		
            		
            		readAll();  // 5개 입력함수 및 출력함수를 독립시킴
            		printAll(); // 함수를 독립시킨 건 알겠는데, 이건 왜 department.printAll() 이라고 안써도 되지? -> Student 객체가 할 일이기 때문에!!!???
            	}
            	
            	void readAll() {
            		Student st = null;
            		for (int i = 0; i < 5; i++) {   
            			st = new Student();
            			st.read(scan);
            			studentList.add(st);
            		}
            	}
            	
            	void printAll() {
            		for (Student st : studentList) {
            			st.print();
            		}
            	}

            	public static void main(String args[]) {
            		Department department = new Department(); // 학과 객체 생성  
            		department.run();
            	}
            }
            ```

        - 메모리 Map

            ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%204.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%204.png)

            - ArrayList studentList 내부에 5개 객체의 reference가 있다.
            - Department는 Scan의 reference와 studentList의 reference를 가지고 있다.

- Class 설계원칙-2. DRY (Don't Repeat Yourself)
    - 중복 배제 원칙 : 동일한 기능을 중복으로 생성하지 않는다.
    - 메소드의 재사용성을 고려하여 생성한다. 함수는 한 가지 기능을 담고 있는 것이 재사용하기에 유리하다.

## 변수의 지정과 비교

- 변수 및 메모리
    - 기본 type 값 변수
    - 변수마다 개별적인 메모리를 가지므로 변수=값=메모리
    - 객체 type 참조 변수
    - 변수는 객체를 가르키는 참조이다. (파란 동그라미가 참조, 큰 동그라미가 객체) *Java에서 참조가 pointer 역할을 한다.
    - new를 통해 생성한 객체가 메모리를 할당받는다.
       heap의 메모리를 사용하려면, 참조를 통해서 접근한다.

        ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%205.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%205.png)

- 변수 지정
    - 값변수 지정
    - `a = b;`
    - a의 메모리에 b의 값을 복사함. a와 b는 다른 메모리에 있으므로 다른 값을 가질 수 있음
    - 참조변수 지정
    - `c = d;`
    - 변수 c에 d의 참조를 복사함. c와 d는 같은 객체를 가르킴
    - 객체 복사 (String 복사)

        ```java
        String name = "Java OOP" // String 객체 생성 (아래 참고)
        String title = name; // String name의 참조가 복사되어 title과 name이 같은 것 ("Java OOP")을 가르킴

        Student st = new Student();
        student.read(scan);
        Student newSt = st; // 객체 st의 참조가 객체 newSt에 복사되어 같은 것 (scan 데이터)을 가르킴
        ```

        - 참고 - String
        - Java의 String은 Char type의 Array이지만 포인터는 아니다.
        - String은 값 type이 아니라 참조 type이므로 Stack이 아닌 Heap 영역에 저장된다.

            ```java
            // String 객체 생성 - 2가지 방법

            // 1. "" - 객체가 한 번만 생성되므로 바람직함
            String s1 = "jackCoding"; 
            String s2 = "jackCoding"; 
            // String pool에 동일한 값이 있는지 확인하고, 있으면 해당 주소값을 반환함 (없으면 새로운 객체를 만들어 String pool에 할당하고 해당 주소값을 반환함)

            // 2. new String("") - 객체가 계속 생성되므로 성능이 나쁨
            String s3 = new String("jackCoding");
            String s4 = new String("jackCoding");
            // 일반 객체처럼 Heap 영역에 객체를 생성하고 해당 주소값을 반환함
            ```

            ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%206.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%206.png)

- 변수 비교
    - 기본 type 값의 비교
    - ==, !=, < 등으로 비교
    - 객체 type 참조의 비교
    - ==만 가능 (참조가 같은지 비교함=동일한 객체를 가르키는지 비교함)
    - equals() 가능 (참조가 가르키는 값이 같은지 비교함) - equals는 객체와 객체를 비교하므로 기본 type 비교가 불가하다.
       *equals 대신 contentEquals가 엄밀히 더 적합함
        - String 변수 비교

            ```java
            String color1 = "red", color2 ="r";
            		color2 += "ed";
            				
            		if (color1 == color2) // ==는 참조를 비교하므로 false
            			System.out.println("같은 String");
            		
            		if (color1 != color2) // true
            			System.out.println("다른 String");
            		
            		if (color1.equals(color2)) // equals는 값을 비교하므로 true
            			System.out.println("색깔이 같다");
            // 다른 String, 색깔이 같다 출력
            ```

## 별칭, String 불변성

- 별칭
    - 변수A 및 변수B가 같은 객체를 가르킬 때, A변수는 B변수의 별칭이다. (A,B가 모두 참조일 때 성립한다.)
    - 어느 이름으로 접근하나 동일하게 작동한다.
    - 참조 변수를 parameter로 전달할 때에도 (같은 객체를 가르키면) 별칭이 된다.
        - 객체 참조 변수의 경우, 별칭으로 값을 변경하면 원래 변수의 값도 바뀐다. (별칭에 의해 발생 가능한 문제)
    - 기본 type은 변수마다 각자 메모리를 가지므로 별칭이 생기지 않는다.

- String 변수와 String 객체의 불변성
    - String 객체는 불변 (객체를 생성하여 메모리를 할당한 이후에는 값을 바꿀 수 없다.)
    - 단점 : String 객체를 변경하는 연산을 할 때마다 계속 쓰레기값이 생겨서 메모리가 낭비된다.
    - 장점 : String 객체를 별칭인 변수끼리 코드의 여러 지점에서 공유 가능하다. (단, 공유한다고 해서 일괄 수정되면 문제가 발생할 수 있으므로 불변으로 약속했다.)
    - String 메소드
    - 검사 : contains, startsWith, endsWith, compare 등 (단, (큰것).contains(작은것) 순으로 코딩해야 함)
    - 일부 반환 : charAt, substring 등
    - 위치 검색 : indexOf
    - 변경 : replace, replaceAll, toLowerCase 등 (단, 변경된 값은 기존 객체를 변경하지 않고, 새로운 객체를 생성하여 반환한다.)

    ```java
    // 기본 type
    int n1 = 10; 

    int n2 = n1; // 값이 복사됨
    n2 = 20;
    System.out.printf("%d %d\n",n1,n2); // 10, 20 출력

    // 참조 type
    Student stud1 = new Student(0); // Student 객체

    Student stud2 = stud1; // 참조가 복사되어 동일한 객체를 가르킴
    stud2.read(scan); // 20161103 손하나 010-5324-0234 2 - 입력. Stud2를 변경하면 Stud1에도 적용됨 (모든 Class 필드의 값을 변경)
    stud1.print(); // 학번 20161103, 이름 손하나, 연락처 010-5324-0234 (2학년) - 출력
    stud1.year++; // Stud1을 변경하면 Stud2에도 적용됨
    stud2.print(); // 학번 20161103, 이름 손하나, 연락처 010-5324-0234 (1학년) - 출력

    // 참조 type
    String str1 = "Sweet"; // String 객체 (불변)

    String str2 = str1; // 참조가 복사되어 동일한 객체를 가르킴
    str2.replace('e','i'); // *e를 i로 대체 => "Swiit" 객체가 생성되었으나, 아무도 이를 가르키지 않는 쓰레기값이 됨 (String str4 = str2.replace('e','i');로 str4에 "Swiit" 객체 할당은 가능)

    String str3 = str1;
    str3 += "Song";  // *String 객체는 불변이므로 "Sweet" 객체가 "SweetSong" 으로 변경되지 않음. "SweetSong" 객체가 새롭게 생성되며, str3에 반환됨 (str3이 가르킴) 
    System.out.printf("%s %s %s", str1,str2,str3); // Sweet Sweet SweetSong

    // print에 많은 변수를 + 하는 코드는 메모리를 많이 소모하므로 지양한다.
    // System.out.println("이름 :" + name + namename + namenamename + ...); // + 할 때마다 새로운 String 객체가 생성되고, parameter로 전달되는 마지막 객체를 제외하고는 모두 쓰레기값이다.
    ```

    ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%207.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%207.png)

- Quiz-1

    ```java
    String alpha = ""; 
    for(int i = 'a'; i < 'z'; i++) 
    		alpha += (char)i;
    System.out.println(alpha); // 출력값은?

    // 문제점 및 해결책은? 
    ```

    - Answer
        - 출력값은? abcde...z 를 출력하지만, 과정에서 a, ab, abc... 등 쓰레기 값이 생긴다.
        - 해결책은? StringBuilder - buffer를 주고 Array를 사용해서 abc...z + 작업이 끝나면 String을 반환함
- Quiz-2

    같은 학생 개체를 가르키는 두 변수 s1, s2가 있을 때, `s2.name = "kim";`으로 객체 이름을 변경했을 때, s1.name은 어떻게 될까? (원래 값은 "lee")

    ```java
    Student s1 = new Student();
    s1.name = "lee";

    Student s2 = s1;
    s2.name = "kim";
    System.out.printf(s1.name); // 출력값?
    ```

    - Answer
        - "kim"으로 변경된다.
        - 학생 객체가 가르키고 있는 필드 name도 참조이다! (`String name;` name이 String type이므로 참조 type) name이 String 객체 "lee"를 가르키다가 String 객체 "kim"를 가르키는 것으로 변경되었다.
        - String 객체인 "lee", "kim" 자체는 불변이고, "lee"는 쓰레기값으로 남아있다. 하지만 필드 name는 변경될 수 있다.

            ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%208.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%208.png)

# 7. 객체의 비교 및 검색

## 7-1. 0이면 입력 끝내기 기능

미정 개수의 객체 입력처리

- 학생의 인원 수를 미리 알지 못하는 상황에서 입력 처리
- 학번 자리에 0이 입력되면 데이터 입력이 끝남을 나타낸다고 설정 (경계값)
    - 1. readAll 함수 수정 - 에러 발생

        ```java
        void readAll() {		
        //		Student st = null;
        //		for (int i = 0; i < 5; i++) {   
        //			st = new Student();
        //			st.read(scan);
        //			studentList.add(st);
        //		}
        		int id; // readAll 함수를 이렇게 수정하면, InputMismatchException 에러 발생

        		while(true) {
        			id = scan.nextInt(); // 여기서 id에 '학번'이 입력됨
        			if (id == 0) break;

        			Student st = new Student(); 
        			st.read(scan); // 여기서 id에 입력되는 값은 학번 다음의 '이름'이므로 에러 발생
        			studentList.add(st);
        		}
        ```

    - 2. 해결방법-1. Student 객체 생성자 지정

        ```java
        void readAll() {		
        		int id; 

        		while(true) {
        			id = scan.nextInt(); 
        			if (id == 0) break;

        			Student st = new Student(id); // 생성자로 id를 설정 -> 1) Student Class 내부에 동일한 이름의 메소드를 생성해야 한다. (생성자 정의) 또한 2) read 함수에서 id 읽기를 삭제한다.
        			st.read(scan); 
        			studentList.add(st);
        		}

        public class Student {
        // ...

        Student(int id) { // 생성자 정의
        		this.id = id;
        }

        	void read(Scanner scan) {
        //	id = scan.nextInt(); // read 함수 수정
        		name = scan.next();
        		phone = scan.next();
        		year = scan.nextInt();
        	}

        // ...
        }
        ```

    - 3. 해결방법-2. read 함수 parameter 수정

        ```java
        void readAll() {		
        		int id; 

        		while(true) {
        			id = scan.nextInt(); 
        			if (id == 0) break;

        			Student st = new Student(); 
        			st.read(scan, id); // read 함수의 parameter를 추가 -> read 함수 정의 부분을 수정해야 한다.
        			studentList.add(st);
        		}

        public class Student {
        // ...

        	void read(Scanner scan, int id) { // read 함수 수정 (parameter 추가, id 필드 입력 변경)
        		this.id = id; 
        		name = scan.next();
        		phone = scan.next();
        		year = scan.nextInt();
        	}

        // ...
        }
        ```

        - 코드

            ```java
            // Student Class
            import java.util.Scanner;

            public class Student {
            	
            	int id; // 학번
            	String name;
            	String phone;
            	int year; // 학년

            //	public static void main(String[] args) {
            //	}

            	void read(Scanner scan, int id) {
            		this.id = id;
            		name = scan.next();
            		phone = scan.next();
            		year = scan.nextInt();
            	}
            	
            	void print() {
            	System.out.format("학번 %d, 이름 %s, 연락처 %s (%d학년)\n", id, name, phone, year);
            	}
            }

            // Department Class
            import java.util.ArrayList;
            import java.util.Scanner;

            public class Department {
            	Scanner scan = new Scanner(System.in);
            	
            	ArrayList<Student> studentList = new ArrayList<>();
            	
            	public static void main(String args[]) {
            		Department department = new Department(); // 학과 객체 생성  
            		department.run();
            	}
            	
            	void run() {
            //		Student st = null;		
            //		for (int i = 0; i < 5; i++) { // *ArrayList로 사용 저장
            //			st = new Student();
            //			st.read(scan);
            //			studentList.add(st);
            //		}
            //		
            //		for (Student st2 : studentList) { // *for-each로 출력  
            //			st2.print();
            //		}		
            		readAll();
            		printAll();
            	}
            	
            	void readAll() {		
            //		Student st = null;
            //		for (int i = 0; i < 5; i++) {   
            //			st = new Student();
            //			st.read(scan);
            //			studentList.add(st);
            //		}
            		int id;
            		while(true) {
            			id = scan.nextInt();
            			if (id == 0) break;
            			
            			Student st = new Student();
            			st.read(scan, id);
            			studentList.add(st);
            		}
            	}
            	
            	void printAll() {
            		for (Student st : studentList) {
            			st.print();
            		}
            	}	
            }
            ```

- Class 설계원칙-3. SRP (Single Resposibility Principle, 단일책임원칙)
    - Class는 한 가지만 책임진다.
    - 학생 객체는 학생 데이터만 책임진다. 또한 학생 데이터는 다른 클래스에서 다루지 않는다.
    - 한 가지 : 기능, 개념, 카테고리, 데이터의 요소 등
    - 가독성이 좋고, 유지보수가 용이하다.

## 7-2. 검색 기능

학과에 저장된 학생 정보를 검색하는 기능을 추가한다.

- 키워드 검색 - 키워드를 입력하면, 학생 객체 중 해당 키워드에 매치되는 필드가 있으면 출력하는 기능
    - 1. 이름 검색

        - 이름에 입력한 string과 각 학생의 이름을 비교하여, 해당 학생이 있으면 학생을 출력하고, 없으면 "없다"고 출력한다.
        - 입력한 string이 "end"이면 검색을 종료한다.

        - 캡슐화 원칙 : 각 Class 필드는 Class 내에서만 접근한다. 필드는 외부에서 접근 불가한 private을 원칙으로 한다.
        - if(st.name.equals(nameInput)) 부분을 보면, Department Class에서 Student Class의 필드에 접근하고 있다. 따라서 부적합하다.
        - OOP이면 학생의 필드 (이름 정보)는 Student Class에서 처리 (비교/검사/수정)해야 한다. 이렇게 Department Class의 기능을 최소화해야 한다.

        ```java
        // 입력 Data
        이름 : 손하나 <- 입력
        20161103 손하나 010-5324-0234 2 <- 출력
        이름 : 김미미 <- 입력
        20130320 김미미 010-2341-2341 4 <- 출력
        이름 : end <- 입력 시 종료
        ```

        ```java
        // Top-down) Department Class에 검색 함수를 추가

        void search() {
        		String nameInput = null;
        		
        		while(true) {
        				System.out.print("이름 : ");
        				nameInput = scan.next();
        				
        				if(nameInput.equals("end")) // name이 string type이고 불변 객체를 가르키므로 equals 사용 가능 
        						break; // 입력값이 end이면 cut해라. 
        				
        				for (Student st : studentList) { // 저장된 학생정보 studentList 중에서 name 필드의 값이 입력값 nameInput과 일치하면, print 해라. 
        						if(st.name.equals(nameInput))
        								st.print();
        				}
        	  }
        }
        ```

        ```java
        // 캡슐화 원칙을 준수하는 방법 

        // 1. st.name => st.getName() 메소드 생성 - OOP에 맞지 않음
        // OOP이면 학생의 필드 (이름 정보)는 Student Class에서 처리 (비교/검사/수정)해야 한다. Department Class에서 학생정보를 가져오는 getName() 메서드를 만드는 것은 부적절하다.

        // 2. Student Class에 matches 메소드를 생성
        // Department Class로부터 키워드를 받아서, Student Class가 판단한다. (SRP 원칙에 따라 matches 함순는 판단만 하고, print하지 않는다.)
        // 즉, 학과는 학생에게 matches를 요청하고, 학생은 판단한다.

        public static void main(String args[]) {
        		Department department = new Department();  
        		department.run();
        		
        		department.search(); 
        	}

        void search() {
        		String nameInput = null;
        		
        		while(true) {
        				System.out.print(" 이름 : ");
        				nameInput = scan.next();
        				
        				if(nameInput.equals("end")) 
        						break;
        				
        				for (Student st : studentList) { 
        //	  			if(st.name.equals(nameInput))
        						if(st.matches(nameInput)) // Student Class에 matches 메소드를 생성한다. (Student Class의 private 필드 name에 접근하기 위해)
        								st.print();
        				}
        	  }
        }

        public class Student {
        // ...

        		boolean matches(String kwd) {
        				if(name.equals(kwd))
        						return true;
        				return false;
        		}

        // ...
        }
        ```

    - 2. 이름 또는 학번 검색 (키워드 통합검색 기능)

        - 입력 키워드 1개
        - 학생의 여러 필드에 대해 match하는지 비교한다.

        ```java
        // 방법-1. 형변환 사용
        boolean matches(String kwd) {
        		if(name.equals(kwd)) // 이름 match 확인 
        			return true;
        		if(kwd.equals(id + "")) // 학번 match 확인. *어떻게 1개의 parameter로 2개 필드를 비교하지? -> this.id를 int->String으로 형변환 (+"" 자동변환 활용) 처리한다!
        			return true;		      // if((id + "").equals(kwd)) 도 가능하다.
        		
        		return false;
        	}
        ```

        ```java
        // 방법-2. 변환함수 사용
        boolean matches(String kwd) {
        		if(name.equals(kwd)) // 이름 match 확인 
        			return true;
        		if((Integer.toString(id)).equals(kwd)) // 학번 match 확인 - Integer.toString(intNumber) 변환함수를 사용
        			return true;		     
        		
        		return false;
        	}
        ```

        ```java
        // 참고 - 연락처, 학년 검색 추가
        boolean matches(String kwd) {
        		if(name.equals(kwd)) // 이름 match 확인 
        			return true;
        		if(kwd.equals(id + "")) // 학번 match 확인
        			return true;	
        		if(kwd.equals(phone)) // 연락처 match 확인 
        			return true;
        		if (kwd.equals(year+"")) // 학년 match 확인 
        			return true;
        		
        		return false;
        	}
        ```

    - 3. 모든 필드 검색 (멀티키워드 검색 기능) 🍎🍎🍎

        - 입력 키워드 여러 개
        - 모든 키워드가 매치되어야 출력한다.

        - [x]  검색키워드 여러 개 빈칸으로 구분 : 0234 2 <- 입력 - 핸드폰 번호나 이름 full로 입력해야 출력되는데?
            - full name이 아니라 일부만 해당되어도 출력되는 방법이 있다.
            - equals() → contains()로 수정 : ex. 성 또는 이름
            - equals() → startsWith()로 수정 : ex. 학번 앞 네자리
            - equals() → endsWith()로 수정 : ex. 전화번호 끝 네자리

        ```java
        // 입력 Data - Set#1
        20161103 손하나 010-5324-0234 2
        20130320 김미미 010-2341-0234 2
        20171203 강천재 010-2341-0234 2
        20140320 JYP 010-2233-2341 4
        20151203 J코천 010-9999-2341 4
        20170321 JYP 010-2233-9999 1
        20150322 JYP 010-3535-8888 3
        0

        검색키워드 여러 개 빈칸으로 구분 : 0234 2 <- 입력 - 핸드폰 번호나 이름 full로 입력해야 출력되는데? => equals 메소드를 contains/startsWith/endsWith 메소드로 수정해야 한다.
        20161103 손하나 010-5324-0234 2 
        20130320 김미미 010-2341-0234 2
        20171203 강천재 010-2341-0234 2 <- 출력
        검색키워드 여러 개 빈칸으로 구분 : J 2341 4 <- 입력 
        20140320 JYP 010-2233-2341 4 <- 출력
        20151203 J코천 010-9999-2341 4 <- 출력

        // 입력 Data - Set#2 
        20161103 손하나 010-5324-2017 2 
        20130320 김미미 010-2341-2017 2
        20171203 강천재 010-2341-0234 2
        20140320 JYP 010-2233-2341 4
        20151203 J코천 010-9999-2341 4
        20170321 JYP 010-2233-9999 1
        20150322 JYP 010-3535-8888 3
        0

        검색키워드 여러 개 입력 (빈칸으로 구분) : 2017 <- 입력 - 만약 핸드폰 끝자리가 학번 앞자리와 일치하는 데이터가 입력된다면? 
        학번 20161103, 이름 손하나, 연락처 010-5324-2017 (2학년)
        학번 20130320, 이름 김미미, 연락처 010-2341-2017 (2학년)
        학번 20171203, 이름 강천재, 연락처 010-2341-0234 (2학년)
        학번 20170321, 이름 JYP, 연락처 010-2233-9999 (1학년) <- 출력 - 학번 앞자리/핸드폰 끝자리에 해당하는 모든 데이터가 출력된다. (OR조건 이므로) 
        ```

        ```java
        // DRY 원칙에 따라 matches 메소드를 여러 번 호출한다. (유사한 기능의 새로운 메소드를 생성하지 않도록 함)

        void search() {
        //		String nameInput = null;		
        		
        //		while(true) {
        //			System.out.print("이름 또는 학번 또는 연락처 : ");
        //			nameInput = scan.next();
        //			
        //			if(nameInput.equals("end")) // name이 string type이고 불변 객체를 가르키므로 equals 사용 가능 
        //				break; // 입력값이 end이면 cut해라. 
        //			
        //			for (Student st : studentList) { // 저장된 학생정보 studentList 중에서 name 필드의 값이 입력값 nameInput과 일치하면, print 해라. 
        //				if(st.matches(nameInput))
        //					st.print();
        //			}
        //		}
        		
        		// 1. 한 줄씩 입력받고 키워드를 여러 개로 쪼갠다.
        		String lineInput = null;
        		String[] kwdArr;
        		
        		while(true) {
        				System.out.print("검색키워드 여러 개 입력 (빈칸으로 구분) : ");
        				lineInput = scan.nextLine();
        				kwdArr = lineInput.split(" "); // split 메소드 : 빈칸(" ")으로 구분한 값들을 Array 형태로 반환한다.
        			
        				// 입력값이 end이면 cut해라. (선택)
        //			if (lineInput.equals("end"))
        //				break;

        				// 2. 학생 Class에게 여러 키워드를 전달하고, 매치되는 학생이 있는지 확인한다.
        				for (Student st : studentList) {
        						if(st.matches(kwdArr)) // parameter가 String type의 Array 이므로 matches메소드가 overloading 된다. (기존 matches의 parameter는 String type)
        								st.print();        // => matches(parameter String Array type)을 정의해야 한다.
        				}
        		}	
        }

        // overload (중복정의) : 동일한 이름의 메소드를 여러 개 생성한다. parameter type/개수 또는 return type을 다르게 지정한다.
        // cf. override (재정의) : SuperClass의 기능을 SubClass가 상속받아 재정의하여 사용한다. (상속 개념)

        public class Student {
        // ...

        boolean matches(String kwd) { // *필드 중 하나라도 match 되면 true를 반환한다. (OR 조건)
        		if(name.equals(kwd)) // 이름 match 확인 
        			return true;
        		if(kwd.length() > 1 && (id + "").startsWith(kwd)) // 학번 match 확인 (앞자리 또는 전체 번호로 확인)
        			return true;	
        		if(kwd.length() > 1 && phone.endsWith(kwd)) // 연락처 match 확인 (끝자리 또는 전체 번호로 확인)
        			return true;
        		if(kwd.equals(year + "")) // 학년 match 확인 - *숫자 1개 입력 시 year에만 매치하려면? -> 학번 및 연락처 부분에 kwd.length() > 1 && 추가
        			return true;
        		
        		return false;
        	}
        	
        	boolean matches(String[] kwds) { // *3. matches 메소드 overload
        		
        		for(String kwd : kwds) { // kwds Array의 element인 kwd를 하나씩 꺼내어 반복문을 실행한다.
        			if(!matches(kwd)) // 기존의 matches(parameter-string) 메소드를 사용한다!!!
        				return false; // 조건 - 입력된 키워드들이 모두 match해야 출력한다.(AND 조건) -> if(!matches) 즉, 키워드들 중에서 하나라도 match 하지 않으면 false를 반환한다. 
        		}         			  // 쪼개진 1개 element의 matches 결과가 true이면, if() 조건문의 결과는 false이다. 그리고 for문 다음 element로 넘어간다. 최종적으로 모든 elements matches 결과가 모두 true이면, true를 반환하여 출력한다.
        		
        		return true; // for문에서 모두 true를 만족한 것만 출력한다.
        	}
        // ...
        }
        ```

        - 코드

            ```java
            // Student Class
            import java.util.Scanner;

            public class Student {
            	
            	int id; // 학번
            	String name;
            	String phone;
            	int year; // 학년

            	void read(Scanner scan, int id) {
            		this.id = id;
            		name = scan.next();
            		phone = scan.next();
            		year = scan.nextInt();
            	}
            	
            	void print() {
            	System.out.format("학번 %d, 이름 %s, 연락처 %s (%d학년)\n", id, name, phone, year);
            	}

            	boolean matches(String kwd) { // *필드 중 하나라도 match 되면 true를 반환한다. (OR 조건)
            		if(name.equals(kwd)) // 이름 match 확인 
            			return true;
            		if(kwd.equals(id + "") || (id + "").startsWith(kwd)) // 학번 match 확인. *어떻게 1개의 parameter로 2개 필드를 비교하지? -> this.id을 int->String으로 형변환 (+"" 자동변환 활용)하여 처리한다!
            			return true;	
            		if(kwd.equals(phone) || phone.endsWith(kwd)) // 연락처 match 확인 
            			return true;
            		if(kwd.equals(year + "")) // 학년 match 확인
            			return true;
            		
            		return false;
            	}
            	
            	boolean matches(String[] kwds) { // *matches 메소드 overload
            		
            		for(String kwd : kwds) { // kwds Array의 element인 kwd를 하나씩 꺼내어 반복문을 실행한다.
            			if(!matches(kwd)) // 기존의 matches(parameter-string) 메소드를 사용한다!!!
            				return false; // 조건 - 입력된 키워드들이 모두 match해야 출력한다.(AND 조건) -> if(!matches) 즉, 키워드들 중에서 하나라도 match 하지 않으면 false를 반환한다.
            		}         			  // 쪼개진 1개 element의 matches 결과가 true이면, if() 조건문의 결과는 false이다. 그리고 for문 다음 element로 넘어간다. 최종적으로 모든 elements matches 결과가 모두 true이면, true를 반환하여 출력한다.
            		
            		return true; // for문에서 모두 true를 만족한 것만 출력한다.
            	}
            }

            // Department Class
            import java.util.ArrayList;
            import java.util.Scanner;

            public class Department {
            	Scanner scan = new Scanner(System.in);
            	
            	ArrayList<Student> studentList = new ArrayList<>();
            	
            	public static void main(String args[]) {
            		Department department = new Department(); // 학과 객체 생성  
            		department.run();
            		
            		department.search(); 
            	}
            	
            	void run() {
            //		Student st = null;		
            //		for (int i = 0; i < 5; i++) { // *ArrayList로 사용 저장
            //			st = new Student();
            //			st.read(scan);
            //			studentList.add(st);
            //		}
            //		
            //		for (Student st2 : studentList) { // *for-each로 출력  
            //			st2.print();
            //		}		
            		readAll();
            		printAll();
            	}
            	
            	void readAll() {		
            //		Student st = null;
            //		for (int i = 0; i < 5; i++) {   
            //			st = new Student();
            //			st.read(scan);
            //			studentList.add(st);
            //		}
            		int id;
            		while(true) {
            			id = scan.nextInt();
            			if (id == 0) break;
            			
            			Student st = new Student();
            			st.read(scan, id);
            			studentList.add(st);
            		}
            	}
            	
            	void printAll() {
            		for (Student st : studentList) {
            			st.print();
            		}
            	}
            	
            	// search 기능 추가 
            	void search() {
            //		String nameInput = null;		
            		
            //		while(true) {
            //			System.out.print("이름 또는 학번 또는 연락처 : ");
            //			nameInput = scan.next();
            //			
            //			if(nameInput.equals("end")) // name이 string type이고 불변 객체를 가르키므로 equals 사용 가능 
            //				break; // 입력값이 end이면 cut해라. 
            //			
            //			for (Student st : studentList) { // 저장된 학생정보 studentList 중에서 name 필드의 값이 입력값 nameInput과 일치하면, print 해라. 
            //				if(st.matches(nameInput))
            //					st.print();
            //			}
            //		}
            		
            		// 1. 한 줄씩 입력받고 키워드를 여러 개로 쪼갠다.
            		String lineInput = null;
            		String[] kwdArr;
            		
            		while(true) {
            			System.out.print("검색키워드 여러 개 입력 (빈칸으로 구분) : ");
            			lineInput = scan.nextLine();
            			kwdArr = lineInput.split(" "); //split 메소드 : 빈칸(" ")으로 구분한 값들을 Array 형태로 반환한다.
            			
            			// 입력값이 end이면 cut해라.
            //			if (lineInput.equals("end"))
            //				break;
            		
            			// 2. 학생 Class에게 여러 키워드를 전달하고, 매치되는 학생이 있는지 확인한다.
            			for (Student st : studentList) {
            				if(st.matches(kwdArr)) // parameter가 String type의 Array 이므로 matches메소드가 overloading 된다. => matches 정의 추가 필요
            					st.print();
            			}
            		}	
            	}
            }
            ```

    - 참고 - search 메소드 위치

        ```java
        public class Department {
        	Scanner scan = new Scanner(System.in);
        	
        	ArrayList<Student> studentList = new ArrayList<>();
        	
        	public static void main(String args[]) {
        		Department department = new Department(); // 학과 객체 생성  
        		department.run();
        		department.search(); 
        	}
        	
        	void run() {
        		readAll();
        		printAll();
        	}
        ```

        ```java
        public class Department {
        	Scanner scan = new Scanner(System.in);
        	
        	ArrayList<Student> studentList = new ArrayList<>();
        	
        	public static void main(String args[]) {
        		Department department = new Department(); // 학과 객체 생성  
        		department.run();
        	}
        	
        	void run() {
        		readAll();
        		printAll();
        		
        		search(); // 이게 더 적절하다.
        	}
        ```

    - 참고 - "검색키워드 여러 개 입력 (빈칸으로 구분) :"가 초기상태에서 2번 출력되는 이유
        - 사용자 입력값이 없어도 lineInput = scan.nextLine();이 실행되어 while문이 2번 돌아가기 때문이다.
        (while문 이전의 Scanner 때문이다. 즉, 입력을 종료하기 위해 사용자가 "0 + Enter key"를 했을 때, 개행문자가 buffer에 남아있기 때문이다.) 
        *개행문자 = 줄바꿈문자 = Enter key = \r\n
        - Scanner에 있는 개행문자를 비우기 위해 flush 함수가 필요하다. (현재 버퍼에 저장되어 있는 내용을 클라이언트로 전송하고 버퍼를 비운다.)
        근데 Scanner Class에는 flush가 없다. [https://vitalholic.tistory.com/42](https://vitalholic.tistory.com/42)
        따라서 임시방편으로 scan.nextLine를 집어넣어 개행문자를 처리하도록 한다.

        ```java
        void search() {
        		String lineInput = null; // *flush 임시방편-1. 변수 garbage0 생성 대신에 String[] kwdArr = scan.nextLine(); 도 가능함
        		String[] kwdArr;
        		
        		String garbage0 = null;
        		garbage0 = scan.nextLine(); // flush 임시방편-1. scan.nextLine를 집어넣는다.

        //  scan.skip("[\\r\\n]+"); // flush 임시방편-2. 이건 제대로 작동 안함

        //	int flag = 0; // flush 임시방편-3. flag를 활용해서 반복문 내부에 scan.nextLine를 집어넣는다.
        		
        		while (true) {
        			System.out.print("검색키워드 여러 개 입력 (빈칸으로 구분) :");
        			
        //			if (flag == 0) {
        //				garbage0 = scan.nextLine();
        //				flag = 1;
        //			}
        			
        			lineInput = scan.nextLine();
        			
        			if(lineInput.equals("end"))
        				break;
        			
        			kwdArr = lineInput.split(" ");
        			
        			for(Student st : studentList) {
        				if(st.matches(kwdArr))
        					st.print();
        			}
        		}
        	}
        ```

    - 4. 제외 키워드 기능
        - 키워드 첫 글자가 '-'이면 제외하는 기능을 추가한다.
        - '-' 키워드가 없어야 match된다.
        - '-'가 아니면 포함해야 한다.
            - 키워드에 '-'가 있는지 검사하는 기능이 필요하다.
            - 학생 데이터이므로 학생 Class에서 처리한다. 포함인지 제외인지 판단하여 matches 메소드를 실행한다. ??

        ```java
        // 알고리즘

        boolean matches(String[] kwds) {

        		for(String kwd : kwds) {
        				if(첫글자가 '-'고 그 키워드를 포함하면)
        						return false; // 해당 학생을 출력하지 않는다.
        				if(해당 키워드를 포함하지 않으면)
        						return false;
        		}

        		return true; // for문을 모두 만족하면 출력함
        }

        // 힌트
        // 1. 첫글자 따오기 : "String".charAt(0) -> 첫번째 문자 (기본 type char)를 반환한다. (기본 type이므로 == operator 사용 가능)
        // 2. '-'다음부터 끝까지에 해당하는 글자 따오기 : "String".substring(1)를 반환한다. (두번째 문자부터 끝까지에 해당하는 글자를 1개의 String으로 반환해주는 메소드)
        ```

        - 해보기
            - [x]  에러 발생 - 왜?
                - 에러메시지 중 내가 짠 코드 (charAt 등 기본메소드 제외)의 최상단 줄을 클릭
                - kwd.charAt(0) != '-' && 이 없으면 비정상 작동함
                → '-4'가 위 if문, 아래 if문 모두에서 작동하므로 '-4'에 해당하지 않는 st는 모두 false 처리됨

            ```swift
            // Student Class
            Boolean matches(String[] kwds) { // AND 조건 

            		for (String kwd : kwds) {
            			if (kwd.charAt(0) == '-' && matches(kwd.substring(1)))
            				return false; // -로 시작하면, 하나라도 매치하면 해당 st는 false
            			
            			if (kwd.charAt(0) != '-' && !matches(kwd)) // 이게 없으면 비정상 동작 - '-4'가 여기서도 작동하므로 -4에 해당하지 않는 st는 모두 false 처리됨 
            				return false; // -로 시작 안하면, 하나라도 매치하지 않으면 해당 st는 false
            		}
            			
            		return true;
            }

            // Data
            20140320 JYP 010-2233-2341 4 <- 입력
            20170321 JYP 010-2233-9999 1
            20150322 JYP 010-3535-8888 3
            0
            검색키워드 여러 개 입력 (빈칸으로 구분) : JYP -4 <- 키워드 입력
            학번 20170321, 이름 JYP, 연락처 010-2233-9999 (1학년) <- 출력
            학번 20150322, 이름 JYP, 연락처 010-3535-8888 (3학년)
            ```

    - 코드

        ```java
        원하는 기능을 입력하세요.
        (1) 전체 출력, (2) 점수 입력, (3) 검색 : 1 <- 초기 출력
        학번 20161103, 이름 손하나, 연락처 010-5324-0234 (2학년) 
        학번 20130320, 이름 김미미, 연락처 010-2341-0234 (2학년) 
        학번 20171203, 이름 강천재, 연락처 010-2341-0234 (2학년) 
        학번 20140320, 이름 JYP, 연락처 010-2233-2341 (4학년) 
        학번 20151203, 이름 J코천, 연락처 010-9999-2341 (4학년) 
        학번 20170321, 이름 JYP, 연락처 010-2233-9999 (1학년) 
        학번 20150322, 이름 JYP, 연락처 010-3535-8888 (3학년) 

        원하는 기능을 입력하세요.
        (1) 전체 출력, (2) 점수 입력, (3) 검색 : 2 <- 점수 입력 (Random)
        학생 점수 입력
        점수 입력 결과-2 손하나 : 36점
        점수 입력 결과-2 김미미 : 51점
        점수 입력 결과-2 강천재 : 69점
        점수 입력 결과-2 JYP : 82점
        점수 입력 결과-2 J코천 : 49점
        점수 입력 결과-2 JYP : 92점
        점수 입력 결과-2 JYP : 8점

        원하는 기능을 입력하세요.
        (1) 전체 출력, (2) 점수 입력, (3) 검색 : 1 <- 점수 입력 이후 출력 
        학번 20161103, 이름 손하나, 연락처 010-5324-0234 (2학년) 점수 36점

        학번 20130320, 이름 김미미, 연락처 010-2341-0234 (2학년) 점수 51점

        학번 20171203, 이름 강천재, 연락처 010-2341-0234 (2학년) 점수 69점

        학번 20140320, 이름 JYP, 연락처 010-2233-2341 (4학년) 점수 82점

        학번 20151203, 이름 J코천, 연락처 010-9999-2341 (4학년) 점수 49점

        학번 20170321, 이름 JYP, 연락처 010-2233-9999 (1학년) 점수 92점

        학번 20150322, 이름 JYP, 연락처 010-3535-8888 (3학년) 점수 8점
        ```

        ```java
        // Student Class
        import java.util.Scanner;
        import java.util.Random;

        public class Student {

        	int id;
        	String name;
        	String phone;
        	int year;
        	
        	int score; // 점수 필드 추가 
        	
        	void read(Scanner scan, int id) {
        		this.id = id;
        		name = scan.next();
        		phone = scan.next();
        		year = scan.nextInt();
        	}

        	static Random rand = new Random(); // 모든 Student가 공유하는 rand를 생성
        	void inputScore(Scanner scan) {
        //		System.out.printf("%s : ", name); // name을 출력함 (Student 객체에 대해)
        //		score = scan.nextInt(); // 점수를 입력받아서 필드 score에 저장함 (직접 입력)
        //		System.out.printf("점수 입력 결과-1 - %s : %d점\n", name, score); // 확인용 - 입력하자마자 출력함 

        		score = rand.nextInt(100) + 1;
        		System.out.printf("점수 입력 결과-2 %s : %d점\n", name, score); // 점수 입력이 귀찮으면 random 입력값 (1~100)을 임의로 할당하는 방법이 있다.
        	}
        	
        	void print() {
        		System.out.printf("학번 %d, 이름 %s, 연락처 %s (%d학년) ", id, name, phone, year);
        		if (score > 0) // 점수가 있으면 출력하고, 없으면 출력하지 않음 
        			System.out.printf("점수 %d점\n", score);
        		System.out.println(); // 모두 출력 이후 줄바꿈 1번
        	}
        	
        	Boolean matches(String kwd) { // OR 조건 - 하나라도 해당하면 true
        		if (name.equals(kwd)) // equals 대신 contentEquals가 엄밀히 더 적합함 
        			return true;
        		if (kwd.equals(id+""))
        			return true;
        		if (kwd.equals(phone))
        			return true;
        		if (kwd.equals(year+""))
        			return true;
        		return false;
        	}

        	Boolean matches(String[] kwds) { // AND 조건 - 입력한 line의 kwds에 모두 해당하는 student만 true
        		for (String kwd : kwds) {
        			if (kwd.charAt(0) == '-' && matches(kwd.substring(1)))
        				return false;
        			
        			if (kwd.charAt(0) != '-' && !matches(kwd))
        				return false;
        		}
        		return true;
        	}

        	void matchesScore() {
        		// ...
        	}
        }

        // Department Class
        import java.util.ArrayList;
        import java.util.Scanner;

        public class Department {
        	Scanner scan = new Scanner(System.in);
        	ArrayList<Student> studentList = new ArrayList<>();
        	
        	public static void main(String[] args) {
        		Department department = new Department();
        		department.run();
        		
        //		department.search(); // 여기가 아니라 run 메소드 내부에!!!
        	}
        	
        	void run() {
        		readAll();
        //		printAll();
        //		
        //		inputScores(); // 바로 실행하거나, 아래와 같이 메뉴를 통해 사용자가 원할 때 실행한다.
        		
        		int menu; // 지역변수 선언 시, 초기값을 주는 것이 바람직하지만 이 경우 Scanner를 통해 항상 입력받으므로 상관 없다.
        		
        		while(true) {
        			System.out.print("원하는 기능을 입력하세요.\n");
        			System.out.print("(1) 전체 출력, (2) 점수 입력, (3) 검색 : ");
        			
        			menu = scan.nextInt();
        			
        			switch(menu) { // 메뉴 사용과 같이 선택값가 적고, 조건이 중복되지 않을 때 switch문을 사용한다. if문을 여러 개 사용하는 것보다 가독성이 좋다.
        			case 1: printAll(); break;
        			case 2: inputScores(); break;
        			case 3: searchMenu(); break; // 검색 관련 세부메뉴를 선택하도록 함
        			default: System.out.print("해당 기능이 없습니다."); break;
        			}
        		}
        	}
        	
        	void searchMenu() {
        		int menu2;
        		
        		while(true) {
        			System.out.print("(3) 검색과 관련하여 원하는 세부 기능을 입력하세요.\n");
        			System.out.print("(1) 학번/이름 검색, (2) 통합 검색, (3) 점수 검색, (4) 멀티키워드 검색 : ");
        			
        			menu2 = scan.nextInt();
        			
        			switch(menu2) { 
        			case 1: search(); break;
        			case 2: search(); break;
        			case 3: searchScores(); break; // 1단계에서 (2) 점수 입력을 하지 않으면 default 값이 출력된다.
        			case 4: search(); break;
        			default: System.out.print("해당 기능이 없습니다."); break;
        			}
        		}
        	}

        	void readAll() {
        //		Student st = null;
        //		for(int i = 0; i < 5; i++) {
        //			st = new Student();
        //			st.read(scan);
        //			studentList.add(st);
        //		}
        		
        		int id;
        		
        		while(true) {
        			id = scan.nextInt();
        			if (id == 0) 
        				break;
        			
        			Student st = new Student();
        			st.read(scan, id);
        			studentList.add(st);
        		}	
        	}
        	
        	void printAll() {
        		for (Student st : studentList) {
        			st.print();
        		}
        	}
        	
        	void search() {
        		String lineInput = null;
        		String[] kwdArr; // 변수 garbage0 생성 대신에 String[] kwdArr = scan.nextLine(); 도 가능함 
        		
        		String garbage0 = null;
        		garbage0 = scan.nextLine();
        		
        		while (true) {
        			System.out.print("검색키워드 여러 개 입력 (빈칸으로 구분) : ");
        			lineInput = scan.nextLine();
        			
        			if(lineInput.equals("end"))
        				break;
        			
        			kwdArr = lineInput.split(" ");
        			
        			for(Student st : studentList) {
        				if(st.matches(kwdArr))
        					st.print();
        			}	
        		}
        	}
        	
        	void inputScores() {
        		System.out.println("학생 점수 입력");
        		for (Student st : studentList) {
        			st.inputScore(scan);
        		}
        	}

        	void searchScores() {
        		// ... 
        		for (Student st : studentList) {
        			st.matchesScore(); 
        		}
        	}	
        }
        ```

- Class 설계원칙-4. OCP (Open Close Principle)
    - Class는 확장에는 열려있고, 변경에는 닫혀있어야 한다.
    - 확장 (상속 개념) 가능성은 극대화하고, 변경을 위한 비용은 가능한 줄여야 한다. (변경해도 다른 Class에 영향이 적음)
    - 변경에 닫혀있기 위해서
    - Class 외부에서 접근하는 것을 최소화한다. (private 등 접근권한을 최소로 열어준다.)
    - 해당 데이터를 취급하는 외부 Class에 필요한 지점에서 메소드를 통해 접근하도록 한다.

## 7-3. 점수와 메뉴

학생의 점수를 입력 및 검색하는 기능을 추가한다.

- 학생의 점수이므로 SRP 원칙에 따라 학생 Class에 기능을 구현한다.
    - 1. 점수 입력 : 학생 이름을 차례로 보여주고, 학생별 점수를 입력하는 함수 추가 (Department Class-inputScores)

        - Top-down 방식
           1) department 객체의 myMain 역할 함수(run)에서 inputScores 함수 실행하도록 함
           2) Department Class의 inputScores 함수 정의
           3) 학생의 점수를 입력하기 위해 score 필드 추가, Student Class의 inputScore 함수 정의

        ```java
        // Department Class
        void run() {
        		readAll();
        		printAll();
        		
        		inputScores();
        }

        void inputScores() {
        		System.out.println("학생 점수 입력");
        		for (Student st : studentList) {
        			st.inputScore(scan)
        		}
        }

        // Student Class
        int score; // 점수 필드 추가

        void inputScore(Scanner scan) {
        		System.out.printf("%s : ", name); // name을 출력함 (Student 객체1에 대해)
        		score = scan.nextInt(); // 점수를 입력받아서 필드 score에 저장함
        		System.out.printf("점수 입력 결과 - %s : %d점\n", name, score); // 확인용 - 입력하자마자 출력 

        //	score = random.nextInt(100) + 1;
        //	System.out.printf("%s : %d점", name, score); // 점수 입력이 귀찮으면 random 입력값 (1~100)을 임의로 할당하는 방법이 있다.
        }
        ```

    - 2. 점수 출력 : 기존의 출력 함수(Student Class의 print) 수정 X, Student Class의 inputScore를 통해 바로 출력함
    - 3. 점수 검색 및 메뉴 구성 : 기존의 검색 함수((Student Class의 matches) 수정, 점수 구간에 해당하는지 확인하는 함수 추가 (Department Class-searchScore)
        - 구현 :  점수 구간 (~이상 ~미만) 2개 숫자를 입력받아 검색한다. (ex. 70 90 : 70 이상 90미만)
                  ~이상 또는 ~미만으로 표시할 때는 1개 숫자 및 '-'을 입력한다. (ex. 90 - : 90 이상, - 60 : 60 미만)
            - 입력 처리
            - '-'을 입력 가능하므로 nextInt()가 아니라 next()로 읽어야 한다. (InputMismatchException 오류 발생)
            - '-'가 입력된 경우, 앞이면 0 이상, 뒤면 101 미만으로 인식하도록 한다.
            - '-'가 입력되지 않은 경우, parseInt 함수를 통해 string→int 형변환을 해준다.
            - 이러한 처리를 누가 담당?
            - 방법-1. 학생 Class에서 한다. (학과는 String 2개를 넘김)
            - 방법-2. 학과 Class에서 한다. (학생에게 숫자 2개를 넘김)
            - SRP 원칙에 따라 입력 처리는 학생 고유 데이터가 아니라, 검색 방식 및 데이터 전처리 등 시스템적 처리이므로 학과 Class에서 담당해야 한다. → 방법-2 선택
            (엄밀히 말하면 검색의 제외 키워드 '-' 처리도 학과 Class에서 담당해야 하지만, minor 하기 때문에 Student Class에서 처리했음)
                - OOP 방식의 코딩
                - Student (요소 Class, Data Access Object)는 자기 것만 처리하고, 여러 학생을 다루는 것은 Department (관리 Class)에서 처리한다. Department는 Student의 메소드를 호출해서 작업을 시킨다. (for loop, arrayList)
                - Main 또는 관리 Class는 일반적으로 처리하는 작업이 많고 커진다. 가능하면 세부적인 일은 다른 Class로 위임하고, 큰 덩어리의 일만 한다. (Anti-pattern. 모든 일을 수행하는 God Class가 되면 안된다.)
                - Student Class에 inputScore, matchScore 등 짧은 메소드를 만들어도 고성능의 컴파일러가 인라이닝을 해주므로 성능이 저하되지 않는다.
                - 모든 필드에 get, set을 만드는 것은 좋지 않다.
        - 구현 : 메뉴 구성
        - 다양한 기능을 만들었으므로 메뉴를 통해 단계별로 기능을 제공 가능하다.
        - 사용자가 원하는 기능을 사용할 수 있도록 유도한다. (데이터 입력이 완료된 상태에서)
          ex. 메뉴 1단계 : (1) 전체 출력, (2) 점수 입력, (3) 검색
                메뉴 2단계 (1단계 (3) 검색 선택 시 세부메뉴) : (1) 학번/이름 검색, (2) 통합 검색, (3) 점수 검색, (4) 멀티키워드 검색
            - 메뉴 사용 시 Switch문을 사용한다.

                ```java
                void run() {
                //		readAll();
                //		printAll();
                //		
                //		inputScores(); // 바로 실행하거나, 아래와 같이 메뉴를 통해 사용자가 원할 때 실행한다.
                		
                		int menu; // 지역변수 선언 시, 초기값을 주는 것이 바람직하지만 이 경우 Scanner를 통해 항상 입력받으므로 상관 없다.
                		
                		while(true) {
                			System.out.print("원하는 기능을 입력하세요.\n");
                			System.out.print("(1) 전체 출력, (2) 점수 입력, (3) 검색 : ");
                			
                			menu = scan.nextInt();
                			
                			switch(menu) { // 메뉴 사용과 같이 선택값가 적고, 조건이 중복되지 않을 때 switch문을 사용한다. if문을 여러 개 사용하는 것보다 가독성이 좋다.
                			case 1: printAll(); break;
                			case 2: inputScores(); break;
                			case 3: searchMenu(); break; // 검색 관련 세부메뉴를 선택하도록 함
                			default: System.out.print("해당 기능이 없습니다."); break;
                			}
                		}
                	}
                	
                	void searchMenu() { // 세부메뉴
                		int menu2;
                		
                		while(true) {
                			System.out.print("(3) 검색과 관련하여 원하는 세부 기능을 입력하세요.\n");
                			System.out.print("(1) 학번/이름 검색, (2) 통합 검색, (3) 점수 검색, (4) 멀티키워드 검색 : ");
                			
                			menu2 = scan.nextInt();
                			
                			switch(menu2) { 
                			case 1: search(); break;
                			case 2: search(); break;
                			case 3: searchScores(); break; // 1단계에서 (2) 점수 입력을 하지 않으면 default 값이 출력된다.
                			case 4: search(); break;
                			default: System.out.print("해당 기능이 없습니다."); break;
                			}		
                }

                private void searchScores() {
                		// ...		
                }
                ```

            - Console

                ```java
                20161103 손하나 010-5324-0234 2 <- 데이터 입력
                20130320 김미미 010-2341-0234 2
                20171203 강천재 010-2341-0234 2
                20140320 JYP 010-2233-2341 4
                20151203 J코천 010-9999-2341 4
                20170321 JYP 010-2233-9999 1
                20150322 JYP 010-3535-8888 3
                0 
                원하는 기능을 입력하세요. <- 메뉴 선택 기능
                (1) 전체 출력, (2) 점수 입력, (3) 검색 : 1 <- 사용자 1 입력 시
                학번 20161103, 이름 손하나, 연락처 010-5324-0234 (2학년) <- 데이터 출력
                학번 20130320, 이름 김미미, 연락처 010-2341-0234 (2학년)
                학번 20171203, 이름 강천재, 연락처 010-2341-0234 (2학년)
                학번 20140320, 이름 JYP, 연락처 010-2233-2341 (4학년)
                학번 20151203, 이름 J코천, 연락처 010-9999-2341 (4학년)
                학번 20170321, 이름 JYP, 연락처 010-2233-9999 (1학년)
                학번 20150322, 이름 JYP, 연락처 010-3535-8888 (3학년)
                원하는 기능을 입력하세요.
                (1) 전체 출력, (2) 점수 입력, (3) 검색 : 2 <- 사용자 2 입력 시
                학생 점수 입력
                손하나 : 1
                점수 입력 결과 - 손하나 : 1점
                김미미 : 2
                점수 입력 결과 - 김미미 : 2점
                강천재 : 3
                점수 입력 결과 - 강천재 : 3점
                JYP : 4
                점수 입력 결과 - JYP : 4점
                J코천 : 5
                점수 입력 결과 - J코천 : 5점
                JYP : 6
                점수 입력 결과 - JYP : 6점
                JYP : 7
                점수 입력 결과 - JYP : 7점
                원하는 기능을 입력하세요.
                (1) 전체 출력, (2) 점수 입력, (3) 검색 : 3 <- 사용자 3 입력 시
                (3) 검색과 관련하여 원하는 세부 기능을 입력하세요. <- 세부메뉴 선택 기능
                (1) 학번/이름 검색, (2) 통합 검색, (3) 점수 검색, (4) 멀티키워드 검색 : 2
                검색키워드 여러 개 입력 (빈칸으로 구분) : JYP
                학번 20140320, 이름 JYP, 연락처 010-2233-2341 (4학년)
                학번 20170321, 이름 JYP, 연락처 010-2233-9999 (1학년)
                학번 20150322, 이름 JYP, 연락처 010-3535-8888 (3학년)
                검색키워드 여러 개 입력 (빈칸으로 구분) : JYP 4
                학번 20140320, 이름 JYP, 연락처 010-2233-2341 (4학년)
                검색키워드 여러 개 입력 (빈칸으로 구분) :
                ```

    - Class 다이어그램

        ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%209.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%209.png)

        - 필드 앞의 '-'는 private을 의미함
        - 각 Class의 필드 및 메소드를 확인 가능함

## 7-4. 팀 기능 추가

- 새로운 기능을 위해 Class 추가가 필요한 경우
    - ex. 구현 - 수업 기능을 추가해서 학생이 수강하는 수업을 학과에서 관리
    - 수업은 데이터를 가지므로 Class로 추가 (학생이 수업 데이터를 모두 가질 수 없음)
    - ex. 구현 - 학생이 팀을 구성하여 한 팀에 여러 학생이 소속
    - 팀은 데이터를 가지므로 Class로 추가 (학생이 팀 정보를 모두 가질 수 없음)

- 기능 설계
    - 팀 Data

        ```java
        A 1 2 7 0 // 1,2,7번 학생이 A팀이다. 끝 (0)
        B 4 6 0
        C 3 5 0
        end // 팀 정보 끝 (end)
        ```

    1. 팀 입력 및 출력 기능
    - A : A팀 소속 학생이름...
       B : ...
    2. 팀 검색
    - 팀 이름으로 검색
    - 학생 이름으로 팀 검색
    - 학생 학번으로 팀 검색
    3. 학생 출력 시 팀 정보를 포함

- Class 관계 분석
    - 팀 정보에 학생이 들어 있음 (팀이 학생 여러 명을 포함)
    - 팀 검색에서 학생 matches 필요
    - 학생은 팀 이름을 출력해야 함 (학생은 팀이 없거나 1개)

    → 즉, 팀은 학생을 0~n명 가지고, 학생은 팀이 0~1개 가진다.

    ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%2010.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%2010.png)

### 팀 Class 추가

- 방법-1. 팀이 학생번호를 저장

    ```java
    import java.util.ArrayList;
    import java.util.Scanner;

    class Team {
    	String teamName;
    	ArrayList<Integer> members = new ArrayList<>(); // members 변수에 학생번호를 저장하여 팀원을 표시한다.
    	
    	Team(String name) {
    		teamName = name; 
    	}
    	
    	void read(Scanner scan) {
    		int studentNumber = 0;
    		
    		while(true) {
    			studentNumber = scan.nextInt();
    			if (studentNumber == 0)
    				break;
    			members.add(studentNumber); // 0이 아니면 학생번호를 arrayList에 추가해준다.
    		}
    	}
    }
    ```

    - 문제점
        - 출력할 때 : 번호로 학생이름을 찾아야 한다.
        - 검색할 때 : 번호로 학생을 찾아 학생의 matches를 호출해야 한다.
        - 성능 측면 : 팀 입력은 한 번이지만 출력/검색은 여러 번 호출 가능하다. 따라서 번호로 학생을 찾는 작업이 반복된다. 
        → 개선 : 팀이 학생번호가 아니라 학생 객체를 저장한다. (입력할 때 해당 객체를 찾아두면 바로 접근 가능하다. 해당하는 학생이름 또는 matches를 바로 불러올 수 있다. 번호로 찾는 과정을 생략한다.)
            즉, 팀의 arrayList가 student 객체를 가진다. (팀에 소속된 학생의 객체만)
        - 메모리 크기 : 번호나 학생 참조나 동일하게 4B이다.
- 방법-2. 팀이 학생 객체를 저장
    - [ ]  teamName = name; // 이게 getter ?  왜 하지?

    ```java
    // 1
    import java.util.ArrayList;
    import java.util.Scanner;

    class Team {
    	String teamName; // A,B,C팀
    //	ArrayList<Integer> members = new ArrayList<>();
    	ArrayList<Student> members = new ArrayList<>(); // members 변수에 학생 객체를 저장하여 팀원을 표시한다.
    	
    	Team(String name) {
    		teamName = name; // 이게 getter ? 
    	}
    	
    	void read(Scanner scan) {
    		int studentNumber = 0;
    		Student st = null;
    		
    		while(true) {
    			studentNumber = scan.nextInt();
    			if (studentNumber == 0)
    				break;
    //			members.add(studentNumber);
    			st = findStudent(studentNumber); // 학생의 참조를 찾아서 (단, Team Class에서 어떻게 Department Class의 findStudent 메소드를 호출할까? -> 학과객체.findStudent로 수정)
    			members.add(st); // 학생 객체를 members에 추가해준다. 
    		}
    	}
    }
    ```

    - findStudent 메소드는 누가 담당?
        - 학생 여러 명을 가지고 있으므로 찾는 것은 학과 Class가 해야 한다. (studentList를 가지는 학과 Class가 해야 한다.)

            ```java
            Student findStudent(int studentNumber) {  // return type Student
            		if (studentNumber <= 0 || studentNumber > studentList.size()) // 잘못된 학생번호 처리
            				return null;
            		return studentList.get(studentNumber - 1);  // get(index) - index 0부터 시작하므로 -1 한다.
            } // arrayList의 get 메소드를 통해 찾은 학생 개체를 return 한다.
            ```

        - Team Class에서 어떻게 Department Class의 findStudent 메소드를 호출할까?
        - 학과 객체.findStudent(번호)로 호출한다. 
        - 학과 객체를 팀이 어떻게 알지?
            - 학과 객체란?
            - main에서 new했던 객체  `Department department = new Department();`  `department.run();`
            - findStudent 입장에서는 this 객체 (Department Class 내부에 findStudent 메소드가 있으므로)
            - 팀 Class의 read 메소드에서는 알 수 없음

                → 따라서 팀 Class의 read 메소드에게 학과의 this를 넘겨준다. (팀 Class가 this를 이용할 수 있도록)
                    "(학과 입장에서) 팀 t, 너는 scan으로 입력을 하다가, 학생을 찾을 일이 있으면 this를 통해 나한테 요청해라"

                ```java
                main()에서 Department/department.run
                run()에서 Department/this.readTeams() - Department Class의 run 메소드 내부에 readTeams 메소드가 있다. 이때 this는 객체 department
                	readTeams()에서 Team/t.read(scan) - readTeams에서 Team에게 read 메소드를 호출시킨다. *Team Class의 read 메소드에게 학과의 this를 넘겨준다. Team에게 this를 준다.
                		Team의 read()에서 Department/OOO.findStudent() - 즉, OOO은 this (학과 객체)이다. 
                ```

                → 팀 Class는 매개변수로 받은 학과를 이용해서 findStudent를 호출한다.

                ```java
                main()에서 Department/department.run
                run()에서 Department/this.readTeams()
                	readTeams()에서 Team/t.read(scan, this) - 매개변수로 this를 받은 후에
                		Team의 read()에서 Department/department.findStudent() - findStudent를 호출한다.
                ```

                ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%2011.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%2011.png)

            - 코드 수정

                ```java
                // 2
                import java.util.ArrayList;
                import java.util.Scanner;

                class Team {
                	String teamName;
                //	ArrayList<Integer> members = new ArrayList<>();
                	ArrayList<Student> members = new ArrayList<>(); // members 변수에 학생 객체를 저장하여 팀원을 표시한다.
                	
                	Team(String name) {
                		teamName = name; // 이게 getter ? 
                	}
                	
                	void read(Scanner scan, Department department) { // 매개변수로 department를 받은 후에
                		int studentNumber = 0;
                		Student st = null;
                		
                		while(true) {
                			studentNumber = scan.nextInt();
                			if (studentNumber == 0)
                				break;
                //			members.add(studentNumber);
                			st = department.findStudent(studentNumber); // 학생의 참조를 찾아서. "(팀 입장에서) 학과, 너는 이 번호에 해당하는 학생을 찾아줘"
                			members.add(st); // 학생 객체를 members에 추가해준다. 
                		}
                	}
                }
                ```

- Class 다이어그램 (KOCW-팀기능 추가하기 18min)

    ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%209.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%209.png)

    ![OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%2012.png](OOP%20(Java)%20dd6061d9d8954db2839d6acfe1958a90/Untitled%2012.png)

### 팀 출력 (팀에서 학생이름을 출력하는 기능)

- 팀 Class의 members arrayList가 학생 참조를 가지고 있으므로 바로 출력 가능하다.
- 학생의 필드인 name을 여기서 접근? - 학생에서 name을 돌려주는 get 함수를 만드는 방법도 있으나, st.name으로 바로 접근하는 것도 가능하다.
- members에 대해 for each문으로 반복한다.
    - [ ]  // teamName A, B, C 각각 객체를 생성하는 건가? 왜 teamName에 대한 for문이 없지?

    ```java
    // Team Class
    void print() { 
    		System.out.printf("%s팀 소속 : ", teamName); // teamName A, B, C 각각 객체를 생성하는 건가? 왜 teamName에 대한 for문이 없지?
    		
    		for (Student st : members) { // members arrayList에 학생 객체가 들어있다. 따라서 st.name으로 접근 가능하다.
    			System.out.printf("%s ", st.name);
    		}

    		System.out.println();
    }
    // A : 손케빈, 김미미, JYP <- 형태로 출력
    // B : J비코, 곽철용
    // C : JYP, JYP 
    ```

### 학생에 팀 정보 저장하기

- 학생에 팀 필드 추가

    ```java
    // Student Class
    Team myTeam;

    void setTeam(Team t) { // 입력 이후 나중에 팀을 지정하는 구조이므로 setter가 필요하다. (최소한 사용하는 것이 좋지만)
    	// ...
    }
    ```

- 학생의 팀 필드를 설정
- 팀 Class에서 Team 객체가 members(자신의 팀원 정보)를 read 메소드를 통해 읽을 때, 학생의 팀을 알게 된다.
- 그때 학생에게 팀을 설정하라고 팀 자신을 전달한다. `st.setTeam(this);` (즉, A팀의 members인 1,2,6 학생에게 'A팀 소속이다'라고 팀 자신을 전달한다. "학생 1, 너는 학생 필드를 this(A팀)로 설정해라")
- 어디에 추가?

    ```java
    void read(Scanner scan, Department department) { 
    		int studentNumber = 0;
    		Student st = null;
    		
    		while(true) {
    			studentNumber = scan.nextInt();
    			if (studentNumber == 0)
    				break;
    			st = department.findStudent(studentNumber); 
    			st.setTeam(this);  // 학생에게 팀을 설정하라고 팀 자신을 전달한다.
    			members.add(st); 
    		}
    	}
    ```

- 코드

    ```java
    // Student Class
    import java.util.Scanner;
    import java.util.Random;

    public class Student {

    	int id;
    	String name;
    	String phone;
    	int year;
    	
    	int score; // 점수 필드 추가 
    	
    	Team myTeam; // 팀 필드 추가 - 지역변수 (함수 내부)가 아니라 필드 이므로 Team myTeam = null; 하지 않아도 자동으로 초기화된다.
    	
    	void read(Scanner scan, int id) {
    		this.id = id;
    		name = scan.next();
    		phone = scan.next();
    		year = scan.nextInt();
    	}
    	
    	static Random rand = new Random(); // 모든 Student가 공유하는 rand를 생성 
    	void inputScore(Scanner scan) {
    //		System.out.printf("%s : ", name); // name을 출력함 (Student 객체에 대해)
    //		score = scan.nextInt(); // 점수를 입력받아서 필드 score에 저장함 
    //		System.out.printf("점수 입력 결과-1 - %s : %d점\n", name, score); // 확인용 - 입력하자마자 출력함 

    		score = rand.nextInt(100) + 1;
    		System.out.printf("점수 입력 결과-2 %s : %d점\n", name, score); // 점수 입력이 귀찮으면 random 입력값 (1~100)을 임의로 할당하는 방법이 있다.
    	}
    	
    	void print() {
    		System.out.printf("학번 %d, 이름 %s, 연락처 %s (%d학년) ", id, name, phone, year);
    		if (score > 0) // 점수가 있으면 출력하고, 없으면 출력하지 않음 
    			System.out.printf("점수 %d점\n", score);
    		System.out.println(); // 모두 출력 이후 줄바꿈 1번 
    	}
    	
    	Boolean matches(String kwd) { // OR 조건 - 하나라도 해당하면 true
    		if (name.equals(kwd)) // equals 대신 contentEquals가 엄밀히 더 적합함 
    			return true;
    		if (kwd.equals(id+""))
    			return true;
    		if (kwd.equals(phone))
    			return true;
    		if (kwd.equals(year+""))
    			return true;
    		
    		return false;
    	}

    	Boolean matches(String[] kwds) { // AND 조건 - 입력한 line의 kwds에 모두 해당하는 student만 true

    		for (String kwd : kwds) {
    			if (kwd.charAt(0) == '-' && matches(kwd.substring(1)))
    				return false;
    			
    			if (kwd.charAt(0) != '-' && !matches(kwd))
    				return false;
    		}
    			
    		return true;
    	}
    		
    	void matchesScore() {
    		// ...
    	}

    	void setTeam(Team t) { // setTeam 메소드 추가
    		// ...
    	}
    }

    // Department Class
    import java.util.ArrayList;
    import java.util.Scanner;

    public class Department {
    	Scanner scan = new Scanner(System.in);
    	ArrayList<Student> studentList = new ArrayList<>();
    	
    	public static void main(String[] args) {
    		Department department = new Department();
    		department.run();		
    //	department.search(); // 여기가 아니라 run 메소드 내부에!!!
    	}
    	
    	void run() {
    		readAll();
    //		printAll();		
    //		inputScores(); // 바로 실행하거나, 아래와 같이 메뉴를 통해 사용자가 원할 때 실행한다.
    		
    		int menu; // 지역변수 선언 시, 초기값을 주는 것이 바람직하지만 이 경우 Scanner를 통해 항상 입력받으므로 상관 없다.
    		
    		while(true) {
    			System.out.print("원하는 기능을 입력하세요.\n");
    			System.out.print("(1) 전체 출력, (2) 점수 입력, (3) 검색, (4) 팀 입력 : ");
    			
    			menu = scan.nextInt();
    			
    			switch(menu) { // 메뉴 사용과 같이 선택값가 적고, 조건이 중복되지 않을 때 switch문을 사용한다. if문을 여러 개 사용하는 것보다 가독성이 좋다.
    			case 1: printAll(); break;
    			case 2: inputScores(); break;
    			case 3: searchMenu(); break; // 검색 관련 세부메뉴를 선택하도록 함
    			case 4: this.readTeams(); break; // case 4: readTeams(); break; 과 동일함 
    			default: System.out.print("해당 기능이 없습니다."); break;
    			}
    		}
    	}
    	
    	void searchMenu() {
    		int menu2;
    		
    		while(true) {
    			System.out.print("(3) 검색과 관련하여 원하는 세부 기능을 입력하세요.\n");
    			System.out.print("(1) 학번/이름 검색, (2) 통합 검색, (3) 점수 검색, (4) 멀티키워드 검색 : ");
    			
    			menu2 = scan.nextInt();
    			
    			switch(menu2) { 
    			case 1: search(); break;
    			case 2: search(); break;
    			case 3: searchScores(); break; // 1단계에서 (2) 점수 입력을 하지 않으면 default 값이 출력된다.
    			case 4: search(); break;
    			default: System.out.print("해당 기능이 없습니다."); break;
    			}
    		}
    	}

    	void readAll() {
    		int id;
    		
    		while(true) {
    			id = scan.nextInt();
    			if (id == 0) 
    				break;
    			
    			Student st = new Student();
    			st.read(scan, id);
    			studentList.add(st);
    		}	
    	}
    	
    	void printAll() {
    		for (Student st : studentList) {
    			st.print();
    		}
    	}
    	
    	void search() {
    		String lineInput = null;
    		String[] kwdArr; // 변수 garbage0 생성 대신에 String[] kwdArr = scan.nextLine(); 도 가능함 
    		
    		String garbage0 = null;
    		garbage0 = scan.nextLine();
    		
    		while (true) {
    			System.out.print("검색키워드 여러 개 입력 (빈칸으로 구분) : ");
    			lineInput = scan.nextLine();
    			
    			if(lineInput.equals("end"))
    				break;
    			
    			kwdArr = lineInput.split(" ");
    			
    			for(Student st : studentList) {
    				if(st.matches(kwdArr))
    					st.print();
    			}	
    		}
    	}
    	
    	void inputScores() {
    		System.out.println("학생 점수 입력");
    		for (Student st : studentList) {
    			st.inputScore(scan);
    		}
    	}
    	
    	void searchScores() {
    		// ... 
    		for (Student st : studentList) {
    			st.matchesScore(); 
    		}
    	}
    	
    	void readTeams() {
    		// ...
    	}

    	Student findStudent(int studentNumber) {  // return type Student
    		if (studentNumber <= 0 || studentNumber > studentList.size()) // 잘못된 학생번호 처리
    			return null;
    		
    		return studentList.get(studentNumber - 1);  // get(index) - index 0부터 시작하므로 -1 한다.
    	} // arrayList의 get 메소드를 통해 찾은 학생 개체를 return 한다.
    	
    }

    // Team Class - 추가
    import java.util.ArrayList;
    import java.util.Scanner;

    class Team {
    	String teamName;
    //	ArrayList<Integer> members = new ArrayList<>();
    	ArrayList<Student> members = new ArrayList<>();
    	
    	Team(String name) {
    		teamName = name; // 이게 getter ? 
    	}
    	
    	void read(Scanner scan, Department department) {
    		int studentNumber = 0;		
    		Student st = null;
    		
    		while(true) {
    			studentNumber = scan.nextInt();
    			if (studentNumber == 0)
    				break;
    //			members.add(studentNumber);
    			st = department.findStudent(studentNumber);
    			st.setTeam(this);
    			members.add(st);
    		}
    	}
    	
    	void print() {
    		System.out.printf("%s팀 소속 : ", teamName);
    		
    		for (Student st : members) { // members arrayList에 학생 객체가 들어있다. 따라서 st.name으로 접근 가능하다.
    			System.out.printf("%s ", st.name);
    		}
    		System.out.println();
    	}
    }
    ```

- 필드 및 지역변수의 초기화 차이
    - 지역변수는 항상 초기화해야 한다.
    - 초기화하지 않으면 오류 발생 가능성이 있으므로 컴파일 오류가 발생한다. (단, 선언 직후에 바로 설정할 변수는 초기화하지 않아도 된다. 그러나 바람직하지 않다.  `int a;`  `a = 10;` )
    - `int x = 0;` 으로 수정해야 한다.
    - 참조 변수는 `Student st = null;`로 초기화해야 한다.

        ```java
        void run() {
        		int n = 10, x;  // 지역변수 x. Uninitialized variable 컴파일 오류 발생 - The local variable x may not have been initialized.

        		while(true) {
        				try {
        						x = scan.nextInt(); // 1. 여기서 x 입력값이 없으면
        				} catch (Exception e) {
        						System.out.println("0으로 나누어짐. 오류"); 
        						break; // 2. break를 하고
        				}
        		}

        		System.out.printf("%d %d\n", n, x); // 3. x 값을 출력해야 하는데, 입력값이 없으므로 오류 발생 가능성이 있다. 따라서 (입력값이 있더라도) 컴파일 시 오류를 발생시킨다.
        }
        ```

    - 필드는 자동으로 초기화된다.
    - 0으로 초기화된다. (참조는 null로 초기화된다.)
    - 필드의 초기값은 객체가 new 될 때 바로 설정된다.

        ```java
        Team myTeam; // 팀 필드 추가 - 지역변수 (함수 내부)가 아니라 필드 이므로 Team myTeam = null; 하지 않아도 자동으로 초기화된다.
        ```

## 수강신청 기능 추가

- Class 설계원칙 - SOLID
    1. SRP (Single Responsibility Principle)
    2. OCP (Open Close Principle)
    3. LSP
    4. ISP
    5. DIP

## 연관검색 기능

## 수강신청 코딩

# 8. 상속

## 파일 입력

## Book Class

## 서점 Class

## Interface 상속

## Book 상속 코딩

## Interface 코딩

# 9. Interface로 코드 재사용
