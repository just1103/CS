# SNU 컴공개론학

Created: April 19, 2021 2:34 PM
Created By: hyoju son
Last Edited Time: July 13, 2021 4:37 PM
Property: 서울대_민상렬T
Type: CS

- Contents
    - 강의 Link : [https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K](https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K)

# 1. Bit, Data Type

- Digital System
    - Digital System : 표현하는 정보 심볼이 유한한 개수인 시스템이다. 
    그 중 심볼이 0,1만 있는 것이 Binary System이다. (0은 0~0.5V, 1은 2.4~2.9V-Volts) Computer는 binary digital system이다.
    - 정보의 기본 단위는 Bit (Binary Digit)이다.
    - 컴퓨터에서 취급하는 데이터는 instruction (operation 대상), number, logical (bool), text (string), image (pixel) 등이다.
    - PC = 메모리 (주소마다 binary data가 들어있음), CPU (Processor, Program Counter-다음에 수행해야할 instruction의 주소가 들어있음)
    *instruction : 어떤 주소에 있는 값을 연산하여 결과값을 어떤 주소에 할당해라 등의 작업이 해당된다. 다음에 실행될 instruction을 지정한다.
- Number
    - Two's Complement
    - 0의 표현방법이 2개임 (+0, -0)
    - solution : X + (-X) = 0을 성립시키는 -X의 값을 기준으로 함
    - Overflow
    - If operands(피연산자) are too big, then sum cannot be represented as an n-bit 2's complement number.
    - 실제로 2진수 연산과정에서 양수+양수=음수, 또는 음수+음수=양수 등 비정상적인 결과값이 나온다!
    - Fractions (분수)
        1. Fixed-Point : ex) 0.00000001. 단점은 0000...을 표현하기 위해 메모리 소모가 크다.
        2. Floating-Point : ex) F x 2^E (F: fraction, E: exponent-지수)
- 요약
- 메모리의 내용은 단순히 0,1의 패턴이다.
- 그것을 Program Counter가 가르키고 있으면 instruction으로 해석된다.
- 이 instruction은 서로 다른 메모리 주소에 있는 데이터를 참조하는데, 그 instruction이 integer로 간주하면 해당 데이터는 integer가 된다. (instruction에서 처리하는 데이터 타입은 integer, bit vector, floating point number, character 등이 있다.)
- 나머지 string, image, sound 등은 하드웨어에서 지원하는 내용 (RGB 등 입출력 장치의 해석)에 따라 지정된다.

# 2. Digital Logic Structure

- Memory
    - 메모리에는 몇 개의 칸 (locations)이 있고, 각 칸은 주소를 가진다. 
    메모리의 주소에 데이터를 저장한다.
    - Address Space : 칸의 개수 (bit로 구성된다고 가정하면 2^n locations) *보통 4, 8, 16GB 메모리를 사용하므로
    - Addressability : 한 칸당 bits의 개수 (m bits)
    - 따라서 총 메모리 용량은 (2^n * m) bits

        *참고 - CS는 2의 power를 자주 사용한다. 
          단위 k : 2^10 (1024, 원래는 1000), M : (2^10)*(2^10), G : (2^10)*(2^10)*(2^10)
          예를 들어 8GB 메모리이면 총 용량은 8*(2^10)*(2^10)*(2^10) * m bits (즉, 8억*m개 비트)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png)

- RAM (Random Access Memory)
    - 카세트 테이프와 달리 원하는 위치에 바로 접근이 가능하다.
    - DRAM (Dynamic) - PC의 메모리. slower but denser, bit storage decays. must be periodically refreshed.
    - SRAM (Static) - fast, maintains data as long as power applied.
    - DRAM, SRAM 모두 Volatile memory이다. (전원이 끊기면 모두 날아간다.)
    *non-Volatile memory : flash 메모리 (USB, SDD)
- 요약
- Levels of abstraction
- MOS Transistor를 통해 CMOS gates (inverter, NAND/AND, NOR/OR)를 만들었다
   - Combinational circuit - 그를 바탕으로 Decoder, Mux, Adder, PLA 등을 만들었다. 
   - Sequential circuite - 그를 바탕으로 R-S latch, Gated D latch를 만들고, Register, Memory를 만들었다.
   - Combinational/Sequential circuit의 building block을 이용하여 Finite State Machine을 만들었다.
- CMOS circuits (N,P 타입 반도체...)

# <Hardware>

# 3. Von Neumann Model (컴퓨터 구성)

- 1940년대 개발된 최초의 괜찮은 컴퓨터 (현재와 구성이 유사함)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png)

    - Memory

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png)

    - Processing Unit
    - Register : Processing Unit에서 operation을 수행할 때 필요한 데이터나 결과값을 임시로 저장할 저장공간 (temporary storage)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png)

    - I/O

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png)

    - Control Unit
    - PC (Program Counter)를 통해 다음 실행될 instruction의 주소를 메모리에서 가져오고, 작업을 실행하기 위해 판단한다.
    - IR (Instruction Register) : 현재 instruction 자체를 가진다.

        *instruction : processing의 기본 단위. 연산, 데이터 이동 (Memory↔Register), 제어 등의 종류가 있다.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png)

## 4. LC-3

- ISA (Instruction Set Architecture)
    - specifies all of programmer-visible state (memory organization, register set) and operations (opcode, data type, addressing mode).
    - hardware (하드웨어 구현 시 필요한 모든 정보), software (머신러닝 개발을 위해 필요한 모든 정보)의 interface

## 5. Assembly Language

- Assembler : symbolic representation을 binary representation으로 바꿔주는 프로그램

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png)

    - Assembly language is "translated (동일한 기능으로 번역됨)" into machine language (object code) by two-pass assembler, whereas instructions in machine language are "interpreted (해석되어 실행됨)" by hardware.

# 6. I/O

- Device

    - 어떻게 외부 데이터가 메모리로 들어오고, 메모리의 데이터가 외부로 나가는지
    - input device는 키보드, 마우스 등 / output device는 모니터 등 / 둘다 해당되는 것은 USB

    - I/O Controller
    - Control Register : CPU가 device에게 시킨 작업에 대해 필요한 명령이나 parameter를 전달한다. (write)
    - Status Register : device의 상태를 CPU에 보고한다. (read)
    - Date Register : 데이터를 전달한다. (메모리↔device)
    - Device Electronics : 실제 동작을 실행한다. pixel to screen, bits to/from disk, characters from keyboard
    - Programming Interface
        - identify device register : Memory-mapped / special I/O instructions 
        - 주로 Memory-mapped가 사용됨
        - transfer timing : Asynchronous (비동기적) / synchronous (동기적)
        - 대부분 비동기적. device가 보낼 데이터가 있는지 확인하거나 데이터를 받을 상태가 되었는지 확인하는 작업을 거침
        - 동기적 : 일정 주기로 동일한 양의 데이터를 계속 device로 보내거나 받는 경우
        - transfer control : CPU (Polling) / device (Interrupts)
        - 데이터 전달을 언제 실행할지 결정하는 방법
        - Polling : CPU keeps checking status register until new data arrives or device ready for next data. 대부분 Polling을 지원함
        - Interrupt : Device needs a special signal to CPU when new data arrives or device ready for next data. (CPU가 그동안 다른 작업을 수행함. priority로 판단함)

## 7. Trap Routines, Subroutines

- OS (Operating System)이 관여하는 경우
    - system calls (via TRAP instruction)
    - Interrupts
    - Exception
- Subroutines
    - invoked via JSR or JSRR instruction (return address in R7)
    - arguments, return values, need to save/restore registers

# 8. Stack (Data Type)

- Stack은 Abstract data type이다. (Abstract : 내부 구현에 대한 자세한 내용은 감추고, interface를 통해 해당 자료구조를 buidling block으로 사용하는 것이다.)
- LIFO (last-in, first-out) 저장 구조이다.
- Main Operation은 Push&Pop이다. Push는 새로운 아이템을 stack에 더하는 것, Pop은 stack으로부터 아이템을 꺼내는 것이다.
- 메모리에서 stack의 구조

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png)

- [x]  Abstraction?
    - CS에서 추상화(abstraction)는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다. 추상화를 적절히 시키면 코드의 재사용성, 가독성을 높이고, 결국 생산성, 에러의 감소와 같은 요소에 영향을 미치게 된다.
    - 추상화는 인간의 문제해결 사고과정에서, 컴퓨터가 일을 처리하도록 데이터를 가공하고 처리하여, 문제를 해결하는 모델을 만드는 과정이다.
    - Abstraction is identifying what is important without worrying too much about the detail. Abstraction allows us to manage complexity.
    - CS에서는 두가지 추상화가 있는데, data abstraction과 control abstraction/functional abstraction/procedural abstraction 이다.
    - data abstraction : 문제 영역의 데이터를 추상화하는 것으로 문제 영역에서 취급할 주요 데이터를 식별하고, 주요 데이터 그룹에 대해 이름을 명명하고 각 데이터 그룹의 속성을 정의하는 것이다.
       ex. 클래스 다이어그램-객체들의 속성(Attributes)과 연산(Operations, 혹은 Method)을 추상화시켜 가지고 있다. 즉, 그 객체가 무엇인지, 어떤일을 할 수 있는지 설명하는 것이다.
    - control abstraction : 문제해결 알고리즘 단계 중 하나이다.
    - functional abstraction : 입력 데이터를 출력 데이터로 변환하는 과정을 추상화하는 방법이다. 이때 입력 데이터를 출력 데이터로 변환하는 기능을 모듈이라 정의하고, 각 모듈마다 하나의 함수 이름을 부여하고 필요에 따라 함수마다 매개변수를 가질 수 있고 다양한 상황에 따라 그 기능을 재사용할 수 있도록 추상화하는 방법이다. 
    [http://hicomputing.org/ct/8741](http://hicomputing.org/ct/8741)
    - [x]  Stack & Abstration?
        - Stacks can be implemented using Arrays or Linked List. stack을 구현하는 방법으로 Arrays or Linked List가 있다.

            ```c
            //struct나 class로 stack을 구현한다 치면
            private int top;
            private int[] arr;

            //변수 top이 stack 탑 표시하니깐 그거 pop, insert 하는 메소드
            //arr에는 data를 담고, top은 stack 에대한 정보 표시함
            ```

        - Stack holds a collection of elements but different from the Array or List. The elements can only be manipulated from one end of the stack. This end is the top of the stack.
        - Stack 개념 구분
        하드웨어 분야에서 메모리의 *stack, heap, global 등이 있고,
        소프트웨어 분야에서 data type으로서 *stack이 있다. 다른 개념이다.

---

# <Software>

# 9. Programming in C

- C언어 : High-Level Language
    - System programming (Windowx, UNIX 등) 개발에도 사용된다.
    - 값을 담는 container에 symbolic name (변수명)을 부여 가능하다. 
    C 컴파일러가 변수를 memory에 옮기거나, 임시로 register로 옮기는 등의 작업을 해준다. (기존의 Assembly Language나 Machine Instruction은 register or memory location에 값을 저장한다. C는 register or memory location을 몰라도 된다.)
    - underlying hardware에 대해 abstraction을 지원한다. (machine language의 high-level abstraction을 제공한다.)
    operation은 instruction set architecture와 별개로 작동한다.
    - 변수 (register, memory location에 대한 abstraction)
    - operation (arithmetic, logic instruction에 대한 abstraction)
    - control structure (branch, jump instruction에 대한 abstraction)
    - 표현력이 풍부하고, 가독성 있음, 버그에 대한 safeguard를 지원 (규칙을 enforce하도록 가이드 제공)한다.
- Translating High-Level Language
    1. Interpretation (실행을 위한 해석. 실제 machine instruction이 실행되는 것)
        - executes program statements
        - generally one line/command at a time, 전체 구조를 파악하지 않으므로 효율성이 낮음
        - debug, 변경, 중간결과 확인이 쉬움 (statement 단위로 수정 가능하므로)
        - 언어 - BASIC, LISP, Perl, Matlab, C-shell
    2. Compilation (high level language를 machine language로 전환)
        - high level language의 전체 statement를 machine language로 traslate 함 (실행하는게 아니라 executable program을 생성함)
        *CS50 - Asembly code를 object code로 변환하는 것은 어셈블 (Assemble) 단계
        - 전체 구조를 파악하고 있으므로 최적화 기회가 많고, 효율성이 높음
        - 변경 시 compilation을 다시 해야 함. debug가 어려움
        - 언어 - C, C++, Fortran, Pascal
    3. Interpretation&Compilation의 Hybrid
        - Java
        - Java language는 JVM (Java Virtual Machine) byte code로 컴파일된다.
        - JVM byte code는 1) interpreted 되어 실행되거나, 또는 2) native machine code로 compile되어 실행된다. - JIT (Just in Time, 코드가 실행될 때 컴파일) 또는 AOT (Ahead of Time, 코드가 실행되기 전에 컴파일) 컴파일러에 의해
        - Python
        - Python 프로그램은 byte code (Java Language 등)으로 converted된다. - PVM (Python Virtual Machine) for CPython, JVM for Jython에 의해
        - byte code는 native machine code로 interpreted 또는 compile된다. - JIT (Just in Time) 또는 AOT (Ahead of Time) 컴파일러에 의해
    - 예시

        ```swift
        func getZ (W: Int) {
        		X = W + W
        		Y = X + X
        		Z = Y + Y
        		print("Z")
        }

        라는 코드가 있을 때,
        1. interpreting하면, 한 줄씩 실행하여 Z를 계산한다.
        2. compile하면, 전체 코드를 분석하여 Z = 8W로 최적화하고 Z를 계산한다.
        ```

- Compiling C

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png)

    - Pre-processor
    - macro substitution
    - conditional compilation
    - source-level transformations (output is still C)
    - Compiler
    - generates object file (machine instruction)
    1) Source Code Analysis
        - Front-end, parses programs to identify its pieces (변수, 함수 등). C언어 코드를 분석해서 어떤 문법적 구조를 가지는지 파악함
        - depends on language (not on target machine)
    2) Code Generation
        - Back-end, generates machine code from analyzed source
        - may optimize machine code
        - depends on target machine (특정 instruction set architecture에 따라 machine code, machine instruction이 되므로)
    3) Symbol Table
        - map between symbolic names and items
        - Assembler의 Symbol Table과 유사하지만 보다 다양함
    - Linker
    - combine object files (including libraries) into executable image
    - 예시

        ```c
        #include <stdio.h> // 1) # : pre-processor에 의해 처리됨
        #define STOP 0     // 2)

        // description : counts down from user input to STOP
        main () // 3) function : main
        {
        		int counter; // 4) 변수 선언
        		int startPoint;

        		printf("Enter a positive number: "); // 5) prompt user for input (prompt를 통해 user에게 보여준다)
        		scanf("%d, &startPoint"); // 6) read into startPoint (user가 입력한 값을 read해서 startPoint 변수에 할당) *scanf : 변수 값을 input 받음

        		for (counter = startPoint; counter >= STOP; counter--)
        			printf("%d\n", counter); // 5) count down and print count 
        }
        ```

        1) pre-processor 단계로 해당 파일의 소스코드를 가져와서 대체한다.
            - Before compiling, copy contents of header file (stdio.h) into source code.
            - header file은 보통 상수, 변수, 함수 정의 등을 포함한다.
        2) pre-processor 단계로 String STOP을 String 0으로 대체한다.
            - Before compiling, replace all instances of the String "STOP" with the String "0"
            - Called as macro (macro substitution)
            - 실행하는 동안 변경되지 않는 값에 사용된다. 단, 프로그램이 reused될 때는 변경될 가능성이 있으므로 recompile해야 한다.
        3) 프로그램을 run하면 실행되는 함수이다.
        4) 변수를 선언한다.
             - symbolic name : counter, 값을 담을 컨테이너의 type : int 
               (data type을 컴파일러에 전달하여 얼마만큼의 공간을 할당할지 등을 interpret한다.)
        5) Output 
            - String contains characters to print and formatting directions for variables. (변수 값을 어떤 type으로 출력할지)
            - 변수 counter를 %d (decimal integer) type으로 출력한다. 그리고 linefeed (\n)를 출력한다.
            - 예시) printf("%d %d\n", counter, startPoint - counter); // 변수 외에도 연산 값을 출력 가능하다.
            *formatting options - %x (hexadecibal integer), %c (ASCII character), %f (floating-point number)
        6) Input
            - String contains formatting directions for looking at input. 
            - %d type의 값을 read하여 변수 startPoint에 할당한다.
            - & (Ampersand)를 사용한다. (Pointer에서 설명)

# 10. *Variable, Operator

- 변수
- holds a value upon which a program acts
- an abstraction (즉, symbolic name) of a memory location, but its value is moved to a register when subject to an operation and moved back to memory when registers are full
   (실제 연산을 할 때 값이 memory에서 register로 이동함)
- 변수, 상수, 연산자 등으로 표현된 Expression은 연산을 통해 value를 구하며 (evaluate to a value), type을 가짐 
   (할당연산자 '='도 1) 할당 action을 수행하면서, 2) value를 가지며 해당 값은 "연산의 결과로 할당되는 값"임. C의 특징)
- Expression의 결과값을 area에 할당하는 것은 Statement임 (작업의 단위;)
   - simple statement `a = b + 1;`
   - compound statement `{ a = b + 1; b = c * d; }`
    - Scope
    - Compiler infers scope from where variable is declared. (컴파일러는 변수가 선언된 위치에서 범위를 추론한다.)
    - Global : accessed anywhere in program. declared outside of all blocks
    - Local : only accessible in a particular region. Variable is local to the block {} in which it is declared.
- 연산자
- predefined actions performed on values
- an abstraction of arithmetic/logic instructions
- 논리연산자 : Bool type의 결과값을 Int로 표현 (0=false, 1=true) 단, 피연산자를 취급할 때 0=false, 0외 모든 값=true로 인식함 (C의 특징)
- Precedence (우선 순위)
   - 연산자 우선순위는 */%이 6이고, +-이 7임 (숫자 적을수록 우선순위 높음)
- Associativity (결합 법칙)
   - Assignment associates right to left. (할당연산자의 결합 법칙은 우에서 좌임) 따라서 `y = x = 3;` 의 의미는 `y = (x = 3);`과 동일함 (3을 x에 할당하고, x를 y에 할당)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png)

- Symbol Table
- 컴파일러는 변수 관련 정보를 저장한다. (변수명, type, memory location (Offset), scope)
- 로컬변수 Storage (YT 50min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png)

    - 로컬변수는 user stack (activation record, stack frame)에 저장된다.
    - main 함수에 변수가 할당되면, memory의 stack 바닥부터 쌓인다. (main 함수의 stack 크기가 늘어난다.) 만약 다른 함수를 정의하면서 변수를 선언하면, 선언 순으로 stack에 쌓인다. 
    - main 함수가 호출되면, activation record가 stack에 쌓인다. 
    *(12. Function 참고) activate record : procedure가 한 번 수행되기 위해 필요한 정보는 memory의 연속 블록을 사용하여 관리하는데, 이때 연속 블록을 의미함. 지역변수 및 그외 프로그램 수행에 필요한 정보.
    The activation record is temporary - it is allocated when the function is called (becomes active) and it is deallocated when the function returns (becomes inactive). Once an activation record is deallocated, the memory it occupied is available for use when new activation records are created.
    - Symbol Table "Offset"은 the base of the frame으로부터의 거리를 나타낸다.
    - R5 (frame pointer) holds address of the base of the current frame. (the base of the activation record)
    - A new frame is pushed on the run-time stack each time a function is called or a block is entered.
    - bc stack grows downward, R5 contains the highest address of the frame (*주의-frame base로 내려갈수록 address는 높아짐. 즉, 그림 상 위로 쌓는 형태로 보이지만, 실제로 변수가 할당되면 아래 방향의 메모리가 할당되면서 Stack이 아래로 늘어남), and variable offsets are <= 0. 
      (offset : R5가 가르치는 곳이 0, 그 윗칸부터 올라갈수록 -1, -2 ... -5가 됨)
        - [ ]  stack grows downward ???
- 프로그램 실행 시 memory (YT 55min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png)

    - Instructions 
    - 현재 실행되는 instruction은 PC (Program Counter)가 트래킹하고 있다.
    - Global data section
    - 모든 글로벌 변수가 저장된다. (엄밀히는 모든 static 변수)
    - R4는 beginning (시작 주소)을 가르킨다.
    - Run-time stack
    - 로컬변수 사용에 활용된다. (엄밀히는 automatic 변수)
    - R6 (stack pointer)는 top of stack (stack 최상단)을, R5 (frame pointer)는 top frame on stack (the base of the current frame, 현재 함수의 frame base) 을 가르킨다.
    - 개별 block에 new frame이 주어진다. (block exit, 즉 메모리가 free되면 사라진다.)
    *변수 선언 시 static이 없으면 automatic 변수이다. 해당 block에 들어가면 메모리가 allocate되고, block에서 나가면 free 된다.
    반면, static이 있으면 static 변수이다. block에 들어가고 나가는 것과 무관하게 프로그램 시작 시 allocate되고, 프로그램 종료 시 free 된다.
    ⇒ 따라서 'static 로컬변수'는 로컬변수이지만 Stack이 아니라 Global에 할당된다.
    - Offset : 저장공간의 시작점으로부터의 거리이다.
    - Global : LDR R1, R4, #4 // Global의 R4를 기준으로 access함
    - Local   : LDR R2, R5, #-3 // Stack의 R5를 기준으로 access함
- Variable & Memory Location
    - 변수는 항상 메모리에 저장된다.
    - 어떤 변수가 할당되면, memory location에 저장된다. 
    - instruction 수준에서는 store operation을 진행한다. (컴파일의 결과로 생성되는 instruction)
    - 컴파일러는 코드 최적화를 위해 변수를 register에 할당하려고 한다. 왜?
    - +, && 등 operation을 하려면 값이 (임시로라도) register에 있어야만 연산이 가능하다.
    - 성능 측면에서 register를 참조하는 것이 memory를 참조하는 것보다 더 빠르다.
    - 따라서 컴파일은 보통 메모리에 home location이 있고, 필요에 따라 (연산을 하거나 빠른 access가 필요할 때) register에 임시로 값을 이동시키는 최적화 작업을 수행한다.

# 11. Control Structure

- row level language - 보통 machine instruction은 sequential 하게 수행되고, conditional branch 또는 jump instruction에 의해 non-sequential하게 수행되기도 한다.
- high level language - Sequence, Conditional, Iterarion 등의 Control Structure가 있다.

- Condition
    - `if (condition) action;`
    - condition : C expression, action : C statement;

        ```c
        if (x <= 10) {
        y = x + 1; // condition이 true이면 action (2개 statement)이 실행됨
        z = y + 1;
        }

        if (x <= 10) // {}가 없으면 condition 뒤의 1개 statement만 if문 소속으로 인식됨
        y = x + 1; // condition이 true이면 action (1개 statement)이 실행됨
        z = y + 1; // condition과 상관없이 항상 실행됨

        ```

    - `switch (expression) {caseconst1: action1;break;caseconst2: action2;break;default:action3;}`
    - break를 각 case에 추가하는 것이 바람직함. break가 없으면 const1 조건을 만족할 경우, case1에서 종료되지 않고 case2, default로 넘어가서 모두 실행되기 때문 (C의 단점)
    - const1을 만족하면 action1을 실행하고 종료, const2를 만족하면 action2를 실행하고 종료, 위의 모든 조건에서 false이면 default를 실행하고 종료 (break가 있으므로)
        - break
        - used only in switch or iteration statement
        - *passes control out of the smallest statement (loop or switch) containing it to the statement immediately following (break를 포함하는 실행문 (반복문 또는 switch문)의 제어를 바로 다음 실행문 (해당 반복문 또는 switch문 외부)으로 전달한다.)
        - usually used to exit a loop before terminating condition occurs (or to exit switch statement when case is done)
        - continue
        - used only in iteration statement
        - *terminates the execution of the loop body for this iteration (반복문의 해당 iteration의 실행문을 즉시 종료하고, 다음 iteration으로 넘어간다.)
        - loop expression is evaluated to see whether another iteration should be performed
        - if 'for loop', also executes the re-initializer (for문이면 re-initializer를 실행한 이후, 다음 iteration으로 넘어간다.)

            ```c
            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) continue;
            		printf("%d ", i);
            }
            // if문이 true이면 다음 iteration을 실행함 -> 20 이하의 홀수가 출력됨

            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) break;
            		printf("%d ", i);
            }
            // i = 0인 첫번째 iteration에서 break -> *for문 자체를 종료함
            ```

- *Iteration
    - `while (test) loop_body;`
    - Executes loop_body as long as test evaluates to True (non-zero).
    - `for (init;test;re-init) statement;`
    - Executes loop_body as long as test evaluates to True (non-zero). Initialization and re-initialization code include in loop statement.
    - `init;while (test) {statement;re-init}` 구조와 동일하다.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png)

        ```c
        // Nested Loops

        for (mp1 = 0; mp1 < 10; mp1++) {      // 1) mp1 = 0이 먼저 들어가고
        		for (mp2 = 0; mp2 < 10; mp2++) {  // 2) mp2가 0에서 9까지 돌고나서, (다시 mp1 = 1이 들어가고, mp2가 0에서 9까지 돌고나서 ... 반복)
        				printf("%d\t", mp1 * mp2);
        		}
        		print("\n")
        } // prints a multiplication table.

        for (outer = 1; outer < 10; outer++) {
        		for (inner = 0; inner < outer; inner++) {  // outer 변수에 따라 내부 for문의 실행횟수가 결정되는 구조
        				sum += inner;
        		}
        }
        ```

    - For Vs. While
        - For loop : counter-based loop에 적합하다. (ex. 5번 count 동안 실행해라)
        - While loop : sentinel (보초병)-based loop에 적합하다. (ex. 특정 조건 동안 실행해라)
- Problem Solving in C
    - Stepwise Refinement 
    - machine instruction을 이용하면 machine language까지 내려가야 problem solving이 가능하지만,
       C에서는 C언어 자체로 problem solving이 가능하므로 작업이 쉽고 생산성이 좋다.

# 12. Function

- 장점
    - 자주 쓰는 기능을 subcompoment로 만든다. 이를 통해 프로그램의 compositional design이 가능하다.
    - 작업에 대한 abstraction을 지원한다.
    - hides low-level details (input, output 관계만 알면 사용 가능하다. 내부적으로 어떻게 구현이 되는지는 숨겨준다.)  
    - gives high-level structure to program, and make it easier to understand overall program flow
    - C Function
    - argument : zero or multiple arguments passed in
    - return : single result returned (optional-output이 없는 경우도 있다.)
    - 다른 언어에서는 procedure, subroutine으로 부른다.
- Declaration & Call & Definition
    - [x]  왜 parameter가 선언할 때는 1개인데, 호출할 때는 2개가 들어가지?
        - f+g의 결과값이 parameter n의 argument로 전달된다.

    ```c
    // Declaration
    int Factorial(int n;) // prototype
    // 차례로 return type, Function Name, types/number of all arguments

    // Call (Invocation)
    a = x + Factorial(f + g) // 1) evaluate argument, 2) evaluate function, 3) use return value in expression.

    // Definition - 함수 구현과 관련된 low-level detail
    // - Declaration 내용 (State type, name/types of arguments 등)과 일치시킨다. (argument name을 동일하지 않게 부여 가능하지만, 비효율적이다.)
    int Factorial(int n) {
    		int i;
    		int result = 1;

    		for (i = 1; i <= n; i++)
    				result = result * i;

    		return result; // 값을 반환하고, gives control back to calling function (control은 함수 호출 지점으로 되돌아간다.)
    }  
    ```

    - Declaration이 필요한 이유
        - Definition 이전에 함수를 사용 가능하다. (C 특징)
        - 컴파일러는 return type, argument type/number를 알아야 한다.
        - Definition이 다른 파일에 들어있거나, 다른 개발자에 의해 작성된 것일 수 있다.
        - include a "header file" with function declarations only (함수 선언이 들어있는 헤더파일을 포함시킨다. 개별적으로 컴파일하고, 최종 실행 전에 link 해야 한다.)
- Implementing Function (YT 16min)
    - 함수 호출 시, 어떻게 machine instruction 수준에서 구현되는지

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png)

    - *Activation Record (=Stack Frame)
    - 함수 정보 (argument, return value, 로컬변수 등)는 activation record에 담겨있다. (AR은 함수 호출 시 생성된다.)
    - 함수가 호출될 때마다 해당 함수의 activation record가 run-time stack에 allocate된다. (여러 Caller에 의해 여러 번 호출되면, AR이 개별적으로 다른 memory location에 생성된다.)
    - 함수 Call 및 Return의 과정 🌴🌴🌴
    - 어떤 함수가 호출되면, 해당 함수는 Callee이고, 해당 함수를 호출한 지점은 Caller이다.
    1. Caller가 argument를 전달하기 위해 argument의 값을 복사해서 activation record에 push한다.
    2. Caller가 함수를 호출한다. 
    3. Callee는 자기 함수의 로컬변수를 allocate한다. (AR을 stack에 push함)
    4. Callee는 코드를 실행해서 return value를 구하고, return 값을 activation record의 해당 위치에 넣는다.
    5. Callee는 사용이 완료된 로컬변수를 free하고, 함수를 return 한다. (함수를 return 한다 : Caller로 되돌아가기 위해 Program counter을 되돌리고, AR을 stack에서 pop함)
    6. Caller는 activation record에서 return값을 꺼내어 사용한다.
        - Argument values : allocated, set up, free - by Caller
        Return value : allocated, set up - by Callee / used, free - by Caller
        Return address : allocated, set up, free - by Callee
        dynamic link : allocated, set up, restore, free - by Callee
        local variables (엄밀히는 automatic variables) : allocated, set up, free - by Callee
    - (정리) Run-time Stack
    - *로컬변수는 stack in an activation record에 저장된다.
    - 함수가 호출될 때마다 해당 함수의 activation record가 stack에 allocate된다.
    - R5 (frame pointer)는 the beginning of a region of activation record (현재 함수 관련 로컬변수가 저장되어 있음)를 가르킨다.
    - 새로운 함수가 호출되면, activation record가 stack에 push된다.
       해당 함수가 return되면, activation records는 stack에서 pop off된다. 
       (함수 호출 및 return 과정이 LIFO이므로 activation record를 효율적으로 allocate/free 시킬 수 있다.)
        - *예시1 - 코드가 실행될 때 stack의 구조

            ```c
            int main() 
            {
            	int a; // 0. stack에 로컬변수가 allocate 됨
            	int b;
              // ...
            	b = Watt(a); // 1. Main 함수가 Watt 함수를 호출
            	b = Volta(a,b); // 5. Main 함수가 Volta 호출
            } // 7. main return

            int Watt(int a)
            {
            	int w; 
              // ...
            	w = Volta(w,10); // 2. Watt 함수가 Volta 함수를 호출
            	return w; // 4. Watt return -> 1
            }

            int Volta(int q, int r)
            {
            	int k;
            	int m;
              // ...
            	return k; // 3. Volta return -> 2 / 6. Volta return -> 1
            }
            ```

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png)

            1. (첫번째 그림) Main 함수가 실행되면, R5는 로컬변수 (a,b)의 base (최상위 주소)를 가르킨다. (로컬변수가 2개이므로 R5가 위에서 2번째를 가르킴) - 0. stack에 로컬변수가 allocate 됨
            R6는 stack 최상단을 가르킨다. 
            2. (두번째 그림) Main에서 Watt를 호출하고, Watt 함수가 실행되면, Watt의 activation record가 push된다. - 1. Main 함수가 Watt 함수를 호출
            R5는 로컬변수 (w)의 최상위 주소를 가르킨다. (로컬변수가 1개이므로 R5가 위에서 1번째를 가르킴) 
            R6는 stack 최상단을 가르킨다. 
            3. (세번째 그림) Main에서 Volta를 호출하고, Volta 함수가 실행되면, Volta의 activation record가 push된다. - 2. Watt 함수가 Volta 함수를 호출
            R5는 로컬변수 (k,m)의 최상위 주소를 가르킨다. (로컬변수가 2개이므로 R5가 위에서 2번째를 가르킴) 
            R6는 stack 최상단을 가르킨다. 

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png)

            4. (네번째 그림) Volta가 return하면, stack에서 free된다. (return control to Caller and pop) - 3. Volta return -> 2 
            5. (다섯번째 그림) Watt가 return하면, stack에서 free된다. - 4. Watt return -> 1
            6. (여섯번째 그림) Main에서 Watt를 호출하고, Watt 함수가 실행되면, Watt의 activation record가 push된다. - 5. Main 함수가 Volta 호출
                R5는 로컬변수 (w)의 최상위 주소를 가르킨다. (로컬변수가 1개이므로 R5가 위에서 1번째를 가르킴) 
                R6는 stack 최상단을 가르킨다. 
            7. (다시 다섯번째 그림) Volta가 return하면, stack에서 free된다. - 6. Volta return -> 1
            8. Main이 return하면, stack에서 free된다. - 7. main return
                이때 R5는 Main 함수를 호출한 System 초기화 routine에서 로컬변수의 최상위 주소를 가르킨다.
                R6는 Main 아래줄 (stack 최상단)을 가르킨다.

            - 참고 - LC-3의 함수 호출 Implementation
                1. Caller pushes arguments (last to first)
                2. Caller invokes subroutine (JSR)
                3. Callee allocates return value, pushes R7 and R5
                4. Callee allocates space for local variables
                5. Callee executes function code
                6. Callee stores result into return value slot
                7. Callee pops local vars, pops R5, pops R7
                8. Callee returns (JMP R7)
                9. Caller loads return value and pops arguments
                10. Caller resumes computation
        - *예시2 - 코드가 실행될 때 activation record의 구조

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png)

            - 함수 FName을 호출하면, 그림과 같이 activation record이 생성된다.
            - 그림 상 아래부터 차례로 argument, return value (값을 구할 때까지 비워둠), return address, dynamic link (해당 함수를 호출한 Caller의 R5값), 로컬변수 순으로 locate된다.
            이때 R5는 (로컬변수 중에서) 최상위 주소를 가르킨다. (AR의 하단에 로컬변수가 있고, 가장 아래의 로컬변수가 stack frame의 base이므로) R6는 stack 최상단을 가르킨다.
                - Offset은 R5를 기준으로 위쪽에 있으면 (-), 아래쪽에 있으면 (+) 값이다.
                즉, R5가 w를 가르키므로 w,x,y = 0, -1, -2 / a,b = 4,5 
                (Offset이 있으므로 load register 또는 store register를 통해 activation record의 각 요소에 모두 접근가능하다.)
                - Bookkeeping을 위한 3가지 요소
                - return value : space for value returned by function. return값이 없더라도 allocate 한다.
                - return address : 해당 function이 return하면 되돌아갈 주소. save pointer to next instruction in calling function. (convenient location to store R7 in case another function (JSR) is called. 다른 함수가 호출되면 주소가 사라지므로)
                - dynamic link : 해당 함수를 호출한 Caller의 R5값. FName이 return하면 해당 R5값을 다시 restore해야 하기 때문! caller's frame pointer. used to pop this activation record from stack

# 13. Testing/Debugging

- Debugging with high-level language
    - Debugging 측면에서 machine language와 high-level language은 목표가 동일하며 큰 차이가 없다.
    - Examine and set values in memory. 메모리의 값을 읽어본다. 값을 세팅해본다.
    - Execute portions of program. 프로그램 일부를 실행해본다.
    - Stop execution when/where desired. 원하는 시점/위치에서 프로그램을 중지해본다.
    - high-level language에서는
    - Examine and set variables (abstraction-memory location이 아니라 variable)
    - Trace, single-stepping and set breakpoints on statements, function calls (instruction이 아니라)
    - 필요 시 low-level tool도 사용한다.
- Error Type
    - Syntactic Error 
    - 문법적 오류. Input code is not legal
    - Caught by compiler
    - Semantic Error
    - legal code이지만, 개발자가 의도하지 않은 방향으로 구현됨
    - 해결하기 어려우며 debugging tool이 필요함
    - Algorithmic Error
    - 프로그램 logic의 문제. 문제해결을 위한 개발자의 의도가 틀림
    - ex. Y2K bug (only allow 2 digits for year, assuming 19__)
- Testing
    - 실제 input을 주고, 그 결과를 관찰/확인하는 작업이다. 모든 경우의 수를 고려하는 것은 현실적으로 불가하다.
    - Black-Box Testing : program internals에 대해 아무것도 가정하지 않고, 임의의 input을 주는 방식. replies upon input/output specification. 자동화가 용이하나 경로가 한정됨
    - White-Box Testing : test coverage를 증가시켜 보완한 방식. 다양한 경로를 확인함. 필요 시 assertation을 사용함
- Debuggin Techniques
    - 주먹구구식 - Ad-Hoc
    - Insert printf statements to track flow and values
    - code explicitly checks for values out of expected range
    - Tool 사용 - Source-Level Debugger
    - Examine and set variable values
    - Tracing, breakpoints, single-stepping (ex. cloud9)
        - breakpoints
        - stop when a particular statement is reached (잠시 멈췄다가 진행 가능한 suspend의 개념) 함수의 entry 또는 exit에서 보통 stop하여 확인함
        - conditional breakpoint : stop if a var is equal to a specific value
        - watchpoint : stop when a var is set to a specific value
        - single-stepping
        - execute one statement at a time (단, '다음 stop (statement)'를 무엇으로 잡는지 기준이 필요)
        - step into : next statement is first inside function call (다음 stop은 호출된 함수의 첫번째 statement임)
        - step over : execute function without stopping (function 전체는 무시하고, function 바로 뒤의 statement가 다음 stop임)
        - step out : finish executing current function and stop on exit (현재 함수를 실행하고, exit 부분 (return 부분)이 다음 stop임)
        - Displaying Values
        - show value consistent with declared type of variable
- Programming for Correctness
- 애초에 프로그래밍할 때 정확히 하는 것이 중요하다.
- Accurate Specificatiton, Modular Design (큰 문제를 작은 문제들로 쪼갠 Module을 만들고, module들을 componential하게 조합하여 프로그램을 구성) Defensive Programming (comment를 통한 documentation, consistent coding style, avoid global var)

# 14. Pointers, Array

- Pointer
    - 메모리에 있는 변수의 주소를 담고 있는 type이다.
    - allows us to indirectly access variables with its address (we can talk about its address rather than its value)
    useful for returning multiple values from a function
    - `int *p;` : p is a pointer to an int
    *p : returns the value pointed to by p (dereferencing operator) 
    &n : returns the address of variable n (& must applied to a memory object, such as variable. &3 or $(a+b) is not allowed)
    **p : p가 가르키고 있는 것이 다시 주소가 되어서, 그것이 가르키는 값을 반환함

        ```c
        int i = 10;
        int *ptr;  // int type의 주소를 담는 포인터 변수 ptr을 선언

        ptr = &i  // i 주소를 ptr에 할당

        *ptr = *ptr + 5;  // 포인터 ptr이 가르키는 값, 즉 i의 값인 10에 5를 더한 15를 할당
                          // 즉, 개념적으로 reference(주소를 담고 있는 포인터 ptr) 그리고 dereference(*)가 상쇄된다.
        ```

- Pointer가 필요한 이유 - swap (YT 7min, 참고-CS50 Memory 1hr 10min)
    - Pointer 미사용

        ```c
        // The function is supposed to swap the values of its arguments
        void swap(int firstVar, int secondVar)  // argument
        {
        	int temp = firstVar;
        	firstVar = secondVar;
          secondVar = tempVar;
        }

        int main(void)
        {
        int valueA = 3;
        int valueB = 4;
        swap(valueA, valueB)  // 함수 호출 - 하지만 실제로 valueA/B가 swap 되지 않음
        }
        ```

        - Swap 함수 호출 시 Stack

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png)

            - 함수 실행 이전
                - Caller (main 함수)의 로컬변수 valueA, valueB (argument 복사값 3,4)가 main의 AR 상단에 allocate 된다.
                - Caller의 로컬변수 valueA, valueB의 복사값 3,4가 Callee (swap 함수)의 argument (로컬변수X) firstVar, secondVar로 전달된다.
                - Callee의 argument firstVar, secondVar가 swap의 AR 하단에 allocate 된다. (엄밀히 호출 이후에 allocate 됨)
                또한 로컬변수 temp가 swap의 AR 상단에 allocate 된다.
                *AR (Activation Record)
            - 함수 실행 이후
                - 함수가 실행되면 swap의 argument firstVar, secondVar의 값이 swap 된다.
                실행이 완료되면 swap 함수가 return 되고 AR이 pop 된다. (return type은 void임)
                - 의도했던 main의 로컬변수 valueA, valueB은 swap되지 않는다.
                - 결론적으로 Swap needs address of variables outside its own AR
            - 참고-CS50
            - 아랫줄이 main 함수, 윗줄이 swap 함수의 stack frame이다.

                ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png)

    - Pointer 사용
    - Passing a pointer into a function allows the function to read/change memory outside its activation record.

        ```c
        void swap(int *firstVar, int *secondVar) // Pointers as argument - Caller passes addresses of vars that it wants the callee to change.
        {
        	int temp = *firstVar; // 포인터 변수 firstVar이 가르키고 있는 값을 로컬변수 temp에 할당
        	*firstVar = *secondVar;
          *secondVar = tempVar; 
        }

        int main(void)
        {
        int valueA = 3;
        int valueB = 4;
        swap(&valueA, &valueB)  // 함수 호출 - valueA/B의 주소 (복사값이 아니라)가 전달되므로 swap 됨
        }
        ```

        - Swap 함수 호출 시 Stack

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2021.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2021.png)

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2022.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2022.png)

            - Caller (main 함수)의 로컬변수 valueA, valueB의 주소 (복사값 3,4가 아니라)가 Callee (swap 함수)의 argument firstVar, secondVar로 전달된다. (argument type이 pointer)
            - (Pointer 미사용과 동일)
            Callee의 argument firstVar, secondVar가 swap의 AR 하단에 allocate 된다. (엄밀히 호출 이후에 allocate 됨)
            또한 로컬변수 temp가 swap의 AR 상단에 allocate 된다.

            단, argument firstVar, secondVar에 주소가 할당되었으므로 결론적으로 valueA/B의 값이 swap 된다.
- Null Pointer
    - 포인터를 선언했지만, 어떤 것을 가르킬지 아직 할당해주지 않은 상태이다.
    (종종 NULL = 0 인데, 대부분의 프로그램/플랫폼에서 Address 0은 legal address가 아니기 때문이다.)

        ```c
        int *p;
        p = NULL;  // p is a null pointer
        ```

- Array
    - a mechanism to group multiple elements of a homogeneous type (*heterogeneous type-Structure 구조체에서 가능)
    - its element allocated sequentially in memory
    - 선언 / Array Reference
    `type variableName[num_elements];` / `variableName[index];`
    ex. int grid[10] : declaration of an Int array with 10 elements. referenced by: grid[0] ... grid[9]
    - grid[10]를 실수로 넣어도 compile-time 및 run-time에서 limit checking이 되지 않는다. (컴파일러가 확인하면 실행속도가 너무 느려지므로)
    - Array가 로컬변수에 할당되면, array elements are allocated as part of the AR.
    - First element grid[0] is at the lowest address of allocated space. (그림상으로는 맨 위에)
    - If grid is the first variable allocated, then R5 (frame pointer, frame base, 최상위주소) will point to grid[9].

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2023.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2023.png)

    - Passing array as arguments
        - C passes arrays by reference. array를 argument로 전달할 때는 array의 주소를 전달한다.
        - array의 주소(=array의 첫번째 element의 주소) 는 함수의 activation record에 적힌다.

            ```c
            // #define MAX_NUMS = 10 (상수로 선언해야 함)

            main() {
            		int numbers[MAX_NUMS]; // array 선언
            	  // ...
            	  mean = Average(numbers); // array를 argument로 전달
            }

            int Average(int inputValues[MAX_NUMS]) { // array element의 average를 계산하는 함수
            		for (index = 0; index < MAX_NUMS; index++)
            				sum = sum + indexValues[index];
            		return (sum / MAX_NUMS);
            }
            ```

    - String : an array of characters (엄밀히는 a pointer of charaters)
        - `char outputString[16];` 
        - String array의 마지막 element는 항상 terminating zero (\0)이다. 따라서 15개 character만 할당 가능하다.
- Array & Pointer
    - An array name is essentially a pointer to the first element in the array

        ```c
        char word[10]; // array
        char *cptr;    // pointer

        cptr = word;  // points to word[0]
        // cptr = &word[0]; // 위와 동일
        ```

# 15. Recursion

- 함수 자기 자신을 호출하는 함수를 구현 가능하다. 
함수를 호출하면, 그에 필요한 메모리 영역이 stack에 dynamic하게 allocate된다. 해당 함수의 AR이 stack에 push된다.
해당 함수가 자신을 호출한다고 해도 동일한 방식으로 함수 자신의 AR이 새롭게 stack에 push된다. (여러 번 다시 호출돼도 새로운 AR이 생성되므로 자신이 아닌 다른 함수를 호출한 것처럼 취급한다.)
- Recursive Function
    - is one that solves its task by calling itself on smaller pieces of data.
    - similar to recurrence relation in math.
    - high-level ex. Binary search (전화번호부 찾기, 하노이 탑 쌓기)
    - 반복문보다 코드를 conceptually 단순하게 작성 가능하지만, 실행 시 메모리가 비효율적으로 사용된다. (이미 값을 알고 있는 base 단계 (ex. n== 1)가 반복 실행되므로)

        ```c
        int RunningSum(int n) {
        		if (n == 1)
        				return 1;
        		else
        				return n + RunningSum(n-1);
        }
        ```

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2024.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2024.png)

    - ex. Fibonacci 함수

        ```c
        int Fibonacci(int n)
        {
        		int sum;

        		if ((n == 0) || (n == 1))
        				return 1;

        		else {
        				sum = Fibonacci(n-1) + Fibonacci(n-2)
        				reuturn sum;
        		}
        }
        ```

        - AR - Fibonacci 함수가 호출될 때마다 새로운 AR이 stack에 push된다.

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2025.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2025.png)

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2026.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2026.png)

            1. (그림 순서대로) main이 Fibonacci(3)을 호출한다. // sum = Fibonacci(2) + Fibonacci(1)
            2. Fibonacci(3)은 Fibonacci(2)을 호출한다. 
            3. Fibonacci(2)은 Fibonacci(1)을 호출한다. Fibonacci(1)은 1을 return하고 pop된다.
            4. Fibonacci(2)은 남은 Fibonacci(0)을 호출한다. Fibonacci(0)은 1을 return하고 pop된다.
            5. Fibonacci(2)은 호출했던 Fibonacci(1), Fibonacci(0)의 return값(1+1)을 모두 얻었으므로 Fibonacci(2)는 return하고 pop된다.
            Fibonacci(3)은 남은 Fibonacci(1)을 호출한다. // Fibonacci(3) = 2 + Fibonacci(1)인 상태
            6. Fibonacci(1)은 1을 return하고 pop된다. 
            Fibonacci(3)은 호출했던 Fibonacci(2), Fibonacci(1)의 return값을 모두 얻었으므로 Fibonacci(3)는 return하고 pop된다.
            - 즉, Fibonacci(3)의 trace는

                ```c
                Fibonacci(3)
                	Fibonacci(2)
                		Fibonacci(1)
                		Fibonacci(0)
                	Fibonacci(1)
                ```

# 16. I/O in C

- Standard C Library
    - I/O commands are not included as part of the C language. Instead, they are part of the Standard C Library.
    - C언어의 일부가 아니므로 컴파일러는 function interface 관련 정보가 필요하다. 이를 함수, 변수, 상수 등이 선언 내용이 포함된 Standard header file형태로 제공한다.
    - A collection of functions and macros that must be implemented by any ANSI standard implementation.
    - Implementation depends on processor, OS... but interface is standard. (CPU, OS 종류에 따라 implementation이 달라질 수 있지만, interface는 ANSI standard에서 정의한 것을 따른다.)
    - Basic Function : declared in the <stdio.h> header file. (printf, scanf, fopen...)
- I/O Streams 
- 모든 문자는 streams을 기반으로 실행된다. 
- A stream is a sequence of ASCII characters. 예를 들어 키보드에 입력되는 것, 모니터에 출력되는 것 등 문자
- characters are processed in the order in which they were added to the steam. stream에 추가되는 순서에 따라 처리된다. (키보드 입력한 순서대로 문자를 처리하는 등)
- Buffered I/O
- In many systems, characters are buffered in memory during an I/O operation. (개념적으로 각 I/O Stream은 자신의 buffer를 가짐)
- Keyboard input system : Characters are added to the buffer only when the newline character (=Enter key) is pressed.
   buffer가 있어서 사용자가 키보드에 문자를 입력하고 Enter key을 눌러서 confirming하기 전까지 문자를 수정 가능하다.
- Formatted I/O
- printf("Result is %d\n", var1);과 같이 Format String ("...") contains text to be read/written, and formatting characters (%d) that describe how data is to be read/written.
- File I/O 
- a file is a sequence of ASCII characters. Each file is associated with a stream. 
- type of a stream is a "file pointer", declared as: `FILE *infile;` (FILE type is defined in <stdio.h>)

# 17. Data Structure

- Data Structure
    - is a particular organization of data in memory. (연관성이 있는 데이터를 그룹핑하여 처리한다.)
    - Key Mechanisms
    - Array : group multiple elements of a homogeneous type
    - Structure : group multiple elements of a heterogeneous type
- Structure
    - Defining

        ```c
        struct flightType {
        		char flightNum[7];
        		int altitude;
        		int longitude;
        		int latitude;
        		int heading;
        		double airSpeed;
        };  // struct을 define하면 컴파일러는 어떤 component를 가지는지, 메모리 요구 정도가 얼마인지 파악한다. 이때 메모리를 할당하지 않는다. (변수를 선언하지는 않은 것으로 인식한다.) 

        struct flightType {
        		char flightNum[7];
        		int altitude;
        		int longitude;
        		int latitude;
        		int heading;
        		double airSpeed;
        } declareRightNow; // 참고 - define하는 동시에 declare하는 것도 가능하다.
        ```

    - Declaring
    - 메모리가 할당되는 시점은 struct type의 변수를 선언할 때이다. declared as: `struct flightType plane;`
    - 변수를 통해 struct의 member에 접근 가능하다. `plane.airSpeed = 800.0;`
    - typedef (typeAlias와 유사함)
    - 이미 정의된 type에 새로운 이름을 지정한다. `typedef int Color;` (이미 정의된 int type을 Color라고 부르겠다는 의미),
       `typedef struct flightType Flight;` (이미 정의된 flightType 구조체를 Flight라고 부르겠다는 의미)
       ⇒ `Color pixels[500]` (Int type array를 생성), `Flight planeA;` (flightType 구조체 type의 변수를 선언)
    - Array of Struct
    - declared as: `Flight airplanes[100];` (원래는 `struct flightType airplanes[100];`) // Flight type의 element로 구성된 Array airplanes
    - *Each array element is a struct (6 members in this case)
    - To access a member of a particular element: `airplanes[34].altitude = 10000;`
    - Pointer to Struct
    - declared as: `Flight *planePtr;` , pointer에 주소를 할당: `planePtr =&planes[34];`
    - To access a member of the struct address by pointer: `(*planePtr).altitude = 10000;` or `planePtr→altitude = 10000;`
    - Passing Struct as Arguments
    - array와 달리 struct는 항상 값으로 전달된다. (즉, struct member는 그 복사값이 함수의 AR에 전달된다. 따라서 changes inside the function are not reflected in the calling routine's copy.)
    - 필요 시 pointer를 사용한다.

        ```c
        int Collide(Flight *planeA, Flight *planeB) {
        		if (planeA->altitude == planeB->altitude) {
        				// ...
        		}
        }
        ```

    - Dynamic Allocation
    - 지난 수업처럼 함수가 호출될 때마다 AR을 stack에 push하는 방식이 아니라,
       임의의 순간에 원하는 만큼의 메모리를 Operating System으로부터 allocate 받는 방식이다.
    - ex. 공중의 비행기 관련 DB를 구축하는 프로젝트가 있다면, 그것을 표현할 수 있는 자료구조를 택해야 한다.
       - Array : Max number (현재 공중의 비행기가 몇 대가 될지)를 알 수 없으므로 불가, 안다고 하더라도 대부분 훨씬 적은 수의 비행기가 운행될 것이므로 메모리가 낭비된다.
       - 이때, 현재 운행중인 비행기에 해당하는 만큼의 메모리를 allocate 받는 Dynamic Allocation을 사용한다.
        - Memory Map

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2027.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2027.png)

            - Memory 상단부터 차례로 Instruction, Global, Heap, Stack가 locate 하는데, Dynamically allocated memory는 Heap 영역에 들어있다.
            - malloc
                - Standard C Library의 malloc 함수를 사용하여 memory를 allocate한다. `void *malloc(int numBytes);`
                - it returns a generic pointer (void *) to a contiguous region of memory of the requested size (in bytes). 
                - Operating system이 메모리를 allocate 해주고, 해당 메모리 영역의 시작주소를 return한다.
                - The bytes are allocated from a region in memory called the heap.
            - free
                - 할당받은 data를 free해주지 않으면 heap memory가 부족해서 프로그램 진행이 불가하다.
                - free 함수를 사용하여 malloc으로 할당받은 메모리를 deallocate 해준다. `void free(void*);`

                ```c
                // sizeof operator를 통해 컴파일러에게 해당 Type을 구현하는데 필요한 메모리 크기 (in bytes)를 계산하도록 한다.
                planes = malloc(n * sizeof(Flight)); // malloc은 할당한 heap 영역의 시작주소를 return 한다.

                // 만약 planes 변수가 pointer이면 type casting이 필요하다.
                planes = (Flight *) malloc(n * sizeof(Flight));
                ```

                ```c
                // struct define 부터
                struct flightType {
                		char flightNum[7];
                		int altitude;
                		int longitude;
                		int latitude;
                		int heading;
                		double airSpeed;
                };

                typedef struct flightType Flight; 

                int airbornePlanes; // 현재 공중의 비행기 대수
                Flight *planes; // Flight type을 가르키는 pointer 변수 planes를 선언

                printf("How many planes are in the air?");
                scanf("%d", %airbornePlane);

                planes = (Flight *) malloc(sizeof(Flight) * airbornePlanes);

                if (planes == NULL) { // if allocation fails, malloc returns NULL
                		printf("Error in allocating the data array.\n");
                    // ...
                }

                planes[0].altitude = ... // Can use array notation or pointer notation
                ```

- Linked List (YT 27min)
    - struct, pointer 개념을 조합하여 만든 data structure이다.
    - is an ordered collection of nodes, each of which contains some data, connected using pointers.
    - Each node points to the next node in the list. (head: 첫번째 node, tail: 마지막 node)
    - 장점 : element 추가/삭제가 쉽다. dynamically size 변경이 가능하다. (반면 Array는 메모리에 연속으로 위치해서 전체 element 위치를 다시 allocate 해야 함)
    단점 : element 접근이 어렵다. head에서부터 sequentially access 해야 한다. (반면 Array는 .index를 통해 임의 접근이 가능함)
    ⇒ 이를 보완한 다른 data structure : Tree, Graph,Hash Table 등
    - 예시 - inventory DB for a used car lot. support the following action:
    - search the DB for a particular vehicle
    - add a new car to the DB
    - delete a car from the DB
    *DB must remain sorted by vehicle ID. ID 작음-큼 순서로 정렬된 상태를 가정. 현재 주차된 차량의 대수를 알수 없으므로 linked list presentation을 채택함

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2028.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2028.png)

        *Node가 하나도 없는 초기상태가 필요하므로 carBase를 두어야 함

        ```c
        // Car data structure
        typedef struct carType Car;
        struct carType {
        		int vehicleID;
        		char maker[20];
        		char model[20];
        		int year;
        		int mileAge;
        		double cost;

        		Car *next; // next node를 가르키는 pointer 선언
        }

        // Scanning the List - search, adding/deleting requires finding a particular node in the list. Scan the list until we find a node whose ID is >= the one we're looking for.
        Car *ScanList(Car *head, int searchID) // ScanList function
        {
        		Car *previous, *current;
        		previous = head;
        		current = head->next; // next node를 가르키므로 next node(node1)가 할당됨

        		// Traverse until ID >= searchID 
        		while ((current != NULL) && (current->vehicleID < searchID)) { 
        				previous = current; 
        				current = current->next;
        		}
        		
        		return previous; // previous를 return한다. node를 add할 때, 이 뒤에 연결시켜야 하기 때문이다.
        }

        // Excerpts (발췌) from code to Add a Node
        newNode = (Car *) malloc(sizeof(Car));

        // initialize node with new car info
        prevNode = ScanList(head, newNode->vehicleID);
        nextNode = prevNode->next;

        if ((nextNode == NULL) || (nextNode->vehicleID != newNode->vehicleID)) {
        		prevNode->next = newNode;
        		newNode->next = nextNode;
        } else {
        		printf("Car already exists in database.");
        		free(newNode);
        }

        // Excerpts (발췌) from code to Delete a Node
        printf("Enter vehicle ID of car to delete:\n");
        scanf("%d", vehicleID);

        prevNode = ScanList(head, vehicleID);
        delNode = prevNode->next;

        if ((delNode != NULL) && (delNode->vehicleID == vehicleID)) {
        		prevNode->next = delNode->next;
        		free(delNode);
        } else {
        		printf("Vehicle not found in database.");
        }
        ```