# SNU ì»´ê³µê°œë¡ í•™

Created: April 19, 2021 2:34 PM
Created By: hyoju son
Last Edited Time: July 13, 2021 4:37 PM
Property: ì„œìš¸ëŒ€_ë¯¼ìƒë ¬T
Type: CS

- Contents
    - ê°•ì˜ Link : [https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K](https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K)

# 1. Bit, Data Type

- Digital System
    - Digital System : í‘œí˜„í•˜ëŠ” ì •ë³´ ì‹¬ë³¼ì´ ìœ í•œí•œ ê°œìˆ˜ì¸ ì‹œìŠ¤í…œì´ë‹¤. 
    ê·¸ ì¤‘ ì‹¬ë³¼ì´ 0,1ë§Œ ìˆëŠ” ê²ƒì´ Binary Systemì´ë‹¤. (0ì€ 0~0.5V, 1ì€ 2.4~2.9V-Volts) ComputerëŠ” binary digital systemì´ë‹¤.
    - ì •ë³´ì˜ ê¸°ë³¸ ë‹¨ìœ„ëŠ” Bit (Binary Digit)ì´ë‹¤.
    - ì»´í“¨í„°ì—ì„œ ì·¨ê¸‰í•˜ëŠ” ë°ì´í„°ëŠ” instruction (operation ëŒ€ìƒ), number, logical (bool), text (string), image (pixel) ë“±ì´ë‹¤.
    - PC = ë©”ëª¨ë¦¬ (ì£¼ì†Œë§ˆë‹¤ binary dataê°€ ë“¤ì–´ìˆìŒ), CPU (Processor, Program Counter-ë‹¤ìŒì— ìˆ˜í–‰í•´ì•¼í•  instructionì˜ ì£¼ì†Œê°€ ë“¤ì–´ìˆìŒ)
    *instruction : ì–´ë–¤ ì£¼ì†Œì— ìˆëŠ” ê°’ì„ ì—°ì‚°í•˜ì—¬ ê²°ê³¼ê°’ì„ ì–´ë–¤ ì£¼ì†Œì— í• ë‹¹í•´ë¼ ë“±ì˜ ì‘ì—…ì´ í•´ë‹¹ëœë‹¤. ë‹¤ìŒì— ì‹¤í–‰ë  instructionì„ ì§€ì •í•œë‹¤.
- Number
    - Two's Complement
    - 0ì˜ í‘œí˜„ë°©ë²•ì´ 2ê°œì„ (+0, -0)
    - solution : X + (-X) = 0ì„ ì„±ë¦½ì‹œí‚¤ëŠ” -Xì˜ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í•¨
    - Overflow
    - If operands(í”¼ì—°ì‚°ì) are too big, then sum cannot be represented as an n-bit 2's complement number.
    - ì‹¤ì œë¡œ 2ì§„ìˆ˜ ì—°ì‚°ê³¼ì •ì—ì„œ ì–‘ìˆ˜+ì–‘ìˆ˜=ìŒìˆ˜, ë˜ëŠ” ìŒìˆ˜+ìŒìˆ˜=ì–‘ìˆ˜ ë“± ë¹„ì •ìƒì ì¸ ê²°ê³¼ê°’ì´ ë‚˜ì˜¨ë‹¤!
    - Fractions (ë¶„ìˆ˜)
        1. Fixed-Point : ex) 0.00000001. ë‹¨ì ì€ 0000...ì„ í‘œí˜„í•˜ê¸° ìœ„í•´ ë©”ëª¨ë¦¬ ì†Œëª¨ê°€ í¬ë‹¤.
        2. Floating-Point : ex) F x 2^E (F: fraction, E: exponent-ì§€ìˆ˜)
- ìš”ì•½
- ë©”ëª¨ë¦¬ì˜ ë‚´ìš©ì€ ë‹¨ìˆœíˆ 0,1ì˜ íŒ¨í„´ì´ë‹¤.
- ê·¸ê²ƒì„ Program Counterê°€ ê°€ë¥´í‚¤ê³  ìˆìœ¼ë©´ instructionìœ¼ë¡œ í•´ì„ëœë‹¤.
- ì´ instructionì€ ì„œë¡œ ë‹¤ë¥¸ ë©”ëª¨ë¦¬ ì£¼ì†Œì— ìˆëŠ” ë°ì´í„°ë¥¼ ì°¸ì¡°í•˜ëŠ”ë°, ê·¸ instructionì´ integerë¡œ ê°„ì£¼í•˜ë©´ í•´ë‹¹ ë°ì´í„°ëŠ” integerê°€ ëœë‹¤. (instructionì—ì„œ ì²˜ë¦¬í•˜ëŠ” ë°ì´í„° íƒ€ì…ì€ integer, bit vector, floating point number, character ë“±ì´ ìˆë‹¤.)
- ë‚˜ë¨¸ì§€ string, image, sound ë“±ì€ í•˜ë“œì›¨ì–´ì—ì„œ ì§€ì›í•˜ëŠ” ë‚´ìš© (RGB ë“± ì…ì¶œë ¥ ì¥ì¹˜ì˜ í•´ì„)ì— ë”°ë¼ ì§€ì •ëœë‹¤.

# 2. Digital Logic Structure

- Memory
    - ë©”ëª¨ë¦¬ì—ëŠ” ëª‡ ê°œì˜ ì¹¸ (locations)ì´ ìˆê³ , ê° ì¹¸ì€ ì£¼ì†Œë¥¼ ê°€ì§„ë‹¤. 
    ë©”ëª¨ë¦¬ì˜ ì£¼ì†Œì— ë°ì´í„°ë¥¼ ì €ì¥í•œë‹¤.
    - Address Space : ì¹¸ì˜ ê°œìˆ˜ (bitë¡œ êµ¬ì„±ëœë‹¤ê³  ê°€ì •í•˜ë©´ 2^n locations) *ë³´í†µ 4, 8, 16GB ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ
    - Addressability : í•œ ì¹¸ë‹¹ bitsì˜ ê°œìˆ˜ (m bits)
    - ë”°ë¼ì„œ ì´ ë©”ëª¨ë¦¬ ìš©ëŸ‰ì€ (2^n * m) bits

        *ì°¸ê³  - CSëŠ” 2ì˜ powerë¥¼ ìì£¼ ì‚¬ìš©í•œë‹¤. 
          ë‹¨ìœ„ k : 2^10 (1024, ì›ë˜ëŠ” 1000), M : (2^10)*(2^10), G : (2^10)*(2^10)*(2^10)
          ì˜ˆë¥¼ ë“¤ì–´ 8GB ë©”ëª¨ë¦¬ì´ë©´ ì´ ìš©ëŸ‰ì€ 8*(2^10)*(2^10)*(2^10) * m bits (ì¦‰, 8ì–µ*mê°œ ë¹„íŠ¸)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png)

- RAM (Random Access Memory)
    - ì¹´ì„¸íŠ¸ í…Œì´í”„ì™€ ë‹¬ë¦¬ ì›í•˜ëŠ” ìœ„ì¹˜ì— ë°”ë¡œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
    - DRAM (Dynamic) - PCì˜ ë©”ëª¨ë¦¬. slower but denser, bit storage decays. must be periodically refreshed.
    - SRAM (Static) - fast, maintains data as long as power applied.
    - DRAM, SRAM ëª¨ë‘ Volatile memoryì´ë‹¤. (ì „ì›ì´ ëŠê¸°ë©´ ëª¨ë‘ ë‚ ì•„ê°„ë‹¤.)
    *non-Volatile memory : flash ë©”ëª¨ë¦¬ (USB, SDD)
- ìš”ì•½
- Levels of abstraction
- MOS Transistorë¥¼ í†µí•´ CMOS gates (inverter, NAND/AND, NOR/OR)ë¥¼ ë§Œë“¤ì—ˆë‹¤
   - Combinational circuit - ê·¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ Decoder, Mux, Adder, PLA ë“±ì„ ë§Œë“¤ì—ˆë‹¤. 
   - Sequential circuite - ê·¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ R-S latch, Gated D latchë¥¼ ë§Œë“¤ê³ , Register, Memoryë¥¼ ë§Œë“¤ì—ˆë‹¤.
   - Combinational/Sequential circuitì˜ building blockì„ ì´ìš©í•˜ì—¬ Finite State Machineì„ ë§Œë“¤ì—ˆë‹¤.
- CMOS circuits (N,P íƒ€ì… ë°˜ë„ì²´...)

# <Hardware>

# 3. Von Neumann Model (ì»´í“¨í„° êµ¬ì„±)

- 1940ë…„ëŒ€ ê°œë°œëœ ìµœì´ˆì˜ ê´œì°®ì€ ì»´í“¨í„° (í˜„ì¬ì™€ êµ¬ì„±ì´ ìœ ì‚¬í•¨)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png)

    - Memory

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png)

    - Processing Unit
    - Register : Processing Unitì—ì„œ operationì„ ìˆ˜í–‰í•  ë•Œ í•„ìš”í•œ ë°ì´í„°ë‚˜ ê²°ê³¼ê°’ì„ ì„ì‹œë¡œ ì €ì¥í•  ì €ì¥ê³µê°„ (temporary storage)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png)

    - I/O

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png)

    - Control Unit
    - PC (Program Counter)ë¥¼ í†µí•´ ë‹¤ìŒ ì‹¤í–‰ë  instructionì˜ ì£¼ì†Œë¥¼ ë©”ëª¨ë¦¬ì—ì„œ ê°€ì ¸ì˜¤ê³ , ì‘ì—…ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ íŒë‹¨í•œë‹¤.
    - IR (Instruction Register) : í˜„ì¬ instruction ìì²´ë¥¼ ê°€ì§„ë‹¤.

        *instruction : processingì˜ ê¸°ë³¸ ë‹¨ìœ„. ì—°ì‚°, ë°ì´í„° ì´ë™ (Memoryâ†”Register), ì œì–´ ë“±ì˜ ì¢…ë¥˜ê°€ ìˆë‹¤.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png)

## 4. LC-3

- ISA (Instruction Set Architecture)
    - specifies all of programmer-visible state (memory organization, register set) and operations (opcode, data type, addressing mode).
    - hardware (í•˜ë“œì›¨ì–´ êµ¬í˜„ ì‹œ í•„ìš”í•œ ëª¨ë“  ì •ë³´), software (ë¨¸ì‹ ëŸ¬ë‹ ê°œë°œì„ ìœ„í•´ í•„ìš”í•œ ëª¨ë“  ì •ë³´)ì˜ interface

## 5. Assembly Language

- Assembler : symbolic representationì„ binary representationìœ¼ë¡œ ë°”ê¿”ì£¼ëŠ” í”„ë¡œê·¸ë¨

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png)

    - Assembly language is "translated (ë™ì¼í•œ ê¸°ëŠ¥ìœ¼ë¡œ ë²ˆì—­ë¨)" into machine language (object code) by two-pass assembler, whereas instructions in machine language are "interpreted (í•´ì„ë˜ì–´ ì‹¤í–‰ë¨)" by hardware.

# 6. I/O

- Device

    - ì–´ë–»ê²Œ ì™¸ë¶€ ë°ì´í„°ê°€ ë©”ëª¨ë¦¬ë¡œ ë“¤ì–´ì˜¤ê³ , ë©”ëª¨ë¦¬ì˜ ë°ì´í„°ê°€ ì™¸ë¶€ë¡œ ë‚˜ê°€ëŠ”ì§€
    - input deviceëŠ” í‚¤ë³´ë“œ, ë§ˆìš°ìŠ¤ ë“± / output deviceëŠ” ëª¨ë‹ˆí„° ë“± / ë‘˜ë‹¤ í•´ë‹¹ë˜ëŠ” ê²ƒì€ USB

    - I/O Controller
    - Control Register : CPUê°€ deviceì—ê²Œ ì‹œí‚¨ ì‘ì—…ì— ëŒ€í•´ í•„ìš”í•œ ëª…ë ¹ì´ë‚˜ parameterë¥¼ ì „ë‹¬í•œë‹¤. (write)
    - Status Register : deviceì˜ ìƒíƒœë¥¼ CPUì— ë³´ê³ í•œë‹¤. (read)
    - Date Register : ë°ì´í„°ë¥¼ ì „ë‹¬í•œë‹¤. (ë©”ëª¨ë¦¬â†”device)
    - Device Electronics : ì‹¤ì œ ë™ì‘ì„ ì‹¤í–‰í•œë‹¤. pixel to screen, bits to/from disk, characters from keyboard
    - Programming Interface
        - identify device register : Memory-mapped / special I/O instructions 
        - ì£¼ë¡œ Memory-mappedê°€ ì‚¬ìš©ë¨
        - transfer timing : Asynchronous (ë¹„ë™ê¸°ì ) / synchronous (ë™ê¸°ì )
        - ëŒ€ë¶€ë¶„ ë¹„ë™ê¸°ì . deviceê°€ ë³´ë‚¼ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê±°ë‚˜ ë°ì´í„°ë¥¼ ë°›ì„ ìƒíƒœê°€ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ì‘ì—…ì„ ê±°ì¹¨
        - ë™ê¸°ì  : ì¼ì • ì£¼ê¸°ë¡œ ë™ì¼í•œ ì–‘ì˜ ë°ì´í„°ë¥¼ ê³„ì† deviceë¡œ ë³´ë‚´ê±°ë‚˜ ë°›ëŠ” ê²½ìš°
        - transfer control : CPU (Polling) / device (Interrupts)
        - ë°ì´í„° ì „ë‹¬ì„ ì–¸ì œ ì‹¤í–‰í• ì§€ ê²°ì •í•˜ëŠ” ë°©ë²•
        - Polling : CPU keeps checking status register until new data arrives or device ready for next data. ëŒ€ë¶€ë¶„ Pollingì„ ì§€ì›í•¨
        - Interrupt : Device needs a special signal to CPU when new data arrives or device ready for next data. (CPUê°€ ê·¸ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•¨. priorityë¡œ íŒë‹¨í•¨)

## 7. Trap Routines, Subroutines

- OS (Operating System)ì´ ê´€ì—¬í•˜ëŠ” ê²½ìš°
    - system calls (via TRAP instruction)
    - Interrupts
    - Exception
- Subroutines
    - invoked via JSR or JSRR instruction (return address in R7)
    - arguments, return values, need to save/restore registers

# 8. Stack (Data Type)

- Stackì€ Abstract data typeì´ë‹¤. (Abstract : ë‚´ë¶€ êµ¬í˜„ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ ê°ì¶”ê³ , interfaceë¥¼ í†µí•´ í•´ë‹¹ ìë£Œêµ¬ì¡°ë¥¼ buidling blockìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.)
- LIFO (last-in, first-out) ì €ì¥ êµ¬ì¡°ì´ë‹¤.
- Main Operationì€ Push&Popì´ë‹¤. PushëŠ” ìƒˆë¡œìš´ ì•„ì´í…œì„ stackì— ë”í•˜ëŠ” ê²ƒ, Popì€ stackìœ¼ë¡œë¶€í„° ì•„ì´í…œì„ êº¼ë‚´ëŠ” ê²ƒì´ë‹¤.
- ë©”ëª¨ë¦¬ì—ì„œ stackì˜ êµ¬ì¡°

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png)

- [x]  Abstraction?
    - CSì—ì„œ ì¶”ìƒí™”(abstraction)ëŠ” ë³µì¡í•œ ìë£Œ, ëª¨ë“ˆ, ì‹œìŠ¤í…œ ë“±ìœ¼ë¡œë¶€í„° í•µì‹¬ì ì¸ ê°œë… ë˜ëŠ” ê¸°ëŠ¥ì„ ê°„ì¶”ë ¤ ë‚´ëŠ” ê²ƒì„ ë§í•œë‹¤. ì¶”ìƒí™”ë¥¼ ì ì ˆíˆ ì‹œí‚¤ë©´ ì½”ë“œì˜ ì¬ì‚¬ìš©ì„±, ê°€ë…ì„±ì„ ë†’ì´ê³ , ê²°êµ­ ìƒì‚°ì„±, ì—ëŸ¬ì˜ ê°ì†Œì™€ ê°™ì€ ìš”ì†Œì— ì˜í–¥ì„ ë¯¸ì¹˜ê²Œ ëœë‹¤.
    - ì¶”ìƒí™”ëŠ” ì¸ê°„ì˜ ë¬¸ì œí•´ê²° ì‚¬ê³ ê³¼ì •ì—ì„œ, ì»´í“¨í„°ê°€ ì¼ì„ ì²˜ë¦¬í•˜ë„ë¡ ë°ì´í„°ë¥¼ ê°€ê³µí•˜ê³  ì²˜ë¦¬í•˜ì—¬, ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ëª¨ë¸ì„ ë§Œë“œëŠ” ê³¼ì •ì´ë‹¤.
    - Abstraction is identifying what is important without worrying too much about the detail. Abstraction allows us to manage complexity.
    - CSì—ì„œëŠ” ë‘ê°€ì§€ ì¶”ìƒí™”ê°€ ìˆëŠ”ë°, data abstractionê³¼ control abstraction/functional abstraction/procedural abstraction ì´ë‹¤.
    - data abstraction : ë¬¸ì œ ì˜ì—­ì˜ ë°ì´í„°ë¥¼ ì¶”ìƒí™”í•˜ëŠ” ê²ƒìœ¼ë¡œ ë¬¸ì œ ì˜ì—­ì—ì„œ ì·¨ê¸‰í•  ì£¼ìš” ë°ì´í„°ë¥¼ ì‹ë³„í•˜ê³ , ì£¼ìš” ë°ì´í„° ê·¸ë£¹ì— ëŒ€í•´ ì´ë¦„ì„ ëª…ëª…í•˜ê³  ê° ë°ì´í„° ê·¸ë£¹ì˜ ì†ì„±ì„ ì •ì˜í•˜ëŠ” ê²ƒì´ë‹¤.
       ex. í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨-ê°ì²´ë“¤ì˜ ì†ì„±(Attributes)ê³¼ ì—°ì‚°(Operations, í˜¹ì€ Method)ì„ ì¶”ìƒí™”ì‹œì¼œ ê°€ì§€ê³  ìˆë‹¤. ì¦‰, ê·¸ ê°ì²´ê°€ ë¬´ì—‡ì¸ì§€, ì–´ë–¤ì¼ì„ í•  ìˆ˜ ìˆëŠ”ì§€ ì„¤ëª…í•˜ëŠ” ê²ƒì´ë‹¤.
    - control abstraction : ë¬¸ì œí•´ê²° ì•Œê³ ë¦¬ì¦˜ ë‹¨ê³„ ì¤‘ í•˜ë‚˜ì´ë‹¤.
    - functional abstraction : ì…ë ¥ ë°ì´í„°ë¥¼ ì¶œë ¥ ë°ì´í„°ë¡œ ë³€í™˜í•˜ëŠ” ê³¼ì •ì„ ì¶”ìƒí™”í•˜ëŠ” ë°©ë²•ì´ë‹¤. ì´ë•Œ ì…ë ¥ ë°ì´í„°ë¥¼ ì¶œë ¥ ë°ì´í„°ë¡œ ë³€í™˜í•˜ëŠ” ê¸°ëŠ¥ì„ ëª¨ë“ˆì´ë¼ ì •ì˜í•˜ê³ , ê° ëª¨ë“ˆë§ˆë‹¤ í•˜ë‚˜ì˜ í•¨ìˆ˜ ì´ë¦„ì„ ë¶€ì—¬í•˜ê³  í•„ìš”ì— ë”°ë¼ í•¨ìˆ˜ë§ˆë‹¤ ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆê³  ë‹¤ì–‘í•œ ìƒí™©ì— ë”°ë¼ ê·¸ ê¸°ëŠ¥ì„ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì¶”ìƒí™”í•˜ëŠ” ë°©ë²•ì´ë‹¤. 
    [http://hicomputing.org/ct/8741](http://hicomputing.org/ct/8741)
    - [x]  Stack & Abstration?
        - Stacks can be implemented using Arrays or Linked List. stackì„ êµ¬í˜„í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ Arrays or Linked Listê°€ ìˆë‹¤.

            ```c
            //structë‚˜ classë¡œ stackì„ êµ¬í˜„í•œë‹¤ ì¹˜ë©´
            private int top;
            private int[] arr;

            //ë³€ìˆ˜ topì´ stack íƒ‘ í‘œì‹œí•˜ë‹ˆê¹ ê·¸ê±° pop, insert í•˜ëŠ” ë©”ì†Œë“œ
            //arrì—ëŠ” dataë¥¼ ë‹´ê³ , topì€ stack ì—ëŒ€í•œ ì •ë³´ í‘œì‹œí•¨
            ```

        - Stack holds a collection of elements but different from the Array or List. The elements can only be manipulated from one end of the stack. This end is the top of the stack.
        - Stack ê°œë… êµ¬ë¶„
        í•˜ë“œì›¨ì–´ ë¶„ì•¼ì—ì„œ ë©”ëª¨ë¦¬ì˜ *stack, heap, global ë“±ì´ ìˆê³ ,
        ì†Œí”„íŠ¸ì›¨ì–´ ë¶„ì•¼ì—ì„œ data typeìœ¼ë¡œì„œ *stackì´ ìˆë‹¤. ë‹¤ë¥¸ ê°œë…ì´ë‹¤.

---

# <Software>

# 9. Programming in C

- Cì–¸ì–´ : High-Level Language
    - System programming (Windowx, UNIX ë“±) ê°œë°œì—ë„ ì‚¬ìš©ëœë‹¤.
    - ê°’ì„ ë‹´ëŠ” containerì— symbolic name (ë³€ìˆ˜ëª…)ì„ ë¶€ì—¬ ê°€ëŠ¥í•˜ë‹¤. 
    C ì»´íŒŒì¼ëŸ¬ê°€ ë³€ìˆ˜ë¥¼ memoryì— ì˜®ê¸°ê±°ë‚˜, ì„ì‹œë¡œ registerë¡œ ì˜®ê¸°ëŠ” ë“±ì˜ ì‘ì—…ì„ í•´ì¤€ë‹¤. (ê¸°ì¡´ì˜ Assembly Languageë‚˜ Machine Instructionì€ register or memory locationì— ê°’ì„ ì €ì¥í•œë‹¤. CëŠ” register or memory locationì„ ëª°ë¼ë„ ëœë‹¤.)
    - underlying hardwareì— ëŒ€í•´ abstractionì„ ì§€ì›í•œë‹¤. (machine languageì˜ high-level abstractionì„ ì œê³µí•œë‹¤.)
    operationì€ instruction set architectureì™€ ë³„ê°œë¡œ ì‘ë™í•œë‹¤.
    - ë³€ìˆ˜ (register, memory locationì— ëŒ€í•œ abstraction)
    - operation (arithmetic, logic instructionì— ëŒ€í•œ abstraction)
    - control structure (branch, jump instructionì— ëŒ€í•œ abstraction)
    - í‘œí˜„ë ¥ì´ í’ë¶€í•˜ê³ , ê°€ë…ì„± ìˆìŒ, ë²„ê·¸ì— ëŒ€í•œ safeguardë¥¼ ì§€ì› (ê·œì¹™ì„ enforceí•˜ë„ë¡ ê°€ì´ë“œ ì œê³µ)í•œë‹¤.
- Translating High-Level Language
    1. Interpretation (ì‹¤í–‰ì„ ìœ„í•œ í•´ì„. ì‹¤ì œ machine instructionì´ ì‹¤í–‰ë˜ëŠ” ê²ƒ)
        - executes program statements
        - generally one line/command at a time, ì „ì²´ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ íš¨ìœ¨ì„±ì´ ë‚®ìŒ
        - debug, ë³€ê²½, ì¤‘ê°„ê²°ê³¼ í™•ì¸ì´ ì‰¬ì›€ (statement ë‹¨ìœ„ë¡œ ìˆ˜ì • ê°€ëŠ¥í•˜ë¯€ë¡œ)
        - ì–¸ì–´ - BASIC, LISP, Perl, Matlab, C-shell
    2. Compilation (high level languageë¥¼ machine languageë¡œ ì „í™˜)
        - high level languageì˜ ì „ì²´ statementë¥¼ machine languageë¡œ traslate í•¨ (ì‹¤í–‰í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ executable programì„ ìƒì„±í•¨)
        *CS50 - Asembly codeë¥¼ object codeë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì€ ì–´ì…ˆë¸” (Assemble) ë‹¨ê³„
        - ì „ì²´ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ê³  ìˆìœ¼ë¯€ë¡œ ìµœì í™” ê¸°íšŒê°€ ë§ê³ , íš¨ìœ¨ì„±ì´ ë†’ìŒ
        - ë³€ê²½ ì‹œ compilationì„ ë‹¤ì‹œ í•´ì•¼ í•¨. debugê°€ ì–´ë ¤ì›€
        - ì–¸ì–´ - C, C++, Fortran, Pascal
    3. Interpretation&Compilationì˜ Hybrid
        - Java
        - Java languageëŠ” JVM (Java Virtual Machine) byte codeë¡œ ì»´íŒŒì¼ëœë‹¤.
        - JVM byte codeëŠ” 1) interpreted ë˜ì–´ ì‹¤í–‰ë˜ê±°ë‚˜, ë˜ëŠ” 2) native machine codeë¡œ compileë˜ì–´ ì‹¤í–‰ëœë‹¤. - JIT (Just in Time, ì½”ë“œê°€ ì‹¤í–‰ë  ë•Œ ì»´íŒŒì¼) ë˜ëŠ” AOT (Ahead of Time, ì½”ë“œê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì»´íŒŒì¼) ì»´íŒŒì¼ëŸ¬ì— ì˜í•´
        - Python
        - Python í”„ë¡œê·¸ë¨ì€ byte code (Java Language ë“±)ìœ¼ë¡œ convertedëœë‹¤. - PVM (Python Virtual Machine) for CPython, JVM for Jythonì— ì˜í•´
        - byte codeëŠ” native machine codeë¡œ interpreted ë˜ëŠ” compileëœë‹¤. - JIT (Just in Time) ë˜ëŠ” AOT (Ahead of Time) ì»´íŒŒì¼ëŸ¬ì— ì˜í•´
    - ì˜ˆì‹œ

        ```swift
        func getZ (W: Int) {
        		X = W + W
        		Y = X + X
        		Z = Y + Y
        		print("Z")
        }

        ë¼ëŠ” ì½”ë“œê°€ ìˆì„ ë•Œ,
        1. interpretingí•˜ë©´, í•œ ì¤„ì”© ì‹¤í–‰í•˜ì—¬ Zë¥¼ ê³„ì‚°í•œë‹¤.
        2. compileí•˜ë©´, ì „ì²´ ì½”ë“œë¥¼ ë¶„ì„í•˜ì—¬ Z = 8Wë¡œ ìµœì í™”í•˜ê³  Zë¥¼ ê³„ì‚°í•œë‹¤.
        ```

- Compiling C

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png)

    - Pre-processor
    - macro substitution
    - conditional compilation
    - source-level transformations (output is still C)
    - Compiler
    - generates object file (machine instruction)
    1) Source Code Analysis
        - Front-end, parses programs to identify its pieces (ë³€ìˆ˜, í•¨ìˆ˜ ë“±). Cì–¸ì–´ ì½”ë“œë¥¼ ë¶„ì„í•´ì„œ ì–´ë–¤ ë¬¸ë²•ì  êµ¬ì¡°ë¥¼ ê°€ì§€ëŠ”ì§€ íŒŒì•…í•¨
        - depends on language (not on target machine)
    2) Code Generation
        - Back-end, generates machine code from analyzed source
        - may optimize machine code
        - depends on target machine (íŠ¹ì • instruction set architectureì— ë”°ë¼ machine code, machine instructionì´ ë˜ë¯€ë¡œ)
    3) Symbol Table
        - map between symbolic names and items
        - Assemblerì˜ Symbol Tableê³¼ ìœ ì‚¬í•˜ì§€ë§Œ ë³´ë‹¤ ë‹¤ì–‘í•¨
    - Linker
    - combine object files (including libraries) into executable image
    - ì˜ˆì‹œ

        ```c
        #include <stdio.h> // 1) # : pre-processorì— ì˜í•´ ì²˜ë¦¬ë¨
        #define STOP 0     // 2)

        // description : counts down from user input to STOP
        main () // 3) function : main
        {
        		int counter; // 4) ë³€ìˆ˜ ì„ ì–¸
        		int startPoint;

        		printf("Enter a positive number: "); // 5) prompt user for input (promptë¥¼ í†µí•´ userì—ê²Œ ë³´ì—¬ì¤€ë‹¤)
        		scanf("%d, &startPoint"); // 6) read into startPoint (userê°€ ì…ë ¥í•œ ê°’ì„ readí•´ì„œ startPoint ë³€ìˆ˜ì— í• ë‹¹) *scanf : ë³€ìˆ˜ ê°’ì„ input ë°›ìŒ

        		for (counter = startPoint; counter >= STOP; counter--)
        			printf("%d\n", counter); // 5) count down and print count 
        }
        ```

        1) pre-processor ë‹¨ê³„ë¡œ í•´ë‹¹ íŒŒì¼ì˜ ì†ŒìŠ¤ì½”ë“œë¥¼ ê°€ì ¸ì™€ì„œ ëŒ€ì²´í•œë‹¤.
            - Before compiling, copy contents of header file (stdio.h) into source code.
            - header fileì€ ë³´í†µ ìƒìˆ˜, ë³€ìˆ˜, í•¨ìˆ˜ ì •ì˜ ë“±ì„ í¬í•¨í•œë‹¤.
        2) pre-processor ë‹¨ê³„ë¡œ String STOPì„ String 0ìœ¼ë¡œ ëŒ€ì²´í•œë‹¤.
            - Before compiling, replace all instances of the String "STOP" with the String "0"
            - Called as macro (macro substitution)
            - ì‹¤í–‰í•˜ëŠ” ë™ì•ˆ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê°’ì— ì‚¬ìš©ëœë‹¤. ë‹¨, í”„ë¡œê·¸ë¨ì´ reusedë  ë•ŒëŠ” ë³€ê²½ë  ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë¯€ë¡œ recompileí•´ì•¼ í•œë‹¤.
        3) í”„ë¡œê·¸ë¨ì„ runí•˜ë©´ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
        4) ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
             - symbolic name : counter, ê°’ì„ ë‹´ì„ ì»¨í…Œì´ë„ˆì˜ type : int 
               (data typeì„ ì»´íŒŒì¼ëŸ¬ì— ì „ë‹¬í•˜ì—¬ ì–¼ë§ˆë§Œí¼ì˜ ê³µê°„ì„ í• ë‹¹í• ì§€ ë“±ì„ interpretí•œë‹¤.)
        5) Output 
            - String contains characters to print and formatting directions for variables. (ë³€ìˆ˜ ê°’ì„ ì–´ë–¤ typeìœ¼ë¡œ ì¶œë ¥í• ì§€)
            - ë³€ìˆ˜ counterë¥¼ %d (decimal integer) typeìœ¼ë¡œ ì¶œë ¥í•œë‹¤. ê·¸ë¦¬ê³  linefeed (\n)ë¥¼ ì¶œë ¥í•œë‹¤.
            - ì˜ˆì‹œ) printf("%d %d\n", counter, startPoint - counter); // ë³€ìˆ˜ ì™¸ì—ë„ ì—°ì‚° ê°’ì„ ì¶œë ¥ ê°€ëŠ¥í•˜ë‹¤.
            *formatting options - %x (hexadecibal integer), %c (ASCII character), %f (floating-point number)
        6) Input
            - String contains formatting directions for looking at input. 
            - %d typeì˜ ê°’ì„ readí•˜ì—¬ ë³€ìˆ˜ startPointì— í• ë‹¹í•œë‹¤.
            - & (Ampersand)ë¥¼ ì‚¬ìš©í•œë‹¤. (Pointerì—ì„œ ì„¤ëª…)

# 10. *Variable, Operator

- ë³€ìˆ˜
- holds a value upon which a program acts
- an abstraction (ì¦‰, symbolic name) of a memory location, but its value is moved to a register when subject to an operation and moved back to memory when registers are full
   (ì‹¤ì œ ì—°ì‚°ì„ í•  ë•Œ ê°’ì´ memoryì—ì„œ registerë¡œ ì´ë™í•¨)
- ë³€ìˆ˜, ìƒìˆ˜, ì—°ì‚°ì ë“±ìœ¼ë¡œ í‘œí˜„ëœ Expressionì€ ì—°ì‚°ì„ í†µí•´ valueë¥¼ êµ¬í•˜ë©° (evaluate to a value), typeì„ ê°€ì§ 
   (í• ë‹¹ì—°ì‚°ì '='ë„ 1) í• ë‹¹ actionì„ ìˆ˜í–‰í•˜ë©´ì„œ, 2) valueë¥¼ ê°€ì§€ë©° í•´ë‹¹ ê°’ì€ "ì—°ì‚°ì˜ ê²°ê³¼ë¡œ í• ë‹¹ë˜ëŠ” ê°’"ì„. Cì˜ íŠ¹ì§•)
- Expressionì˜ ê²°ê³¼ê°’ì„ areaì— í• ë‹¹í•˜ëŠ” ê²ƒì€ Statementì„ (ì‘ì—…ì˜ ë‹¨ìœ„;)
   - simple statement `a = b + 1;`
   - compound statement `{ a = b + 1; b = c * d; }`
    - Scope
    - Compiler infers scope from where variable is declared. (ì»´íŒŒì¼ëŸ¬ëŠ” ë³€ìˆ˜ê°€ ì„ ì–¸ëœ ìœ„ì¹˜ì—ì„œ ë²”ìœ„ë¥¼ ì¶”ë¡ í•œë‹¤.)
    - Global : accessed anywhere in program. declared outside of all blocks
    - Local : only accessible in a particular region. Variable is local to the block {} in which it is declared.
- ì—°ì‚°ì
- predefined actions performed on values
- an abstraction of arithmetic/logic instructions
- ë…¼ë¦¬ì—°ì‚°ì : Bool typeì˜ ê²°ê³¼ê°’ì„ Intë¡œ í‘œí˜„ (0=false, 1=true) ë‹¨, í”¼ì—°ì‚°ìë¥¼ ì·¨ê¸‰í•  ë•Œ 0=false, 0ì™¸ ëª¨ë“  ê°’=trueë¡œ ì¸ì‹í•¨ (Cì˜ íŠ¹ì§•)
- Precedence (ìš°ì„  ìˆœìœ„)
   - ì—°ì‚°ì ìš°ì„ ìˆœìœ„ëŠ” */%ì´ 6ì´ê³ , +-ì´ 7ì„ (ìˆ«ì ì ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ)
- Associativity (ê²°í•© ë²•ì¹™)
   - Assignment associates right to left. (í• ë‹¹ì—°ì‚°ìì˜ ê²°í•© ë²•ì¹™ì€ ìš°ì—ì„œ ì¢Œì„) ë”°ë¼ì„œ `y = x = 3;` ì˜ ì˜ë¯¸ëŠ” `y = (x = 3);`ê³¼ ë™ì¼í•¨ (3ì„ xì— í• ë‹¹í•˜ê³ , xë¥¼ yì— í• ë‹¹)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png)

- Symbol Table
- ì»´íŒŒì¼ëŸ¬ëŠ” ë³€ìˆ˜ ê´€ë ¨ ì •ë³´ë¥¼ ì €ì¥í•œë‹¤. (ë³€ìˆ˜ëª…, type, memory location (Offset), scope)
- ë¡œì»¬ë³€ìˆ˜ Storage (YT 50min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png)

    - ë¡œì»¬ë³€ìˆ˜ëŠ” user stack (activation record, stack frame)ì— ì €ì¥ëœë‹¤.
    - main í•¨ìˆ˜ì— ë³€ìˆ˜ê°€ í• ë‹¹ë˜ë©´, memoryì˜ stack ë°”ë‹¥ë¶€í„° ìŒ“ì¸ë‹¤. (main í•¨ìˆ˜ì˜ stack í¬ê¸°ê°€ ëŠ˜ì–´ë‚œë‹¤.) ë§Œì•½ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ë©´ì„œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©´, ì„ ì–¸ ìˆœìœ¼ë¡œ stackì— ìŒ“ì¸ë‹¤. 
    - main í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, activation recordê°€ stackì— ìŒ“ì¸ë‹¤. 
    *(12. Function ì°¸ê³ ) activate record : procedureê°€ í•œ ë²ˆ ìˆ˜í–‰ë˜ê¸° ìœ„í•´ í•„ìš”í•œ ì •ë³´ëŠ” memoryì˜ ì—°ì† ë¸”ë¡ì„ ì‚¬ìš©í•˜ì—¬ ê´€ë¦¬í•˜ëŠ”ë°, ì´ë•Œ ì—°ì† ë¸”ë¡ì„ ì˜ë¯¸í•¨. ì§€ì—­ë³€ìˆ˜ ë° ê·¸ì™¸ í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì— í•„ìš”í•œ ì •ë³´.
    The activation record is temporary - it is allocated when the function is called (becomes active) and it is deallocated when the function returns (becomes inactive). Once an activation record is deallocated, the memory it occupied is available for use when new activation records are created.
    - Symbol Table "Offset"ì€ the base of the frameìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
    - R5 (frame pointer) holds address of the base of the current frame. (the base of the activation record)
    - A new frame is pushed on the run-time stack each time a function is called or a block is entered.
    - bc stack grows downward, R5 contains the highest address of the frame (*ì£¼ì˜-frame baseë¡œ ë‚´ë ¤ê°ˆìˆ˜ë¡ addressëŠ” ë†’ì•„ì§. ì¦‰, ê·¸ë¦¼ ìƒ ìœ„ë¡œ ìŒ“ëŠ” í˜•íƒœë¡œ ë³´ì´ì§€ë§Œ, ì‹¤ì œë¡œ ë³€ìˆ˜ê°€ í• ë‹¹ë˜ë©´ ì•„ë˜ ë°©í–¥ì˜ ë©”ëª¨ë¦¬ê°€ í• ë‹¹ë˜ë©´ì„œ Stackì´ ì•„ë˜ë¡œ ëŠ˜ì–´ë‚¨), and variable offsets are <= 0. 
      (offset : R5ê°€ ê°€ë¥´ì¹˜ëŠ” ê³³ì´ 0, ê·¸ ìœ—ì¹¸ë¶€í„° ì˜¬ë¼ê°ˆìˆ˜ë¡ -1, -2 ... -5ê°€ ë¨)
        - [ ]  stack grows downward ???
- í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ memory (YT 55min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png)

    - Instructions 
    - í˜„ì¬ ì‹¤í–‰ë˜ëŠ” instructionì€ PC (Program Counter)ê°€ íŠ¸ë˜í‚¹í•˜ê³  ìˆë‹¤.
    - Global data section
    - ëª¨ë“  ê¸€ë¡œë²Œ ë³€ìˆ˜ê°€ ì €ì¥ëœë‹¤. (ì—„ë°€íˆëŠ” ëª¨ë“  static ë³€ìˆ˜)
    - R4ëŠ” beginning (ì‹œì‘ ì£¼ì†Œ)ì„ ê°€ë¥´í‚¨ë‹¤.
    - Run-time stack
    - ë¡œì»¬ë³€ìˆ˜ ì‚¬ìš©ì— í™œìš©ëœë‹¤. (ì—„ë°€íˆëŠ” automatic ë³€ìˆ˜)
    - R6 (stack pointer)ëŠ” top of stack (stack ìµœìƒë‹¨)ì„, R5 (frame pointer)ëŠ” top frame on stack (the base of the current frame, í˜„ì¬ í•¨ìˆ˜ì˜ frame base) ì„ ê°€ë¥´í‚¨ë‹¤.
    - ê°œë³„ blockì— new frameì´ ì£¼ì–´ì§„ë‹¤. (block exit, ì¦‰ ë©”ëª¨ë¦¬ê°€ freeë˜ë©´ ì‚¬ë¼ì§„ë‹¤.)
    *ë³€ìˆ˜ ì„ ì–¸ ì‹œ staticì´ ì—†ìœ¼ë©´ automatic ë³€ìˆ˜ì´ë‹¤. í•´ë‹¹ blockì— ë“¤ì–´ê°€ë©´ ë©”ëª¨ë¦¬ê°€ allocateë˜ê³ , blockì—ì„œ ë‚˜ê°€ë©´ free ëœë‹¤.
    ë°˜ë©´, staticì´ ìˆìœ¼ë©´ static ë³€ìˆ˜ì´ë‹¤. blockì— ë“¤ì–´ê°€ê³  ë‚˜ê°€ëŠ” ê²ƒê³¼ ë¬´ê´€í•˜ê²Œ í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œ allocateë˜ê³ , í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ free ëœë‹¤.
    â‡’ ë”°ë¼ì„œ 'static ë¡œì»¬ë³€ìˆ˜'ëŠ” ë¡œì»¬ë³€ìˆ˜ì´ì§€ë§Œ Stackì´ ì•„ë‹ˆë¼ Globalì— í• ë‹¹ëœë‹¤.
    - Offset : ì €ì¥ê³µê°„ì˜ ì‹œì‘ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ì´ë‹¤.
    - Global : LDR R1, R4, #4 // Globalì˜ R4ë¥¼ ê¸°ì¤€ìœ¼ë¡œ accessí•¨
    - Local   : LDR R2, R5, #-3 // Stackì˜ R5ë¥¼ ê¸°ì¤€ìœ¼ë¡œ accessí•¨
- Variable & Memory Location
    - ë³€ìˆ˜ëŠ” í•­ìƒ ë©”ëª¨ë¦¬ì— ì €ì¥ëœë‹¤.
    - ì–´ë–¤ ë³€ìˆ˜ê°€ í• ë‹¹ë˜ë©´, memory locationì— ì €ì¥ëœë‹¤. 
    - instruction ìˆ˜ì¤€ì—ì„œëŠ” store operationì„ ì§„í–‰í•œë‹¤. (ì»´íŒŒì¼ì˜ ê²°ê³¼ë¡œ ìƒì„±ë˜ëŠ” instruction)
    - ì»´íŒŒì¼ëŸ¬ëŠ” ì½”ë“œ ìµœì í™”ë¥¼ ìœ„í•´ ë³€ìˆ˜ë¥¼ registerì— í• ë‹¹í•˜ë ¤ê³  í•œë‹¤. ì™œ?
    - +, && ë“± operationì„ í•˜ë ¤ë©´ ê°’ì´ (ì„ì‹œë¡œë¼ë„) registerì— ìˆì–´ì•¼ë§Œ ì—°ì‚°ì´ ê°€ëŠ¥í•˜ë‹¤.
    - ì„±ëŠ¥ ì¸¡ë©´ì—ì„œ registerë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ memoryë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒë³´ë‹¤ ë” ë¹ ë¥´ë‹¤.
    - ë”°ë¼ì„œ ì»´íŒŒì¼ì€ ë³´í†µ ë©”ëª¨ë¦¬ì— home locationì´ ìˆê³ , í•„ìš”ì— ë”°ë¼ (ì—°ì‚°ì„ í•˜ê±°ë‚˜ ë¹ ë¥¸ accessê°€ í•„ìš”í•  ë•Œ) registerì— ì„ì‹œë¡œ ê°’ì„ ì´ë™ì‹œí‚¤ëŠ” ìµœì í™” ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

# 11. Control Structure

- row level language - ë³´í†µ machine instructionì€ sequential í•˜ê²Œ ìˆ˜í–‰ë˜ê³ , conditional branch ë˜ëŠ” jump instructionì— ì˜í•´ non-sequentialí•˜ê²Œ ìˆ˜í–‰ë˜ê¸°ë„ í•œë‹¤.
- high level language - Sequence, Conditional, Iterarion ë“±ì˜ Control Structureê°€ ìˆë‹¤.

- Condition
    - `if (condition) action;`
    - condition : C expression, action : C statement;

        ```c
        if (x <= 10) {
        y = x + 1; // conditionì´ trueì´ë©´ action (2ê°œ statement)ì´ ì‹¤í–‰ë¨
        z = y + 1;
        }

        if (x <= 10) // {}ê°€ ì—†ìœ¼ë©´ condition ë’¤ì˜ 1ê°œ statementë§Œ ifë¬¸ ì†Œì†ìœ¼ë¡œ ì¸ì‹ë¨
        y = x + 1; // conditionì´ trueì´ë©´ action (1ê°œ statement)ì´ ì‹¤í–‰ë¨
        z = y + 1; // conditionê³¼ ìƒê´€ì—†ì´ í•­ìƒ ì‹¤í–‰ë¨

        ```

    - `switch (expression) {caseconst1: action1;break;caseconst2: action2;break;default:action3;}`
    - breakë¥¼ ê° caseì— ì¶”ê°€í•˜ëŠ” ê²ƒì´ ë°”ëŒì§í•¨. breakê°€ ì—†ìœ¼ë©´ const1 ì¡°ê±´ì„ ë§Œì¡±í•  ê²½ìš°, case1ì—ì„œ ì¢…ë£Œë˜ì§€ ì•Šê³  case2, defaultë¡œ ë„˜ì–´ê°€ì„œ ëª¨ë‘ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ (Cì˜ ë‹¨ì )
    - const1ì„ ë§Œì¡±í•˜ë©´ action1ì„ ì‹¤í–‰í•˜ê³  ì¢…ë£Œ, const2ë¥¼ ë§Œì¡±í•˜ë©´ action2ë¥¼ ì‹¤í–‰í•˜ê³  ì¢…ë£Œ, ìœ„ì˜ ëª¨ë“  ì¡°ê±´ì—ì„œ falseì´ë©´ defaultë¥¼ ì‹¤í–‰í•˜ê³  ì¢…ë£Œ (breakê°€ ìˆìœ¼ë¯€ë¡œ)
        - break
        - used only in switch or iteration statement
        - *passes control out of the smallest statement (loop or switch) containing it to the statement immediately following (breakë¥¼ í¬í•¨í•˜ëŠ” ì‹¤í–‰ë¬¸ (ë°˜ë³µë¬¸ ë˜ëŠ” switchë¬¸)ì˜ ì œì–´ë¥¼ ë°”ë¡œ ë‹¤ìŒ ì‹¤í–‰ë¬¸ (í•´ë‹¹ ë°˜ë³µë¬¸ ë˜ëŠ” switchë¬¸ ì™¸ë¶€)ìœ¼ë¡œ ì „ë‹¬í•œë‹¤.)
        - usually used to exit a loop before terminating condition occurs (or to exit switch statement when case is done)
        - continue
        - used only in iteration statement
        - *terminates the execution of the loop body for this iteration (ë°˜ë³µë¬¸ì˜ í•´ë‹¹ iterationì˜ ì‹¤í–‰ë¬¸ì„ ì¦‰ì‹œ ì¢…ë£Œí•˜ê³ , ë‹¤ìŒ iterationìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.)
        - loop expression is evaluated to see whether another iteration should be performed
        - if 'for loop', also executes the re-initializer (forë¬¸ì´ë©´ re-initializerë¥¼ ì‹¤í–‰í•œ ì´í›„, ë‹¤ìŒ iterationìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.)

            ```c
            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) continue;
            		printf("%d ", i);
            }
            // ifë¬¸ì´ trueì´ë©´ ë‹¤ìŒ iterationì„ ì‹¤í–‰í•¨ -> 20 ì´í•˜ì˜ í™€ìˆ˜ê°€ ì¶œë ¥ë¨

            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) break;
            		printf("%d ", i);
            }
            // i = 0ì¸ ì²«ë²ˆì§¸ iterationì—ì„œ break -> *forë¬¸ ìì²´ë¥¼ ì¢…ë£Œí•¨
            ```

- *Iteration
    - `while (test) loop_body;`
    - Executes loop_body as long as test evaluates to True (non-zero).
    - `for (init;test;re-init) statement;`
    - Executes loop_body as long as test evaluates to True (non-zero). Initialization and re-initialization code include in loop statement.
    - `init;while (test) {statement;re-init}` êµ¬ì¡°ì™€ ë™ì¼í•˜ë‹¤.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png)

        ```c
        // Nested Loops

        for (mp1 = 0; mp1 < 10; mp1++) {      // 1) mp1 = 0ì´ ë¨¼ì € ë“¤ì–´ê°€ê³ 
        		for (mp2 = 0; mp2 < 10; mp2++) {  // 2) mp2ê°€ 0ì—ì„œ 9ê¹Œì§€ ëŒê³ ë‚˜ì„œ, (ë‹¤ì‹œ mp1 = 1ì´ ë“¤ì–´ê°€ê³ , mp2ê°€ 0ì—ì„œ 9ê¹Œì§€ ëŒê³ ë‚˜ì„œ ... ë°˜ë³µ)
        				printf("%d\t", mp1 * mp2);
        		}
        		print("\n")
        } // prints a multiplication table.

        for (outer = 1; outer < 10; outer++) {
        		for (inner = 0; inner < outer; inner++) {  // outer ë³€ìˆ˜ì— ë”°ë¼ ë‚´ë¶€ forë¬¸ì˜ ì‹¤í–‰íšŸìˆ˜ê°€ ê²°ì •ë˜ëŠ” êµ¬ì¡°
        				sum += inner;
        		}
        }
        ```

    - For Vs. While
        - For loop : counter-based loopì— ì í•©í•˜ë‹¤. (ex. 5ë²ˆ count ë™ì•ˆ ì‹¤í–‰í•´ë¼)
        - While loop : sentinel (ë³´ì´ˆë³‘)-based loopì— ì í•©í•˜ë‹¤. (ex. íŠ¹ì • ì¡°ê±´ ë™ì•ˆ ì‹¤í–‰í•´ë¼)
- Problem Solving in C
    - Stepwise Refinement 
    - machine instructionì„ ì´ìš©í•˜ë©´ machine languageê¹Œì§€ ë‚´ë ¤ê°€ì•¼ problem solvingì´ ê°€ëŠ¥í•˜ì§€ë§Œ,
       Cì—ì„œëŠ” Cì–¸ì–´ ìì²´ë¡œ problem solvingì´ ê°€ëŠ¥í•˜ë¯€ë¡œ ì‘ì—…ì´ ì‰½ê³  ìƒì‚°ì„±ì´ ì¢‹ë‹¤.

# 12. Function

- ì¥ì 
    - ìì£¼ ì“°ëŠ” ê¸°ëŠ¥ì„ subcompomentë¡œ ë§Œë“ ë‹¤. ì´ë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì˜ compositional designì´ ê°€ëŠ¥í•˜ë‹¤.
    - ì‘ì—…ì— ëŒ€í•œ abstractionì„ ì§€ì›í•œë‹¤.
    - hides low-level details (input, output ê´€ê³„ë§Œ ì•Œë©´ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤. ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ êµ¬í˜„ì´ ë˜ëŠ”ì§€ëŠ” ìˆ¨ê²¨ì¤€ë‹¤.)  
    - gives high-level structure to program, and make it easier to understand overall program flow
    - C Function
    - argument : zero or multiple arguments passed in
    - return : single result returned (optional-outputì´ ì—†ëŠ” ê²½ìš°ë„ ìˆë‹¤.)
    - ë‹¤ë¥¸ ì–¸ì–´ì—ì„œëŠ” procedure, subroutineìœ¼ë¡œ ë¶€ë¥¸ë‹¤.
- Declaration & Call & Definition
    - [x]  ì™œ parameterê°€ ì„ ì–¸í•  ë•ŒëŠ” 1ê°œì¸ë°, í˜¸ì¶œí•  ë•ŒëŠ” 2ê°œê°€ ë“¤ì–´ê°€ì§€?
        - f+gì˜ ê²°ê³¼ê°’ì´ parameter nì˜ argumentë¡œ ì „ë‹¬ëœë‹¤.

    ```c
    // Declaration
    int Factorial(int n;) // prototype
    // ì°¨ë¡€ë¡œ return type, Function Name, types/number of all arguments

    // Call (Invocation)
    a = x + Factorial(f + g) // 1) evaluate argument, 2) evaluate function, 3) use return value in expression.

    // Definition - í•¨ìˆ˜ êµ¬í˜„ê³¼ ê´€ë ¨ëœ low-level detail
    // - Declaration ë‚´ìš© (State type, name/types of arguments ë“±)ê³¼ ì¼ì¹˜ì‹œí‚¨ë‹¤. (argument nameì„ ë™ì¼í•˜ì§€ ì•Šê²Œ ë¶€ì—¬ ê°€ëŠ¥í•˜ì§€ë§Œ, ë¹„íš¨ìœ¨ì ì´ë‹¤.)
    int Factorial(int n) {
    		int i;
    		int result = 1;

    		for (i = 1; i <= n; i++)
    				result = result * i;

    		return result; // ê°’ì„ ë°˜í™˜í•˜ê³ , gives control back to calling function (controlì€ í•¨ìˆ˜ í˜¸ì¶œ ì§€ì ìœ¼ë¡œ ë˜ëŒì•„ê°„ë‹¤.)
    }  
    ```

    - Declarationì´ í•„ìš”í•œ ì´ìœ 
        - Definition ì´ì „ì— í•¨ìˆ˜ë¥¼ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤. (C íŠ¹ì§•)
        - ì»´íŒŒì¼ëŸ¬ëŠ” return type, argument type/numberë¥¼ ì•Œì•„ì•¼ í•œë‹¤.
        - Definitionì´ ë‹¤ë¥¸ íŒŒì¼ì— ë“¤ì–´ìˆê±°ë‚˜, ë‹¤ë¥¸ ê°œë°œìì— ì˜í•´ ì‘ì„±ëœ ê²ƒì¼ ìˆ˜ ìˆë‹¤.
        - include a "header file" with function declarations only (í•¨ìˆ˜ ì„ ì–¸ì´ ë“¤ì–´ìˆëŠ” í—¤ë”íŒŒì¼ì„ í¬í•¨ì‹œí‚¨ë‹¤. ê°œë³„ì ìœ¼ë¡œ ì»´íŒŒì¼í•˜ê³ , ìµœì¢… ì‹¤í–‰ ì „ì— link í•´ì•¼ í•œë‹¤.)
- Implementing Function (YT 16min)
    - í•¨ìˆ˜ í˜¸ì¶œ ì‹œ, ì–´ë–»ê²Œ machine instruction ìˆ˜ì¤€ì—ì„œ êµ¬í˜„ë˜ëŠ”ì§€

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png)

    - *Activation Record (=Stack Frame)
    - í•¨ìˆ˜ ì •ë³´ (argument, return value, ë¡œì»¬ë³€ìˆ˜ ë“±)ëŠ” activation recordì— ë‹´ê²¨ìˆë‹¤. (ARì€ í•¨ìˆ˜ í˜¸ì¶œ ì‹œ ìƒì„±ëœë‹¤.)
    - í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ í•´ë‹¹ í•¨ìˆ˜ì˜ activation recordê°€ run-time stackì— allocateëœë‹¤. (ì—¬ëŸ¬ Callerì— ì˜í•´ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œë˜ë©´, ARì´ ê°œë³„ì ìœ¼ë¡œ ë‹¤ë¥¸ memory locationì— ìƒì„±ëœë‹¤.)
    - í•¨ìˆ˜ Call ë° Returnì˜ ê³¼ì • ğŸŒ´ğŸŒ´ğŸŒ´
    - ì–´ë–¤ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, í•´ë‹¹ í•¨ìˆ˜ëŠ” Calleeì´ê³ , í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ì§€ì ì€ Callerì´ë‹¤.
    1. Callerê°€ argumentë¥¼ ì „ë‹¬í•˜ê¸° ìœ„í•´ argumentì˜ ê°’ì„ ë³µì‚¬í•´ì„œ activation recordì— pushí•œë‹¤.
    2. Callerê°€ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤. 
    3. CalleeëŠ” ìê¸° í•¨ìˆ˜ì˜ ë¡œì»¬ë³€ìˆ˜ë¥¼ allocateí•œë‹¤. (ARì„ stackì— pushí•¨)
    4. CalleeëŠ” ì½”ë“œë¥¼ ì‹¤í–‰í•´ì„œ return valueë¥¼ êµ¬í•˜ê³ , return ê°’ì„ activation recordì˜ í•´ë‹¹ ìœ„ì¹˜ì— ë„£ëŠ”ë‹¤.
    5. CalleeëŠ” ì‚¬ìš©ì´ ì™„ë£Œëœ ë¡œì»¬ë³€ìˆ˜ë¥¼ freeí•˜ê³ , í•¨ìˆ˜ë¥¼ return í•œë‹¤. (í•¨ìˆ˜ë¥¼ return í•œë‹¤ : Callerë¡œ ë˜ëŒì•„ê°€ê¸° ìœ„í•´ Program counterì„ ë˜ëŒë¦¬ê³ , ARì„ stackì—ì„œ popí•¨)
    6. CallerëŠ” activation recordì—ì„œ returnê°’ì„ êº¼ë‚´ì–´ ì‚¬ìš©í•œë‹¤.
        - Argument values : allocated, set up, free - by Caller
        Return value : allocated, set up - by Callee / used, free - by Caller
        Return address : allocated, set up, free - by Callee
        dynamic link : allocated, set up, restore, free - by Callee
        local variables (ì—„ë°€íˆëŠ” automatic variables) : allocated, set up, free - by Callee
    - (ì •ë¦¬) Run-time Stack
    - *ë¡œì»¬ë³€ìˆ˜ëŠ” stack in an activation recordì— ì €ì¥ëœë‹¤.
    - í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ í•´ë‹¹ í•¨ìˆ˜ì˜ activation recordê°€ stackì— allocateëœë‹¤.
    - R5 (frame pointer)ëŠ” the beginning of a region of activation record (í˜„ì¬ í•¨ìˆ˜ ê´€ë ¨ ë¡œì»¬ë³€ìˆ˜ê°€ ì €ì¥ë˜ì–´ ìˆìŒ)ë¥¼ ê°€ë¥´í‚¨ë‹¤.
    - ìƒˆë¡œìš´ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, activation recordê°€ stackì— pushëœë‹¤.
       í•´ë‹¹ í•¨ìˆ˜ê°€ returnë˜ë©´, activation recordsëŠ” stackì—ì„œ pop offëœë‹¤. 
       (í•¨ìˆ˜ í˜¸ì¶œ ë° return ê³¼ì •ì´ LIFOì´ë¯€ë¡œ activation recordë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ allocate/free ì‹œí‚¬ ìˆ˜ ìˆë‹¤.)
        - *ì˜ˆì‹œ1 - ì½”ë“œê°€ ì‹¤í–‰ë  ë•Œ stackì˜ êµ¬ì¡°

            ```c
            int main() 
            {
            	int a; // 0. stackì— ë¡œì»¬ë³€ìˆ˜ê°€ allocate ë¨
            	int b;
              // ...
            	b = Watt(a); // 1. Main í•¨ìˆ˜ê°€ Watt í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            	b = Volta(a,b); // 5. Main í•¨ìˆ˜ê°€ Volta í˜¸ì¶œ
            } // 7. main return

            int Watt(int a)
            {
            	int w; 
              // ...
            	w = Volta(w,10); // 2. Watt í•¨ìˆ˜ê°€ Volta í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            	return w; // 4. Watt return -> 1
            }

            int Volta(int q, int r)
            {
            	int k;
            	int m;
              // ...
            	return k; // 3. Volta return -> 2 / 6. Volta return -> 1
            }
            ```

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png)

            1. (ì²«ë²ˆì§¸ ê·¸ë¦¼) Main í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (a,b)ì˜ base (ìµœìƒìœ„ ì£¼ì†Œ)ë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 2ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 2ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) - 0. stackì— ë¡œì»¬ë³€ìˆ˜ê°€ allocate ë¨
            R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 
            2. (ë‘ë²ˆì§¸ ê·¸ë¦¼) Mainì—ì„œ Wattë¥¼ í˜¸ì¶œí•˜ê³ , Watt í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, Wattì˜ activation recordê°€ pushëœë‹¤. - 1. Main í•¨ìˆ˜ê°€ Watt í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (w)ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 1ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 1ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) 
            R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 
            3. (ì„¸ë²ˆì§¸ ê·¸ë¦¼) Mainì—ì„œ Voltaë¥¼ í˜¸ì¶œí•˜ê³ , Volta í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, Voltaì˜ activation recordê°€ pushëœë‹¤. - 2. Watt í•¨ìˆ˜ê°€ Volta í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (k,m)ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 2ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 2ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) 
            R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png)

            4. (ë„¤ë²ˆì§¸ ê·¸ë¦¼) Voltaê°€ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. (return control to Caller and pop) - 3. Volta return -> 2 
            5. (ë‹¤ì„¯ë²ˆì§¸ ê·¸ë¦¼) Wattê°€ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. - 4. Watt return -> 1
            6. (ì—¬ì„¯ë²ˆì§¸ ê·¸ë¦¼) Mainì—ì„œ Wattë¥¼ í˜¸ì¶œí•˜ê³ , Watt í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, Wattì˜ activation recordê°€ pushëœë‹¤. - 5. Main í•¨ìˆ˜ê°€ Volta í˜¸ì¶œ
                R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (w)ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 1ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 1ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) 
                R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 
            7. (ë‹¤ì‹œ ë‹¤ì„¯ë²ˆì§¸ ê·¸ë¦¼) Voltaê°€ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. - 6. Volta return -> 1
            8. Mainì´ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. - 7. main return
                ì´ë•Œ R5ëŠ” Main í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ System ì´ˆê¸°í™” routineì—ì„œ ë¡œì»¬ë³€ìˆ˜ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤.
                R6ëŠ” Main ì•„ë˜ì¤„ (stack ìµœìƒë‹¨)ì„ ê°€ë¥´í‚¨ë‹¤.

            - ì°¸ê³  - LC-3ì˜ í•¨ìˆ˜ í˜¸ì¶œ Implementation
                1. Caller pushes arguments (last to first)
                2. Caller invokes subroutine (JSR)
                3. Callee allocates return value, pushes R7 and R5
                4. Callee allocates space for local variables
                5. Callee executes function code
                6. Callee stores result into return value slot
                7. Callee pops local vars, pops R5, pops R7
                8. Callee returns (JMP R7)
                9. Caller loads return value and pops arguments
                10. Caller resumes computation
        - *ì˜ˆì‹œ2 - ì½”ë“œê°€ ì‹¤í–‰ë  ë•Œ activation recordì˜ êµ¬ì¡°

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png)

            - í•¨ìˆ˜ FNameì„ í˜¸ì¶œí•˜ë©´, ê·¸ë¦¼ê³¼ ê°™ì´ activation recordì´ ìƒì„±ëœë‹¤.
            - ê·¸ë¦¼ ìƒ ì•„ë˜ë¶€í„° ì°¨ë¡€ë¡œ argument, return value (ê°’ì„ êµ¬í•  ë•Œê¹Œì§€ ë¹„ì›Œë‘ ), return address, dynamic link (í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ Callerì˜ R5ê°’), ë¡œì»¬ë³€ìˆ˜ ìˆœìœ¼ë¡œ locateëœë‹¤.
            ì´ë•Œ R5ëŠ” (ë¡œì»¬ë³€ìˆ˜ ì¤‘ì—ì„œ) ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ARì˜ í•˜ë‹¨ì— ë¡œì»¬ë³€ìˆ˜ê°€ ìˆê³ , ê°€ì¥ ì•„ë˜ì˜ ë¡œì»¬ë³€ìˆ˜ê°€ stack frameì˜ baseì´ë¯€ë¡œ) R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤.
                - Offsetì€ R5ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìœ„ìª½ì— ìˆìœ¼ë©´ (-), ì•„ë˜ìª½ì— ìˆìœ¼ë©´ (+) ê°’ì´ë‹¤.
                ì¦‰, R5ê°€ wë¥¼ ê°€ë¥´í‚¤ë¯€ë¡œ w,x,y = 0, -1, -2 / a,b = 4,5 
                (Offsetì´ ìˆìœ¼ë¯€ë¡œ load register ë˜ëŠ” store registerë¥¼ í†µí•´ activation recordì˜ ê° ìš”ì†Œì— ëª¨ë‘ ì ‘ê·¼ê°€ëŠ¥í•˜ë‹¤.)
                - Bookkeepingì„ ìœ„í•œ 3ê°€ì§€ ìš”ì†Œ
                - return value : space for value returned by function. returnê°’ì´ ì—†ë”ë¼ë„ allocate í•œë‹¤.
                - return address : í•´ë‹¹ functionì´ returní•˜ë©´ ë˜ëŒì•„ê°ˆ ì£¼ì†Œ. save pointer to next instruction in calling function. (convenient location to store R7 in case another function (JSR) is called. ë‹¤ë¥¸ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´ ì£¼ì†Œê°€ ì‚¬ë¼ì§€ë¯€ë¡œ)
                - dynamic link : í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ Callerì˜ R5ê°’. FNameì´ returní•˜ë©´ í•´ë‹¹ R5ê°’ì„ ë‹¤ì‹œ restoreí•´ì•¼ í•˜ê¸° ë•Œë¬¸! caller's frame pointer. used to pop this activation record from stack

# 13. Testing/Debugging

- Debugging with high-level language
    - Debugging ì¸¡ë©´ì—ì„œ machine languageì™€ high-level languageì€ ëª©í‘œê°€ ë™ì¼í•˜ë©° í° ì°¨ì´ê°€ ì—†ë‹¤.
    - Examine and set values in memory. ë©”ëª¨ë¦¬ì˜ ê°’ì„ ì½ì–´ë³¸ë‹¤. ê°’ì„ ì„¸íŒ…í•´ë³¸ë‹¤.
    - Execute portions of program. í”„ë¡œê·¸ë¨ ì¼ë¶€ë¥¼ ì‹¤í–‰í•´ë³¸ë‹¤.
    - Stop execution when/where desired. ì›í•˜ëŠ” ì‹œì /ìœ„ì¹˜ì—ì„œ í”„ë¡œê·¸ë¨ì„ ì¤‘ì§€í•´ë³¸ë‹¤.
    - high-level languageì—ì„œëŠ”
    - Examine and set variables (abstraction-memory locationì´ ì•„ë‹ˆë¼ variable)
    - Trace, single-stepping and set breakpoints on statements, function calls (instructionì´ ì•„ë‹ˆë¼)
    - í•„ìš” ì‹œ low-level toolë„ ì‚¬ìš©í•œë‹¤.
- Error Type
    - Syntactic Error 
    - ë¬¸ë²•ì  ì˜¤ë¥˜. Input code is not legal
    - Caught by compiler
    - Semantic Error
    - legal codeì´ì§€ë§Œ, ê°œë°œìê°€ ì˜ë„í•˜ì§€ ì•Šì€ ë°©í–¥ìœ¼ë¡œ êµ¬í˜„ë¨
    - í•´ê²°í•˜ê¸° ì–´ë ¤ìš°ë©° debugging toolì´ í•„ìš”í•¨
    - Algorithmic Error
    - í”„ë¡œê·¸ë¨ logicì˜ ë¬¸ì œ. ë¬¸ì œí•´ê²°ì„ ìœ„í•œ ê°œë°œìì˜ ì˜ë„ê°€ í‹€ë¦¼
    - ex. Y2K bug (only allow 2 digits for year, assuming 19__)
- Testing
    - ì‹¤ì œ inputì„ ì£¼ê³ , ê·¸ ê²°ê³¼ë¥¼ ê´€ì°°/í™•ì¸í•˜ëŠ” ì‘ì—…ì´ë‹¤. ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ê³ ë ¤í•˜ëŠ” ê²ƒì€ í˜„ì‹¤ì ìœ¼ë¡œ ë¶ˆê°€í•˜ë‹¤.
    - Black-Box Testing : program internalsì— ëŒ€í•´ ì•„ë¬´ê²ƒë„ ê°€ì •í•˜ì§€ ì•Šê³ , ì„ì˜ì˜ inputì„ ì£¼ëŠ” ë°©ì‹. replies upon input/output specification. ìë™í™”ê°€ ìš©ì´í•˜ë‚˜ ê²½ë¡œê°€ í•œì •ë¨
    - White-Box Testing : test coverageë¥¼ ì¦ê°€ì‹œì¼œ ë³´ì™„í•œ ë°©ì‹. ë‹¤ì–‘í•œ ê²½ë¡œë¥¼ í™•ì¸í•¨. í•„ìš” ì‹œ assertationì„ ì‚¬ìš©í•¨
- Debuggin Techniques
    - ì£¼ë¨¹êµ¬êµ¬ì‹ - Ad-Hoc
    - Insert printf statements to track flow and values
    - code explicitly checks for values out of expected range
    - Tool ì‚¬ìš© - Source-Level Debugger
    - Examine and set variable values
    - Tracing, breakpoints, single-stepping (ex. cloud9)
        - breakpoints
        - stop when a particular statement is reached (ì ì‹œ ë©ˆì·„ë‹¤ê°€ ì§„í–‰ ê°€ëŠ¥í•œ suspendì˜ ê°œë…) í•¨ìˆ˜ì˜ entry ë˜ëŠ” exitì—ì„œ ë³´í†µ stopí•˜ì—¬ í™•ì¸í•¨
        - conditional breakpoint : stop if a var is equal to a specific value
        - watchpoint : stop when a var is set to a specific value
        - single-stepping
        - execute one statement at a time (ë‹¨, 'ë‹¤ìŒ stop (statement)'ë¥¼ ë¬´ì—‡ìœ¼ë¡œ ì¡ëŠ”ì§€ ê¸°ì¤€ì´ í•„ìš”)
        - step into : next statement is first inside function call (ë‹¤ìŒ stopì€ í˜¸ì¶œëœ í•¨ìˆ˜ì˜ ì²«ë²ˆì§¸ statementì„)
        - step over : execute function without stopping (function ì „ì²´ëŠ” ë¬´ì‹œí•˜ê³ , function ë°”ë¡œ ë’¤ì˜ statementê°€ ë‹¤ìŒ stopì„)
        - step out : finish executing current function and stop on exit (í˜„ì¬ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³ , exit ë¶€ë¶„ (return ë¶€ë¶„)ì´ ë‹¤ìŒ stopì„)
        - Displaying Values
        - show value consistent with declared type of variable
- Programming for Correctness
- ì• ì´ˆì— í”„ë¡œê·¸ë˜ë°í•  ë•Œ ì •í™•íˆ í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.
- Accurate Specificatiton, Modular Design (í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë“¤ë¡œ ìª¼ê°  Moduleì„ ë§Œë“¤ê³ , moduleë“¤ì„ componentialí•˜ê²Œ ì¡°í•©í•˜ì—¬ í”„ë¡œê·¸ë¨ì„ êµ¬ì„±) Defensive Programming (commentë¥¼ í†µí•œ documentation, consistent coding style, avoid global var)

# 14. Pointers, Array

- Pointer
    - ë©”ëª¨ë¦¬ì— ìˆëŠ” ë³€ìˆ˜ì˜ ì£¼ì†Œë¥¼ ë‹´ê³  ìˆëŠ” typeì´ë‹¤.
    - allows us to indirectly access variables with its address (we can talk about its address rather than its value)
    useful for returning multiple values from a function
    - `int *p;` : p is a pointer to an int
    *p : returns the value pointed to by p (dereferencing operator) 
    &n : returns the address of variable n (& must applied to a memory object, such as variable. &3 or $(a+b) is not allowed)
    **p : pê°€ ê°€ë¥´í‚¤ê³  ìˆëŠ” ê²ƒì´ ë‹¤ì‹œ ì£¼ì†Œê°€ ë˜ì–´ì„œ, ê·¸ê²ƒì´ ê°€ë¥´í‚¤ëŠ” ê°’ì„ ë°˜í™˜í•¨

        ```c
        int i = 10;
        int *ptr;  // int typeì˜ ì£¼ì†Œë¥¼ ë‹´ëŠ” í¬ì¸í„° ë³€ìˆ˜ ptrì„ ì„ ì–¸

        ptr = &i  // i ì£¼ì†Œë¥¼ ptrì— í• ë‹¹

        *ptr = *ptr + 5;  // í¬ì¸í„° ptrì´ ê°€ë¥´í‚¤ëŠ” ê°’, ì¦‰ iì˜ ê°’ì¸ 10ì— 5ë¥¼ ë”í•œ 15ë¥¼ í• ë‹¹
                          // ì¦‰, ê°œë…ì ìœ¼ë¡œ reference(ì£¼ì†Œë¥¼ ë‹´ê³  ìˆëŠ” í¬ì¸í„° ptr) ê·¸ë¦¬ê³  dereference(*)ê°€ ìƒì‡„ëœë‹¤.
        ```

- Pointerê°€ í•„ìš”í•œ ì´ìœ  - swap (YT 7min, ì°¸ê³ -CS50 Memory 1hr 10min)
    - Pointer ë¯¸ì‚¬ìš©

        ```c
        // The function is supposed to swap the values of its arguments
        void swap(int firstVar, int secondVar)  // argument
        {
        	int temp = firstVar;
        	firstVar = secondVar;
          secondVar = tempVar;
        }

        int main(void)
        {
        int valueA = 3;
        int valueB = 4;
        swap(valueA, valueB)  // í•¨ìˆ˜ í˜¸ì¶œ - í•˜ì§€ë§Œ ì‹¤ì œë¡œ valueA/Bê°€ swap ë˜ì§€ ì•ŠìŒ
        }
        ```

        - Swap í•¨ìˆ˜ í˜¸ì¶œ ì‹œ Stack

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png)

            - í•¨ìˆ˜ ì‹¤í–‰ ì´ì „
                - Caller (main í•¨ìˆ˜)ì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueB (argument ë³µì‚¬ê°’ 3,4)ê°€ mainì˜ AR ìƒë‹¨ì— allocate ëœë‹¤.
                - Callerì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueBì˜ ë³µì‚¬ê°’ 3,4ê°€ Callee (swap í•¨ìˆ˜)ì˜ argument (ë¡œì»¬ë³€ìˆ˜X) firstVar, secondVarë¡œ ì „ë‹¬ëœë‹¤.
                - Calleeì˜ argument firstVar, secondVarê°€ swapì˜ AR í•˜ë‹¨ì— allocate ëœë‹¤. (ì—„ë°€íˆ í˜¸ì¶œ ì´í›„ì— allocate ë¨)
                ë˜í•œ ë¡œì»¬ë³€ìˆ˜ tempê°€ swapì˜ AR ìƒë‹¨ì— allocate ëœë‹¤.
                *AR (Activation Record)
            - í•¨ìˆ˜ ì‹¤í–‰ ì´í›„
                - í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´ swapì˜ argument firstVar, secondVarì˜ ê°’ì´ swap ëœë‹¤.
                ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´ swap í•¨ìˆ˜ê°€ return ë˜ê³  ARì´ pop ëœë‹¤. (return typeì€ voidì„)
                - ì˜ë„í–ˆë˜ mainì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueBì€ swapë˜ì§€ ì•ŠëŠ”ë‹¤.
                - ê²°ë¡ ì ìœ¼ë¡œ Swap needs address of variables outside its own AR
            - ì°¸ê³ -CS50
            - ì•„ë«ì¤„ì´ main í•¨ìˆ˜, ìœ—ì¤„ì´ swap í•¨ìˆ˜ì˜ stack frameì´ë‹¤.

                ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png)

    - Pointer ì‚¬ìš©
    - Passing a pointer into a function allows the function to read/change memory outside its activation record.

        ```c
        void swap(int *firstVar, int *secondVar) // Pointers as argument - Caller passes addresses of vars that it wants the callee to change.
        {
        	int temp = *firstVar; // í¬ì¸í„° ë³€ìˆ˜ firstVarì´ ê°€ë¥´í‚¤ê³  ìˆëŠ” ê°’ì„ ë¡œì»¬ë³€ìˆ˜ tempì— í• ë‹¹
        	*firstVar = *secondVar;
          *secondVar = tempVar; 
        }

        int main(void)
        {
        int valueA = 3;
        int valueB = 4;
        swap(&valueA, &valueB)  // í•¨ìˆ˜ í˜¸ì¶œ - valueA/Bì˜ ì£¼ì†Œ (ë³µì‚¬ê°’ì´ ì•„ë‹ˆë¼)ê°€ ì „ë‹¬ë˜ë¯€ë¡œ swap ë¨
        }
        ```

        - Swap í•¨ìˆ˜ í˜¸ì¶œ ì‹œ Stack

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2021.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2021.png)

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2022.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2022.png)

            - Caller (main í•¨ìˆ˜)ì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueBì˜ ì£¼ì†Œ (ë³µì‚¬ê°’ 3,4ê°€ ì•„ë‹ˆë¼)ê°€ Callee (swap í•¨ìˆ˜)ì˜ argument firstVar, secondVarë¡œ ì „ë‹¬ëœë‹¤. (argument typeì´ pointer)
            - (Pointer ë¯¸ì‚¬ìš©ê³¼ ë™ì¼)
            Calleeì˜ argument firstVar, secondVarê°€ swapì˜ AR í•˜ë‹¨ì— allocate ëœë‹¤. (ì—„ë°€íˆ í˜¸ì¶œ ì´í›„ì— allocate ë¨)
            ë˜í•œ ë¡œì»¬ë³€ìˆ˜ tempê°€ swapì˜ AR ìƒë‹¨ì— allocate ëœë‹¤.

            ë‹¨, argument firstVar, secondVarì— ì£¼ì†Œê°€ í• ë‹¹ë˜ì—ˆìœ¼ë¯€ë¡œ ê²°ë¡ ì ìœ¼ë¡œ valueA/Bì˜ ê°’ì´ swap ëœë‹¤.
- Null Pointer
    - í¬ì¸í„°ë¥¼ ì„ ì–¸í–ˆì§€ë§Œ, ì–´ë–¤ ê²ƒì„ ê°€ë¥´í‚¬ì§€ ì•„ì§ í• ë‹¹í•´ì£¼ì§€ ì•Šì€ ìƒíƒœì´ë‹¤.
    (ì¢…ì¢… NULL = 0 ì¸ë°, ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë¨/í”Œë«í¼ì—ì„œ Address 0ì€ legal addressê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤.)

        ```c
        int *p;
        p = NULL;  // p is a null pointer
        ```

- Array
    - a mechanism to group multiple elements of a homogeneous type (*heterogeneous type-Structure êµ¬ì¡°ì²´ì—ì„œ ê°€ëŠ¥)
    - its element allocated sequentially in memory
    - ì„ ì–¸ / Array Reference
    `type variableName[num_elements];` / `variableName[index];`
    ex. int grid[10] : declaration of an Int array with 10 elements. referenced by: grid[0] ... grid[9]
    - grid[10]ë¥¼ ì‹¤ìˆ˜ë¡œ ë„£ì–´ë„ compile-time ë° run-timeì—ì„œ limit checkingì´ ë˜ì§€ ì•ŠëŠ”ë‹¤. (ì»´íŒŒì¼ëŸ¬ê°€ í™•ì¸í•˜ë©´ ì‹¤í–‰ì†ë„ê°€ ë„ˆë¬´ ëŠë ¤ì§€ë¯€ë¡œ)
    - Arrayê°€ ë¡œì»¬ë³€ìˆ˜ì— í• ë‹¹ë˜ë©´, array elements are allocated as part of the AR.
    - First element grid[0] is at the lowest address of allocated space. (ê·¸ë¦¼ìƒìœ¼ë¡œëŠ” ë§¨ ìœ„ì—)
    - If grid is the first variable allocated, then R5 (frame pointer, frame base, ìµœìƒìœ„ì£¼ì†Œ) will point to grid[9].

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2023.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2023.png)

    - Passing array as arguments
        - C passes arrays by reference. arrayë¥¼ argumentë¡œ ì „ë‹¬í•  ë•ŒëŠ” arrayì˜ ì£¼ì†Œë¥¼ ì „ë‹¬í•œë‹¤.
        - arrayì˜ ì£¼ì†Œ(=arrayì˜ ì²«ë²ˆì§¸ elementì˜ ì£¼ì†Œ) ëŠ” í•¨ìˆ˜ì˜ activation recordì— ì íŒë‹¤.

            ```c
            // #define MAX_NUMS = 10 (ìƒìˆ˜ë¡œ ì„ ì–¸í•´ì•¼ í•¨)

            main() {
            		int numbers[MAX_NUMS]; // array ì„ ì–¸
            	  // ...
            	  mean = Average(numbers); // arrayë¥¼ argumentë¡œ ì „ë‹¬
            }

            int Average(int inputValues[MAX_NUMS]) { // array elementì˜ averageë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
            		for (index = 0; index < MAX_NUMS; index++)
            				sum = sum + indexValues[index];
            		return (sum / MAX_NUMS);
            }
            ```

    - String : an array of characters (ì—„ë°€íˆëŠ” a pointer of charaters)
        - `char outputString[16];` 
        - String arrayì˜ ë§ˆì§€ë§‰ elementëŠ” í•­ìƒ terminating zero (\0)ì´ë‹¤. ë”°ë¼ì„œ 15ê°œ characterë§Œ í• ë‹¹ ê°€ëŠ¥í•˜ë‹¤.
- Array & Pointer
    - An array name is essentially a pointer to the first element in the array

        ```c
        char word[10]; // array
        char *cptr;    // pointer

        cptr = word;  // points to word[0]
        // cptr = &word[0]; // ìœ„ì™€ ë™ì¼
        ```

# 15. Recursion

- í•¨ìˆ˜ ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„ ê°€ëŠ¥í•˜ë‹¤. 
í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ë©´, ê·¸ì— í•„ìš”í•œ ë©”ëª¨ë¦¬ ì˜ì—­ì´ stackì— dynamicí•˜ê²Œ allocateëœë‹¤. í•´ë‹¹ í•¨ìˆ˜ì˜ ARì´ stackì— pushëœë‹¤.
í•´ë‹¹ í•¨ìˆ˜ê°€ ìì‹ ì„ í˜¸ì¶œí•œë‹¤ê³  í•´ë„ ë™ì¼í•œ ë°©ì‹ìœ¼ë¡œ í•¨ìˆ˜ ìì‹ ì˜ ARì´ ìƒˆë¡­ê²Œ stackì— pushëœë‹¤. (ì—¬ëŸ¬ ë²ˆ ë‹¤ì‹œ í˜¸ì¶œë¼ë„ ìƒˆë¡œìš´ ARì´ ìƒì„±ë˜ë¯€ë¡œ ìì‹ ì´ ì•„ë‹Œ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ê²ƒì²˜ëŸ¼ ì·¨ê¸‰í•œë‹¤.)
- Recursive Function
    - is one that solves its task by calling itself on smaller pieces of data.
    - similar to recurrence relation in math.
    - high-level ex. Binary search (ì „í™”ë²ˆí˜¸ë¶€ ì°¾ê¸°, í•˜ë…¸ì´ íƒ‘ ìŒ“ê¸°)
    - ë°˜ë³µë¬¸ë³´ë‹¤ ì½”ë“œë¥¼ conceptually ë‹¨ìˆœí•˜ê²Œ ì‘ì„± ê°€ëŠ¥í•˜ì§€ë§Œ, ì‹¤í–‰ ì‹œ ë©”ëª¨ë¦¬ê°€ ë¹„íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤. (ì´ë¯¸ ê°’ì„ ì•Œê³  ìˆëŠ” base ë‹¨ê³„ (ex. n== 1)ê°€ ë°˜ë³µ ì‹¤í–‰ë˜ë¯€ë¡œ)

        ```c
        int RunningSum(int n) {
        		if (n == 1)
        				return 1;
        		else
        				return n + RunningSum(n-1);
        }
        ```

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2024.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2024.png)

    - ex. Fibonacci í•¨ìˆ˜

        ```c
        int Fibonacci(int n)
        {
        		int sum;

        		if ((n == 0) || (n == 1))
        				return 1;

        		else {
        				sum = Fibonacci(n-1) + Fibonacci(n-2)
        				reuturn sum;
        		}
        }
        ```

        - AR - Fibonacci í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ ARì´ stackì— pushëœë‹¤.

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2025.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2025.png)

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2026.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2026.png)

            1. (ê·¸ë¦¼ ìˆœì„œëŒ€ë¡œ) mainì´ Fibonacci(3)ì„ í˜¸ì¶œí•œë‹¤. // sum = Fibonacci(2) + Fibonacci(1)
            2. Fibonacci(3)ì€ Fibonacci(2)ì„ í˜¸ì¶œí•œë‹¤. 
            3. Fibonacci(2)ì€ Fibonacci(1)ì„ í˜¸ì¶œí•œë‹¤. Fibonacci(1)ì€ 1ì„ returní•˜ê³  popëœë‹¤.
            4. Fibonacci(2)ì€ ë‚¨ì€ Fibonacci(0)ì„ í˜¸ì¶œí•œë‹¤. Fibonacci(0)ì€ 1ì„ returní•˜ê³  popëœë‹¤.
            5. Fibonacci(2)ì€ í˜¸ì¶œí–ˆë˜ Fibonacci(1), Fibonacci(0)ì˜ returnê°’(1+1)ì„ ëª¨ë‘ ì–»ì—ˆìœ¼ë¯€ë¡œ Fibonacci(2)ëŠ” returní•˜ê³  popëœë‹¤.
            Fibonacci(3)ì€ ë‚¨ì€ Fibonacci(1)ì„ í˜¸ì¶œí•œë‹¤. // Fibonacci(3) = 2 + Fibonacci(1)ì¸ ìƒíƒœ
            6. Fibonacci(1)ì€ 1ì„ returní•˜ê³  popëœë‹¤. 
            Fibonacci(3)ì€ í˜¸ì¶œí–ˆë˜ Fibonacci(2), Fibonacci(1)ì˜ returnê°’ì„ ëª¨ë‘ ì–»ì—ˆìœ¼ë¯€ë¡œ Fibonacci(3)ëŠ” returní•˜ê³  popëœë‹¤.
            - ì¦‰, Fibonacci(3)ì˜ traceëŠ”

                ```c
                Fibonacci(3)
                	Fibonacci(2)
                		Fibonacci(1)
                		Fibonacci(0)
                	Fibonacci(1)
                ```

# 16. I/O in C

- Standard C Library
    - I/O commands are not included as part of the C language. Instead, they are part of the Standard C Library.
    - Cì–¸ì–´ì˜ ì¼ë¶€ê°€ ì•„ë‹ˆë¯€ë¡œ ì»´íŒŒì¼ëŸ¬ëŠ” function interface ê´€ë ¨ ì •ë³´ê°€ í•„ìš”í•˜ë‹¤. ì´ë¥¼ í•¨ìˆ˜, ë³€ìˆ˜, ìƒìˆ˜ ë“±ì´ ì„ ì–¸ ë‚´ìš©ì´ í¬í•¨ëœ Standard header fileí˜•íƒœë¡œ ì œê³µí•œë‹¤.
    - A collection of functions and macros that must be implemented by any ANSI standard implementation.
    - Implementation depends on processor, OS... but interface is standard. (CPU, OS ì¢…ë¥˜ì— ë”°ë¼ implementationì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆì§€ë§Œ, interfaceëŠ” ANSI standardì—ì„œ ì •ì˜í•œ ê²ƒì„ ë”°ë¥¸ë‹¤.)
    - Basic Function : declared in the <stdio.h> header file. (printf, scanf, fopen...)
- I/O Streams 
- ëª¨ë“  ë¬¸ìëŠ” streamsì„ ê¸°ë°˜ìœ¼ë¡œ ì‹¤í–‰ëœë‹¤. 
- A stream is a sequence of ASCII characters. ì˜ˆë¥¼ ë“¤ì–´ í‚¤ë³´ë“œì— ì…ë ¥ë˜ëŠ” ê²ƒ, ëª¨ë‹ˆí„°ì— ì¶œë ¥ë˜ëŠ” ê²ƒ ë“± ë¬¸ì
- characters are processed in the order in which they were added to the steam. streamì— ì¶”ê°€ë˜ëŠ” ìˆœì„œì— ë”°ë¼ ì²˜ë¦¬ëœë‹¤. (í‚¤ë³´ë“œ ì…ë ¥í•œ ìˆœì„œëŒ€ë¡œ ë¬¸ìë¥¼ ì²˜ë¦¬í•˜ëŠ” ë“±)
- Buffered I/O
- In many systems, characters are buffered in memory during an I/O operation. (ê°œë…ì ìœ¼ë¡œ ê° I/O Streamì€ ìì‹ ì˜ bufferë¥¼ ê°€ì§)
- Keyboard input system : Characters are added to the buffer only when the newline character (=Enter key) is pressed.
   bufferê°€ ìˆì–´ì„œ ì‚¬ìš©ìê°€ í‚¤ë³´ë“œì— ë¬¸ìë¥¼ ì…ë ¥í•˜ê³  Enter keyì„ ëˆŒëŸ¬ì„œ confirmingí•˜ê¸° ì „ê¹Œì§€ ë¬¸ìë¥¼ ìˆ˜ì • ê°€ëŠ¥í•˜ë‹¤.
- Formatted I/O
- printf("Result is %d\n", var1);ê³¼ ê°™ì´ Format String ("...") contains text to be read/written, and formatting characters (%d) that describe how data is to be read/written.
- File I/O 
- a file is a sequence of ASCII characters. Each file is associated with a stream. 
- type of a stream is a "file pointer", declared as: `FILE *infile;` (FILE type is defined in <stdio.h>)

# 17. Data Structure

- Data Structure
    - is a particular organization of data in memory. (ì—°ê´€ì„±ì´ ìˆëŠ” ë°ì´í„°ë¥¼ ê·¸ë£¹í•‘í•˜ì—¬ ì²˜ë¦¬í•œë‹¤.)
    - Key Mechanisms
    - Array : group multiple elements of a homogeneous type
    - Structure : group multiple elements of a heterogeneous type
- Structure
    - Defining

        ```c
        struct flightType {
        		char flightNum[7];
        		int altitude;
        		int longitude;
        		int latitude;
        		int heading;
        		double airSpeed;
        };  // structì„ defineí•˜ë©´ ì»´íŒŒì¼ëŸ¬ëŠ” ì–´ë–¤ componentë¥¼ ê°€ì§€ëŠ”ì§€, ë©”ëª¨ë¦¬ ìš”êµ¬ ì •ë„ê°€ ì–¼ë§ˆì¸ì§€ íŒŒì•…í•œë‹¤. ì´ë•Œ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹í•˜ì§€ ì•ŠëŠ”ë‹¤. (ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ì§€ëŠ” ì•Šì€ ê²ƒìœ¼ë¡œ ì¸ì‹í•œë‹¤.) 

        struct flightType {
        		char flightNum[7];
        		int altitude;
        		int longitude;
        		int latitude;
        		int heading;
        		double airSpeed;
        } declareRightNow; // ì°¸ê³  - defineí•˜ëŠ” ë™ì‹œì— declareí•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•˜ë‹¤.
        ```

    - Declaring
    - ë©”ëª¨ë¦¬ê°€ í• ë‹¹ë˜ëŠ” ì‹œì ì€ struct typeì˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ë•Œì´ë‹¤. declared as: `struct flightType plane;`
    - ë³€ìˆ˜ë¥¼ í†µí•´ structì˜ memberì— ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹¤. `plane.airSpeed = 800.0;`
    - typedef (typeAliasì™€ ìœ ì‚¬í•¨)
    - ì´ë¯¸ ì •ì˜ëœ typeì— ìƒˆë¡œìš´ ì´ë¦„ì„ ì§€ì •í•œë‹¤. `typedef int Color;` (ì´ë¯¸ ì •ì˜ëœ int typeì„ Colorë¼ê³  ë¶€ë¥´ê² ë‹¤ëŠ” ì˜ë¯¸),
       `typedef struct flightType Flight;` (ì´ë¯¸ ì •ì˜ëœ flightType êµ¬ì¡°ì²´ë¥¼ Flightë¼ê³  ë¶€ë¥´ê² ë‹¤ëŠ” ì˜ë¯¸)
       â‡’ `Color pixels[500]` (Int type arrayë¥¼ ìƒì„±), `Flight planeA;` (flightType êµ¬ì¡°ì²´ typeì˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸)
    - Array of Struct
    - declared as: `Flight airplanes[100];` (ì›ë˜ëŠ” `struct flightType airplanes[100];`) // Flight typeì˜ elementë¡œ êµ¬ì„±ëœ Array airplanes
    - *Each array element is a struct (6 members in this case)
    - To access a member of a particular element: `airplanes[34].altitude = 10000;`
    - Pointer to Struct
    - declared as: `Flight *planePtr;` , pointerì— ì£¼ì†Œë¥¼ í• ë‹¹: `planePtr =&planes[34];`
    - To access a member of the struct address by pointer: `(*planePtr).altitude = 10000;` or `planePtrâ†’altitude = 10000;`
    - Passing Struct as Arguments
    - arrayì™€ ë‹¬ë¦¬ structëŠ” í•­ìƒ ê°’ìœ¼ë¡œ ì „ë‹¬ëœë‹¤. (ì¦‰, struct memberëŠ” ê·¸ ë³µì‚¬ê°’ì´ í•¨ìˆ˜ì˜ ARì— ì „ë‹¬ëœë‹¤. ë”°ë¼ì„œ changes inside the function are not reflected in the calling routine's copy.)
    - í•„ìš” ì‹œ pointerë¥¼ ì‚¬ìš©í•œë‹¤.

        ```c
        int Collide(Flight *planeA, Flight *planeB) {
        		if (planeA->altitude == planeB->altitude) {
        				// ...
        		}
        }
        ```

    - Dynamic Allocation
    - ì§€ë‚œ ìˆ˜ì—…ì²˜ëŸ¼ í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ARì„ stackì— pushí•˜ëŠ” ë°©ì‹ì´ ì•„ë‹ˆë¼,
       ì„ì˜ì˜ ìˆœê°„ì— ì›í•˜ëŠ” ë§Œí¼ì˜ ë©”ëª¨ë¦¬ë¥¼ Operating Systemìœ¼ë¡œë¶€í„° allocate ë°›ëŠ” ë°©ì‹ì´ë‹¤.
    - ex. ê³µì¤‘ì˜ ë¹„í–‰ê¸° ê´€ë ¨ DBë¥¼ êµ¬ì¶•í•˜ëŠ” í”„ë¡œì íŠ¸ê°€ ìˆë‹¤ë©´, ê·¸ê²ƒì„ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ìë£Œêµ¬ì¡°ë¥¼ íƒí•´ì•¼ í•œë‹¤.
       - Array : Max number (í˜„ì¬ ê³µì¤‘ì˜ ë¹„í–‰ê¸°ê°€ ëª‡ ëŒ€ê°€ ë ì§€)ë¥¼ ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ë¶ˆê°€, ì•ˆë‹¤ê³  í•˜ë”ë¼ë„ ëŒ€ë¶€ë¶„ í›¨ì”¬ ì ì€ ìˆ˜ì˜ ë¹„í–‰ê¸°ê°€ ìš´í–‰ë  ê²ƒì´ë¯€ë¡œ ë©”ëª¨ë¦¬ê°€ ë‚­ë¹„ëœë‹¤.
       - ì´ë•Œ, í˜„ì¬ ìš´í–‰ì¤‘ì¸ ë¹„í–‰ê¸°ì— í•´ë‹¹í•˜ëŠ” ë§Œí¼ì˜ ë©”ëª¨ë¦¬ë¥¼ allocate ë°›ëŠ” Dynamic Allocationì„ ì‚¬ìš©í•œë‹¤.
        - Memory Map

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2027.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2027.png)

            - Memory ìƒë‹¨ë¶€í„° ì°¨ë¡€ë¡œ Instruction, Global, Heap, Stackê°€ locate í•˜ëŠ”ë°, Dynamically allocated memoryëŠ” Heap ì˜ì—­ì— ë“¤ì–´ìˆë‹¤.
            - malloc
                - Standard C Libraryì˜ malloc í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ memoryë¥¼ allocateí•œë‹¤. `void *malloc(int numBytes);`
                - it returns a generic pointer (void *) to a contiguous region of memory of the requested size (in bytes). 
                - Operating systemì´ ë©”ëª¨ë¦¬ë¥¼ allocate í•´ì£¼ê³ , í•´ë‹¹ ë©”ëª¨ë¦¬ ì˜ì—­ì˜ ì‹œì‘ì£¼ì†Œë¥¼ returní•œë‹¤.
                - The bytes are allocated from a region in memory called the heap.
            - free
                - í• ë‹¹ë°›ì€ dataë¥¼ freeí•´ì£¼ì§€ ì•Šìœ¼ë©´ heap memoryê°€ ë¶€ì¡±í•´ì„œ í”„ë¡œê·¸ë¨ ì§„í–‰ì´ ë¶ˆê°€í•˜ë‹¤.
                - free í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ mallocìœ¼ë¡œ í• ë‹¹ë°›ì€ ë©”ëª¨ë¦¬ë¥¼ deallocate í•´ì¤€ë‹¤. `void free(void*);`

                ```c
                // sizeof operatorë¥¼ í†µí•´ ì»´íŒŒì¼ëŸ¬ì—ê²Œ í•´ë‹¹ Typeì„ êµ¬í˜„í•˜ëŠ”ë° í•„ìš”í•œ ë©”ëª¨ë¦¬ í¬ê¸° (in bytes)ë¥¼ ê³„ì‚°í•˜ë„ë¡ í•œë‹¤.
                planes = malloc(n * sizeof(Flight)); // mallocì€ í• ë‹¹í•œ heap ì˜ì—­ì˜ ì‹œì‘ì£¼ì†Œë¥¼ return í•œë‹¤.

                // ë§Œì•½ planes ë³€ìˆ˜ê°€ pointerì´ë©´ type castingì´ í•„ìš”í•˜ë‹¤.
                planes = (Flight *) malloc(n * sizeof(Flight));
                ```

                ```c
                // struct define ë¶€í„°
                struct flightType {
                		char flightNum[7];
                		int altitude;
                		int longitude;
                		int latitude;
                		int heading;
                		double airSpeed;
                };

                typedef struct flightType Flight; 

                int airbornePlanes; // í˜„ì¬ ê³µì¤‘ì˜ ë¹„í–‰ê¸° ëŒ€ìˆ˜
                Flight *planes; // Flight typeì„ ê°€ë¥´í‚¤ëŠ” pointer ë³€ìˆ˜ planesë¥¼ ì„ ì–¸

                printf("How many planes are in the air?");
                scanf("%d", %airbornePlane);

                planes = (Flight *) malloc(sizeof(Flight) * airbornePlanes);

                if (planes == NULL) { // if allocation fails, malloc returns NULL
                		printf("Error in allocating the data array.\n");
                    // ...
                }

                planes[0].altitude = ... // Can use array notation or pointer notation
                ```

- Linked List (YT 27min)
    - struct, pointer ê°œë…ì„ ì¡°í•©í•˜ì—¬ ë§Œë“  data structureì´ë‹¤.
    - is an ordered collection of nodes, each of which contains some data, connected using pointers.
    - Each node points to the next node in the list. (head: ì²«ë²ˆì§¸ node, tail: ë§ˆì§€ë§‰ node)
    - ì¥ì  : element ì¶”ê°€/ì‚­ì œê°€ ì‰½ë‹¤. dynamically size ë³€ê²½ì´ ê°€ëŠ¥í•˜ë‹¤. (ë°˜ë©´ ArrayëŠ” ë©”ëª¨ë¦¬ì— ì—°ì†ìœ¼ë¡œ ìœ„ì¹˜í•´ì„œ ì „ì²´ element ìœ„ì¹˜ë¥¼ ë‹¤ì‹œ allocate í•´ì•¼ í•¨)
    ë‹¨ì  : element ì ‘ê·¼ì´ ì–´ë µë‹¤. headì—ì„œë¶€í„° sequentially access í•´ì•¼ í•œë‹¤. (ë°˜ë©´ ArrayëŠ” .indexë¥¼ í†µí•´ ì„ì˜ ì ‘ê·¼ì´ ê°€ëŠ¥í•¨)
    â‡’ ì´ë¥¼ ë³´ì™„í•œ ë‹¤ë¥¸ data structure : Tree, Graph,Hash Table ë“±
    - ì˜ˆì‹œ - inventory DB for a used car lot. support the following action:
    - search the DB for a particular vehicle
    - add a new car to the DB
    - delete a car from the DB
    *DB must remain sorted by vehicle ID. ID ì‘ìŒ-í¼ ìˆœì„œë¡œ ì •ë ¬ëœ ìƒíƒœë¥¼ ê°€ì •. í˜„ì¬ ì£¼ì°¨ëœ ì°¨ëŸ‰ì˜ ëŒ€ìˆ˜ë¥¼ ì•Œìˆ˜ ì—†ìœ¼ë¯€ë¡œ linked list presentationì„ ì±„íƒí•¨

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2028.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2028.png)

        *Nodeê°€ í•˜ë‚˜ë„ ì—†ëŠ” ì´ˆê¸°ìƒíƒœê°€ í•„ìš”í•˜ë¯€ë¡œ carBaseë¥¼ ë‘ì–´ì•¼ í•¨

        ```c
        // Car data structure
        typedef struct carType Car;
        struct carType {
        		int vehicleID;
        		char maker[20];
        		char model[20];
        		int year;
        		int mileAge;
        		double cost;

        		Car *next; // next nodeë¥¼ ê°€ë¥´í‚¤ëŠ” pointer ì„ ì–¸
        }

        // Scanning the List - search, adding/deleting requires finding a particular node in the list. Scan the list until we find a node whose ID is >= the one we're looking for.
        Car *ScanList(Car *head, int searchID) // ScanList function
        {
        		Car *previous, *current;
        		previous = head;
        		current = head->next; // next nodeë¥¼ ê°€ë¥´í‚¤ë¯€ë¡œ next node(node1)ê°€ í• ë‹¹ë¨

        		// Traverse until ID >= searchID 
        		while ((current != NULL) && (current->vehicleID < searchID)) { 
        				previous = current; 
        				current = current->next;
        		}
        		
        		return previous; // previousë¥¼ returní•œë‹¤. nodeë¥¼ addí•  ë•Œ, ì´ ë’¤ì— ì—°ê²°ì‹œì¼œì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
        }

        // Excerpts (ë°œì·Œ) from code to Add a Node
        newNode = (Car *) malloc(sizeof(Car));

        // initialize node with new car info
        prevNode = ScanList(head, newNode->vehicleID);
        nextNode = prevNode->next;

        if ((nextNode == NULL) || (nextNode->vehicleID != newNode->vehicleID)) {
        		prevNode->next = newNode;
        		newNode->next = nextNode;
        } else {
        		printf("Car already exists in database.");
        		free(newNode);
        }

        // Excerpts (ë°œì·Œ) from code to Delete a Node
        printf("Enter vehicle ID of car to delete:\n");
        scanf("%d", vehicleID);

        prevNode = ScanList(head, vehicleID);
        delNode = prevNode->next;

        if ((delNode != NULL) && (delNode->vehicleID == vehicleID)) {
        		prevNode->next = delNode->next;
        		free(delNode);
        } else {
        		printf("Vehicle not found in database.");
        }
        ```