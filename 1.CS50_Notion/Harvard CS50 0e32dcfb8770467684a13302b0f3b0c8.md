# Harvard CS50

Created: February 10, 2021 7:46 PM
Created By: hyoju son
Last Edited Time: July 14, 2021 3:43 PM
Type: CS

David J. Malan / Harvard 

CS50 2019

![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled.png)

![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%201.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%201.png)

- Contents

Assignment

[https://github.com/dgski/cs50-assignments](https://github.com/dgski/cs50-assignments)

# 1. Computational thinking

*CS란? input과 output을 통한 문제 해결

- 2진법

    place of ten : 10의 자리
    powers of ten : 10의 거듭제곱
    ten to the two is one hundred : 10의 2승 (100)

    input과 output을 **표현**하기 위해선 우선 모두가 동의할 **약속(표준)**이 필요합니다.

    따라서 컴퓨터 과학의 가장 첫 번째 개념은 어떻게 표현하는지에 대한 표현 방법입니다.

    2진법은 전기를 통해 연산하는, 즉 전기를 켜고 끄는 방식으로 작동하는 컴퓨터에게 적합한 방법입니다. 
    컴퓨터에는 많은 스위치(트렌지스터)가 있고 on/off 상태를 통해 0과 1을 표현합니다. 

    비트 
    bit (binary digit, 이진 숫자)

    2진법에서 하나의 자릿수를 표현하는 단위를 비트(bit)라고 합니다. 
    정보를 저장하고 연산을 수행하기 위해 컴퓨터는 비트(bit)라는 측정 단위를 씁니다. 0과 1, 두 가지 값만 저장할 수 있는 측정 단위입니다. 

    디지털 데이터를 여러 비트들로 나타냄으로써 두 가지 값만을 가지고도 많은 양의 정보를 저장할 수 있습니다. 또한 컴퓨터는 저장되어 있는 데이터를 수정하기 위해 비트에 수학적 연산을 수행할 수 있습니다. 

    컴퓨터 내부에서 물리적으로 표현될 때는, 켜고 끌 수 있는 스위치라고 생각할 수 있겠습니다. (켜기=1, 끄기=0) 

    바이트 / 비트열 
    byte = 8 bit

    하지만 비트 한 개는 많은 양의 데이터를 나타내기에 턱없이 부족합니다. 그렇기 때문에 여러 숫자 조합을 컴퓨터에 나타내기 위해 비트열을 사용합니다. 
    바이트(byte)는 8개의 비트가 모여 만들어진 것입니다. 하나의 바이트에 여덟 개의 비트가 있고, 비트 하나는 0과 1로 표현될 수 있기 때문에 2^8 = 256 개의 서로 다른 바이트가 존재할 수 있습니다.

- 정보의 표현
    - 문자의 표현
    - 문자를 숫자로 표현 할 수 있도록 정해진 약속(표준)
        - ASCII(아스키코드/American Standard Code for Information Interchange/미국정보교환표준부호)
            - 8bit 중 7bit를 사용 (남은 1bit는 통신에러 검출에 사용함). 그래서 2^7=128 즉, 128개 문자를 표현가능하다.
            - 가령 알파벳 A는 10진수 기준으로 65, 알파벳 B는 66로 되어있습니다. 그럼 A를 지난 강의에서 배운 2진법으로 표현해볼까요? 
            우선 10진법 기준으로 65이므로 2^6x1 + 2^5x0 + 2^4x0 + 2^3x0 + 2^2x0 + 2^1x0 + 2^0x1 (64+1)로 표현할 수 있습니다. 따라서 A를 2진법로 표현하면 1000001 입니다.
        - Unicode
            - 16bit를 사용하여 2^16 즉, 65536개 문자 표현 가능
            - 더 많은 비트를 사용하여 다양한 문자 표현을 지원하고 있습니다. ASCII로는 문자들을 표현하기에 충분하지 않았기 때문입니다. Unicode으로 😂(기쁨의 눈물) 같은 이모티콘 까지 표현 가능합니다. 이 이모티콘은 10진법으로 128,514입니다. 2진법으로는 11111011000000010 입니다.
            - 만약 여러분이 스마트폰으로 😂(기쁨의 눈물) 이모티콘을 친구의 스마트폰으로 보낸다면 11111011000000010 이라는 0과 1의 패턴을 보낸것입니다. 
            그럼 친구의 스마트폰의 안드로이드 혹은 iOS는 0과 1의 패턴을 받아 노란색 얼굴에 눈물을 흘리고 있는 사진으로 보여줍니다.
    - 이미지의 표현
        - 우리가 스크린을 통해 보는 그림을 확대하면 수많은 작은 점들 (**픽셀)**이 있습니다. 각 픽셀은 빨강, 초록, 파랑을 조합하여 특정한 색을 갖게 됩니다. 예를 들어 빨간색 72, 초록색 72, 파란색 33을 섞게 되면 노란색이 되는 것과 같은 방식입니다.
        - 이 숫자들을 표현하는 방식을 **RGB**(Red, Green, Blue)라고 합니다. 즉, 노란색의 커다란 이미지는 72 73 33 으로 정의되는 무수히 많은 픽셀들의 RGB코드(숫자)로 표현할 수 있습니다.
    - 영상 / 음악의 표현
        - 영상 또한 수많은 그림을 빠르게 연속적으로 이어 붙여놓은 것이기 때문에 숫자로 표현이 가능합니다.
        - 음악도 각 음표, 세기, 길이를 quantify하여 숫자로 표현할 수 있습니다.

    ⇒ 즉, 모두 0과 1 (이진법)에서 비롯된 것이다. 이진법을 십진법으로, 그것을 문자/이미지/영상/음악으로 만든다.

- 알고리즘

    들여쓰기 indent
    종속관계 dependency

    - 상식적인 논리적 사고과정을 컴퓨터가 이해할 수 있게 옮긴 것 뿐이다.
    - ex) Mike Smith를 전화번호부에서 찾기 위한 명령의 두 가지 알고리즘
    - 첫 번째 알고리즘은 한 장을 넘긴 다음 또 한 장 넘기는 규칙들의 순서적 나열
    - 두 번째 알고리즘은 반을 줄이고, 다음 또 반을 줄이는 규칙들의 순서적 나열
        - 의사코드
            - 컴퓨터가 수행할 작업을 프로그램 언어가 아니라 사람이 사용하는 언어로 알고리즘의 논리적 절차를 작성한 코드

                ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%202.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%202.png)

            - function, condition, loop, boolean 개념
    - Scratch : MIT에서 개발한 프로그래밍 언어로 블록을 활용하여 알고리즘을 구성할 수 있다.

# 2. C언어

- 기초
    - 대괄호 [] Square Brackets, brakets 
    중괄호 {} Curly Brackets, braces 
    소괄호 () parentheses
    - source code (C언어) → compiler → machine code (binary)
    - sandbox : 리눅스 운영체제 (요즘은 맥, 윈도우 운영체제에도 있음)로 돌아가는 클라우드 서버의 접근 권한을 가진 프로그램
    - clang을 통해 머신코드 (assembly output) 생성

        ```swift
        // sandbox - hello.c 파일 생성 
        #include <stdio.h> // stdio.h 파일을 읽겠다. (*stdio : standard input output, .h : header file)
                           // printf 함수의 proto type이 들어있어서 컴파일러에게 기능을 전달해준다.

        int main(void)  // 시작 기능
        {
            printf("hello, world\n");  // 출력 기능
        }

        // @프롬프트
        $ clang hello.c  // clang 프로그램 (컴파일 기능)을 통해서 hello.c 파일의 코드를 컴파일 한다. -> a.out 이라는 머신코드가 생성된다.
        $ ./a.out  // 컴퓨터가 현재 디렉토리에 있는 a.out 파일을 실행하도록 한다.

        =>
        hello, world
        $ 
        ```

    - String 
    - 구현 : 사용자의 이름을 입력으로 받고, 그리고 그 사람의 이름을 불러서 인사를 했습니다.

        ```swift
        #include <stdio.h>
        #include <cs50.h>  // get_string 함수 등이 정의되어 있는 파일

        int main(void)
        {
         	 string answer = get_string("What's your name?\n"); // string type의 입력값 (argument)을 변수 answer에 할당한다. 이제 컴퓨터의 메모리 어딘가에 사용자의 이름이 저장됐다.
        	 printf("hello, %s\n", answer);  // %s : placeholder (형식 지정자)
        }

        // answer이라는 변수에 들어있는 이름을 출력을 해야하기 때문에 %를 사용해 줍니다.
        // 이 때도 어떤 종류의 인자를 받는지 말해줘야 합니다. 이름이라는 문자열을 받기때문에 string에서의 s를 %뒤에 붙여서 인자를 받아줍니다.

        -
        $ clang -o string string.c -lcs50  // -o (output) / string (컴파일해서 생성된 기계언어 파일명을 string으로 지정) / string.c (input 파일명) / -lcs50 (cs50 파일과 link 하겠다)
        or
        $ make string // 이 소스코드 (string.c)를 컴파일해서 머신코드 파일 (string)을 만들어라

        $ ./string    // 실행
        What's your name? - 프롬프트에 출력됨
        kevin <- 내가 입력 (argument)
        hello, kevin - 출력
        ```

- condition & loop

    ```swift
    if (x < y) { 
    		printf("x is less than y\n");
    } else if (x > y) {
    		printf("x is not less than y\n");
    } else if (x == y) {
    		printf("x is equal to y\n");
    }
    ```

    ```swift
    int i = 0; 
    while (i < 50) { 
    		printf("hello, world\n");
    		i++; // i += 1; 동일한 표현
    }
    ```

    ```swift
    for (int i = 0; i < 50; i++) { // for 에는 3가지 parameter가 필요함 
    		printf("hello, world\n");
    }
    ```

- data type, 형식지정자, 연산자
    - data type & 형식지정자 (Format Specifier)
        - **%c** : char
        - **%f** : float, double
        - **%i** : int
        - **%li** : long (long int)
        - **%s** : string
    - 연산자
        - + : 더하기 -: 빼기
        - * : 곱하기 / : 나누기
        - % : 나머지
        - && : and
        - || : or
- 사용자 정의 함수, 중첩 루프
    - cough 3번 하는 기능

        ```swift
        #include <stdio.h>

        void cough(void);  // 멍청한 C언어는 위에서 아래로만 읽으므로 이 라인이 없으면 cough 함수를 실행할 수 없다. (proto type)

        int main(void)   // main 이므로 코드의 상단에 있을수록 좋다.
        {
            for (int i = 0; i < 3; i++)
            {
                cough();
            }
        }

        void cough(void)  // 왼쪽 void : type of output (return값이 없음), 오른쪽 void : type of input (parameter가 없음)
        {
            printf("cough\n");
        }
        ```

    - 원하는 횟수만큼 cough 하는 기능

        ```swift
        #include <stdio.h>

        void cough(int n);  

        int main(void)
        {
        		cough(3)  // main의 코드가 간단해서 가독성 있다.
        }

        void cough(int n)  // implementation detail
        {
        		for (int i = 0; i < n; i++) {
        				printf("cough\n");
        		}
        }    
        ```

    - 마리오 게임의 # 상자 만들기 기능 (입력된 n 만큼 가로, 세로로 #를 출력)

        ```swift
        #include <cs50.h>
        #include <stdio.h>

        int main(void)
        {
            int n;

            do
            {
                n = get_int("Size: ");
            }
            while (n < 1);  // 일단 한번 실행하고, false 될 때까지 반복 (사용자가 적절한 값 즉, 1 이상의 값을 입력할 때까지 계속 물어봄)

            for (int i = 0; i < n; i++)  // i 변수를 통해 n 만큼 반복해라
            {
                for (int j = 0; j < n; j++)  // j 변수를 통해 n 만큼 반복해라
                {
                    printf("#");
                }
                printf("\n");
            }
        }

        -
        n=3 <- 사용자가 입력하면
        ###
        ###
        ### - 출력

        // for 루프를 두 번 중첩해서 돌면서 “#”을 출력합니다. 
        // 첫 번째 루프에서는 변수 i를 기준으로 n번 반복하고, 그 안의 내부 루프에서는 변수 j를 기준으로 n번 반복합니다. 
        // 내부 루프에서는 “#”을 출력하고, 내부 루프가 끝날 때마다 줄바꿈을 수행합니다. 따라서 최종적으로는 가로가 n개, 세로가 n개인 “#”이 출력되게 됩니다.
        ```

        - [x]  중첩루프
        // 내부 루프에서는 “#”을 출력하고, 내부 루프가 끝날 때마다 줄바꿈을 수행합니다. 따라서 최종적으로는 가로가 n개, 세로가 n개인 “#”이 출력되게 됩니다.
            - i = 0 조건에 해당하는 모든 경우 (내부 루프 j = 0~n)를 완료한 이후에 i = 1로 넘어간다.

- 하드웨어의 한계 - 메모리
    - 컴퓨터는 RAM(랜덤 액세스 메모리)이라는 물리적 저장장치를 포함하고 있습니다. 
    우리가 작성한 프로그램은 구동 중에 RAM에 저장되는데요, RAM은 유한한 크기의 비트만 저장 가능하므로 부정확한 결과를 내기도 합니다.
        - 부동소수점 부정확성

            ```swift
            #include <cs50.h>
            #include <stdio.h>

            int main(void)
            {
                float x = get_float("x: ");    // 사용자에게 값을 입력받아서 변수 x에 float type으로 할당해라
                float y = get_float("y: ");    // 사용자에게 값을 입력받아서 변수 y에 float type으로 할당해라

               printf("x / y = %.50f\n", x / y);   // x/y 연산을 하고 결과값을 %f에 넣어주되 .50 즉, 소수점 50자리까지 출력해라
            }
            -
            x: 1
            y: 10
            x / y = 0.10000000149011611938476562500000000000000000000000

            // 정확한 결과는 0.1이 되어야 하지만, float 에서 저장 가능한 비트 수가 유한하기 때문에 다소 부정확한 결과를 내게 되는 것입니다.
            // float : 32비트, double : 64비트
            ```

        - 정수 overflow
        변수가 담을 수 있는 최대 허용 범위를 벗어난 값을 저장해 예상치 못한 결과가 나오는 현상

            ```swift
            #include <stdio.h>
            #include <unistd.h>

            int main(void)
            {
                for (int i = 1; ; i *= 2)  // i = 1에서 시작해서 / 조건 없이 (항상 true) / i = 2 * i 연산을 해준다
                {
                    printf("%i\n", i);  // i 를 출력
                    sleep(1);  // 1초 쉰다
                }
            }
            -
            1
            2
            4
            8
            ...
            1073741824
            overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
            -2147483648
            0
            0

            // int는 32비트를 저장 가능하고, 그 이상으로 커지면 overflow가 발생함 
            ```

            - 1999년 큰 이슈였던 Y2K 문제는 연도를 마지막 두 자리수로 저장했던 관습 때문에 새해에 ‘99’에서 ‘00’으로 정수 오버플로우가 발생하고, 새해가 2000년이 아닌 1900년으로 인식된다는 문제였습니다.
            그리고 세계는 수백만 달러를 투자해서 프로그래머들에게 더 많은 메모리를 활용해서 이를 해결하도록 하였습니다. 이는 통찰력 부족으로 발생한 아주 현실적이고 값비싼 문제였습니다.

# 3. Array

- compile 4단계 (전처리-컴파일-어셈블-링크)
    - make나 clang을 사용해서 프로그램을 실행할 때 아래 네 개의 단계를 거친다.
        - 전처리 (Pre-compile)

            # 으로 시작되는 C 소스코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려준다.
            예를 들어, `#include`는 전처리기에게 다른 파일의 내용을 포함시키라고 알려준다. <cs50.h>, <stdio.h>의 파일 중 아래 소스코드에 해당하는 내용을 불러와서 대체한다. 
            소스 코드에 #include 와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스코드 형태이다.

        - 컴파일 (Compile)

            컴파일러 프로그램은 C 코드 (High-level language)를 어셈블리 코드라는 저수준 프로그래밍 언어로 translate한다. 어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것을 수행할 수 있다. C 코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가깝게 만들어 준다. 

        - 어셈블 (Assemble)

            어셈블리 코드를 오브젝트 코드로 변환시키는 것입니다. 컴퓨터의 중앙처리장치가 프로그램을 어떻게 수행할지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업이다. 이 변환작업은 어셈블러 프로그램이 수행한다. 
            소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이 난다. 그렇지 않은 경우에는 링크 단계가 추가된다.

        - 링크 (Link)

            프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크라는 마지막 단계가 필요하다. 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다. 예를 들어, 컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 GetInt()나 GetString() 같은 함수를 어떻게 실행할 지 알 수 있게 된다. 
            이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.

- 디버깅 / 코드 디자인
    - 디버깅(debugging)은 코드에 있는 버그를 식별하고 고치는 과정입니다. 프로그래머는 디버거라고 불리는 프로그램을 사용하여 디버깅을 하게 됩니다.
        - 프로그램은 일반적으로 인간보다 훨씬 빠르게 연산을 수행합니다. 그래서 프로그램을 실행시켜보는 것만으로는 무엇이 잘못됐는지 찾아내기 어렵습니다. 
        디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 됩니다. 프로그래머는 멈춰진 그 지점 (Break point)에서 무슨 일이 일어나는지 볼 수 있습니다. 
        또한 프로그래머가 프로그램을 한번에 한 행씩 실행할 수 있게 해줍니다. 이로써 프로그래머는 프로그램이 내리는 모든 결정들을 단계별로 따라갈 수 있게 됩니다.

            여러 사람들이 각자 한 부분을 맡아 코드를 작성할 때 각자가 수정한 코드가 전체 프로그램의 정확성을 해치지 않는지 쉽게 확인 가능합니다.

        - CS50 IDE - debug50 : 소스 코드에 직접 브레이크 포인트를 지정하고 소스파일을 컴파일한 후에 “debug50 파일명” 으로 실행하면, 오른쪽 패널을 통해 변수의 값을 확인하거나 브레이크 포인트부터 한 줄씩 코드를 실행해 볼 수 있습니다.
    - 코드의 디자인
        - check50 : 목표한 기능을 잘 구현했는지 자동 검사 프로그램. 이 프로그램은 cs50 강의를 위해서만 작성되었지만, 실무에서 이와 같은 자동 검사 프로그램 (테스트)은 많은 도움이 됩니다.
        - style50 : 코드가 가독성 있게, 심미적으로 잘 작성되었는지 검사할 수 있습니다.

- Array의 효용 - 메모리에 연속 저장

    우리가 특정 자료형의 변수를 선언하면 이는 메모리상 어딘가에 특정 크기만큼의 자리를 차지하게 됩니다. 
    비슷한 종류의 값을 모아서 저장하고 싶다면, Array를 만들면 됩니다. Array는 메모리상에서 여러 값을 연이어서 저장하고 사용 가능합니다.

    - 하드웨어 메모리 (RAM)가 1GB 라면, 10억 바이트 만큼의 자리가 있다는 뜻이다. 
    (메모리 한 칸 = 1byte = 8bit
    = 8 Set of 0/1 = 8 Set of 트랜지스터 ON/OFF)
    - C는 여러 자료형이 있고, 각 자료형은 서로 다른 크기의 메모리를 차지합니다. 
    ex. bool : 불리언, 1바이트 / char : 문자, 1바이트 
    int : 정수, 4바이트 / float : 실수, 4바이트 
    long : (더 큰) 정수, 8바이트 / double : (더 큰) 실수, 8바이트 
    string : 문자열, ?바이트
        - ex. 문자 HI!가 메모리에 저장되는 방식

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%203.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%203.png)

    - score 평균을 구하는 방법
        1. 나열하는 방법

            ```swift
            int main(void)
            {
                int score1 = 72;
                int score2 = 73;
                int score3 = 33;

                printf("Average: %i\n", (score1 + score2 + score3) / 3);
            }
            ```

        2. 하나의 변수에 Array를 할당하는 방법
            - 만약 점수의 개수가 더 많아진다면 이 프로그램은 많은 부분을 수정해줘야 합니다.
            - 이 때 활용할 수 있는 것이 배열의 개념입니다. 배열은 같은 자료형의 데이터들을 하나의 변수에 넣어 관리하기 위해 사용됩니다. 이 데이터들은 메모리상에 연이어 저장됩니다.

            ```swift
            int main(void)
            {
                int scores[3];   // 정수 3개를 저장하기 위한 메모리를 달라! 이 데이터들을 Array 형태로 하나의 변수 (score)에 할당하겠다.
                scores[0] = 72;  // index 0에 ~을 할당하겠다
                scores[1] = 73;  // index 1에 ~을 할당하겠다
                scores[2] = 33;  // index 2에 ~을 할당하겠다

                printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
            }
            ```

        3. 상수로 배열의 크기 (데이터의 크기)를 지정
            - scores 배열의 크기를 정해주는 N이라는 변수를 선언하였습니다.
            - 만약 N이 상수라면 prefix const를 통해 전역 변수, 즉 코드 전반에 거쳐 바뀌지 않는 값임을 지정해줄 수 있습니다. 관례적으로 이런 전역 변수는 코드 상단에, 대문자로 표기 합니다.

            ```swift
            const int N = 3;

            int main(void)
            {
                int scores[N];
                scores[0] = 72;
                scores[1] = 73;
                scores[2] = 33;

                printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
            }
            ```

        4. 사용자로부터 입력값을 받는 dynamic한 프로그램

            ```swift
            float average(int length, int array[]); // C는 위에서 아래로 작동하므로 함수 average의 prototype을 써줘야 한다. 
            // statements는 생략가능하다. 유일하게 코드세계에서 복붙이 허용되는 때이다.

            int main(void)
            {
                // 사용자로부터 점수의 개수 입력
                int n = get_int("Scores:  ");

                // 1) scores라는 변수에 배열 선언하여 할당, 2) 사용자로부터 값 입력 받아 i번째 index에 할당
                int scores[n];
                for (int i = 0; i < n; i++) // i++ : 1씩 더한다.
                {
                    scores[i] = get_int("Score %i: ", i + 1);
                }

                printf("Average: %.1f\n", average(n, scores)); // 함수 average를 활용한다.
            }

            // 평균을 계산하는 함수
            float average(int length, int array[]) // 주어진 array (사용자가 입력한)의 length를 parameter로 활용하겠다. return값이 float type 이다.
            {
                int sum = 0;
                for (int i = 0; i < length; i++)
                {
                    sum += array[i];
                 // sum = sum + array[i] 와 동일함
                }
                return (float) sum / (float) length; // *int를 float으로 캐스팅해줌
            }
            ```

    - 문자열 (string)과 배열 - 메모리
        - 변수에 데이터를 할당하면, 컴퓨터가 각 데이터의 자료형에 따라 알아서 필요한 저장공간을 계산한다. (예를 들어 int 면 4바이트 만큼의 공간을 준다.)
        - string은 사실 char의 배열이었습니다! *실제로는 String은 '포인터' (5. Memory 참고)
        `string s = “HI!”;` 과 같이 string type의 변수 s가 있다면,
        s는 문자 (char)의 배열이기 때문에 메모리상에 아래 그림과 같이 저장되고, 인덱스로 각 문자에 접근할 수 있습니다.

            ![https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png](https://cs50.harvard.edu/x/2020/notes/2/memory_with_string.png)

        - 따라서 String 은 문자의 수에 따라 저장공간이 결정된다. (int 등 다른 data type과 달리 일정한 크기를 가질 수 없음) 
        - HI!는 4 byte가 필요하다. 길이가 다른 David 와 JURINBWODKA 의 저장공간의 크기는 다르다.
        - 맨 우측의 ‘\0’은 문자열의 끝을 나타내는 null terminating character (널 종단 문자)입니다. 이것은 1byte (=8bit)가 모두 0을 나타내는 상태를 의미한다. 
        즉, 문자열의 끝을 표시하기 위해 1 byte를 0으로 채워 낭비하는 것이다. 
        `저장공간 = 문자수 + 1 바이트`
        - string 여러 개가 동시에 선언된 경우
            - 출력하는 것은 문자열이 아닌 문자입니다. 여기서는 각 이름의 두번째 문자를 출력하고자 합니다. 이는 names[0][1]과 같이 2차원 배열을 통해 접근한 것이다.

                ```c
                string names[4]; // string type의 array 생성 (4개 string을 저장할 공간을 달라)

                names[0] = "EMMA";
                names[1] = "RODRIGO";
                names[2] = "BRIAN";
                names[3] = "DAVID";

                printf("%s\n", names[0]); // EMMA 출력
                printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]); // String names[0]에 대한 index 0~3의 Character를 하나씩 꺼내서 출력 -> EMMA

                ```

            - Array names가 실제 메모리상에 저장된 예시

                ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%204.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%204.png)

            - [x]  name[0][20]이 어떻게 가능하지?
                - names[400]을 호출하려고 하면 names 배열은 4개까지로 정해졌기 때문에 호출할 수 없다는 에러 메세지가 발생합니다.
                하지만 for 문을 이용하여 names[0][0]부터 names[0][20]까지 출력하면 아무런 이상없이 출력이 됩니다. 또한 출력한 결과물 중에 'RODRIGO'(names[1]의 값) 가 있는 것을 확인할 수 있습니다.
                - 그렇다면 names[x][y] 라는 값은 어떤 '배열 L' (메모리 L) 에서 names[x]를 시작점으로 하여 y번째 떨어진 값이라는 가정이 가능합니다. 또한 names[0]~names[3]까지의 값 또한 배열 L 상에 있다고 볼 수 있습니다.
                names[0][y] 값으로도 names[1][0], names[2][0], names[3][0]에 해당하는 값을 찾을 수 있습니다.(각각 R,B,D 입니다.) 또한 중간 중간에 코드에 입력한 내용들도 호출되는 것을 볼수 있습니다. (아래 사진에서 What is names[0][34]? 부터 ~[60]? 까지 보시면 해당 내용이 첫번째 printf() 의 코드의 내용 중 일부와 일치함을 알 수 있습니다.)
                - 에러가 발생하지 않는 이유
                우리는 변수의 '길이(크기)'를 지정해 주지 않았다. 그래서 names[0][y] 값이 문자열 EMMA 의 길이보다 길어도 컴파일러는 오류인지 검사를 하지 않는다. 
                그래서 names[0][y]는 names[0][0]에서부터 y만큼 떨어진 위치의 메모리 값을 반환한다. 
                (names[x]는 크기가 고정되어 있지 않은 변수입니다. 그래서 컴파일러는 names[x][y]에서 names저장된 값의 길이를 무시하고 y값 만큼 떨어져 있는 메모리 값을 반환합니다.)

                    ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%205.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%205.png)

    - 문자열의 활용
    - 구현 : 사용자로부터 문자열을 입력받아 한 글자씩 출력하는 프로그램
        1. for 문 사용

            ```c
            int main(void)
            {
            	string s = get_string("Input: ");
              printf("Output: ");
              for (int i = 0; s[i] != '\0'; i++) // 문자열 s의 값이 null이 아님이 true일 때까지
            	{
            		printf("%c", s[i]);
            	}
            	printf("\n");
            }
            ```

        2. strlen() 함수 활용 (string의 length 정보를 이용)

            ```c
            #include <string.h> // string length를 활용하기 위해 추가

            int main(void)
            {
            	string s = get_string("Input: ");
              printf("Output: ");

            	int n = strlen(s)
              for (int i = 0; i < n; i++) // s의 length 만큼
            	{
            		printf("%c", s[i]);
            	}
            	printf("\n");
            }
            ```

            ```c
            #include <string.h> // strlen() 함수 활용을 위해 추가

            int main(void)
            {
            	string s = get_string("Input: ");
              printf("Output: ");
              for (int i = 0, n = strlen(s); i < n; i++) // s의 length 만큼
            	{
            		printf("%c", s[i]);
            	}
            	printf("\n");
            }
            ```

        3. 대문자로 바꾸는 기능을 추가

            ```c
            #include <string.h>

            int main(void)
            {
                string s = get_string("Before: ");
                printf("After:  ");
                for (int i = 0, n = strlen(s); i < n; i++)
                {
                    if (s[i] >= 'a' && s[i] <= 'z') // a 이상이고 z 이하일 때
                    {
                        printf("%c", s[i] - 32); // ASCII 활용
                    }
                    else
                    {
                        printf("%c", s[i]);
                    }
                }
                printf("\n");
            }
            ```

        4. 함수 활용

            ```c
            #include <ctype.h> // 추가
            #include <string.h>

            int main(void)
            {
                string s = get_string("Before: ");
                printf("After:  ");
                for (int i = 0, n = strlen(s); i < n; i++)
                {
                    printf("%c", toupper(s[i]));
                }
                printf("\n");
            }
            ```

    - 명령행 인자 (command-line arguments)
        - void를 바꿔보자
        *argc : argument count
        *argv : argument vector
        - 프롬프트 창에서 파일을 실행함과 동시에 입력값을 줄 수 있다.

            - C의 main 함수는 기본적으로 반환값을 가진다.

            ```c
            // int main(void) {} : 명령행 인자가 필요 없다는 뜻

            #include <cs50.h>
            #include <stdio.h>

            int main(int argc, string argv[]) // parameter가 2개 
            {
                if (argc == 2) // 사용자가 입력한 값 
                {
                    printf("hello, %s\n", argv[1]); // *참고 argv[0] = ./argv (프롬프트 입력값 그 자체의 첫 문자열)
                }
                else
                {
                    printf("hello, world\n");
                }
            }

            -
            $ ./argv David (프로그램 뒤에 argument 입력 -> array로 들어감)
            => 
            hello, David
            ```

# 4. Algorithms

*comparison sorting algorithms animation - [https://www.youtube.com/watch?v=ZZuD6iUe3Pc&t=10s](https://www.youtube.com/watch?v=ZZuD6iUe3Pc&t=10s)

- 검색 알고리즘 - linear search, binary search
    - 선형 검색 (linear search)
    - 배열이 정렬되지 않았다면 (random), 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 확인하는 방식으로 검색한다.

        ```c
        For i from 0 to n–1  // 서랍이 n개일 때

            If i'th element is 50
                Return true

        Return false
        ```

    - 이진 검색 (binary search)
    - 만약 배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은 (작은 값이 저장된) 인덱스 또는 큰 (큰 값이 저장된) 인덱스로 이동을 반복합니다.

        ```c
        If no items
            Return false

        If middle item is 50
            Return true

        Else if 50 < middle item
            Search left half

        Else if 50 > middle item
            Search right half
        ```

- 표기법 : 알고리즘 실행시간의 상한/하한 - Big O / Big Ω
    - Big O - 실행시간의 상한 → 프로그램 설계의 기준
        - 코드의 efficiency를 나타냅니다.
        - O(n) 은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가합니다. (O(n/2)도 n이 매우 커지면 1/2은 큰 의미가 없어지므로 결국 O(n)이라고 볼 수 있습니다.)
        - 실행시간 - 아래로 갈수록 빠름 (n size의 problem을 해결하기 위해 걸리는 시간) /on the order of/ (~만큼의 정도로 커지는)
            - O(n^2)      - bubble sort, selection sort
            - O(n log n) - merge sort
            - O(n)          - linear search (n개의 서랍 중 마지막에 답을 찾은 경우), Linked List (search/insert), Hash Table (worst)
            - O(log n)    - binary search, Tree (search/insert)
            - O(1)           - Hash Table (ideal - 모든 값이 한 바구니에 담긴 경우)
    - Big Ω - 실행시간의 하한
        - 예를 들어 선형 검색에서 n개의 서랍이 있을 때 최대 n번 검색해야 하므로 상한이 O(n)이지만, 운이 좋다면 한 번에 끝낼수 있으므로 하한은 Ω(1)이 됩니다.
        - 실행시간 /omega/
            - Ω(n^2)      - bubble sort, selection sort
            - Ω(n log n) - merge sort
            - Ω(n)          - 배열 안에 존재하는 값의 개수 세기, 개선된 bubble sort
            - Ω(log n)
            - Ω(1)          - linear search, binary search, Hash Table (ideal - 모든 값이 개별 바구니에 담긴 경우), Trie
    - θ - 상한과 하한이 동일한 경우
        - 실행시간 /theta/
            - θ(n^2)      - selection sort
            - θ(n log n) - merge sort
            - θ(n)
            - θ(log n)
            - θ(1)

- linear search

    구현 - 전화번호부에서 특정 이름을 찾아 해당하는 전화번호를 출력하는 프로그램

    1. 문자열 단순 비교, name-number 각각 입력하여 활용
    - 단점 : name, number의 index가 불일치하면 오류 발생

        ```c
        int main(void)
        {
            string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
            string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};

            for (int i = 0; i < 4; i++)
            {
                if (strcmp(names[i], "EMMA") == 0) // *strcmp : string comparison // if (names[i] == "EMMA") 는 C에서 불가 (string에 비교연산자 == 사용불가)
                {
                    printf("Found %s\n", numbers[i]);
                    return 0; // 관습-success
                }
            }
            printf("Not found\n");
            return 1; // 관습-fail
        }
        ```

    2. Struct 사용
    - 내 사용목적에 맞는 새로운 data type을 정의하겠다. 그건 struct이다. struct는 여러 type을 담을 수 있는 그릇이다.
    - `person a;` 라는 변수가 있다면, a.name 또는 a.number 이 각각 이름과 전화번호를 저장하는 변수가 된다. 안전하고 확장성 있다.

        ```c
        typedef struct // *typedef: define a type 
        {
            string name;
            string number;
        }
        person; // 이러한 struct의 name은 person이다.

        int main(void)
        {
            person people[4]; // Array people을 Struct person type으로 선언하겠다. 즉, Array의 각 element의 type이 struct person 이다.

            people[0].name = "EMMA";
            people[0].number = "617–555–0100";
            people[1].name = "RODRIGO";
            people[1].number = "617–555–0101";
            people[2].name = "BRIAN";
            people[2].number = "617–555–0102";
            people[3].name = "DAVID";
            people[3].number = "617–555–0103";

            // EMMA 검색
            for (int i = 0; i < 4; i++)
            {
                if (strcmp(people[i].name, "EMMA") == 0)
                {
                    printf("Found %s\n", people[i].number);
                    return 0;
                }
            }
            printf("Not found\n");
            return 1;
        }
        ```

- 정렬 알고리즘 - bubble sort
    - 정렬을 먼저하는 것이 유리한 경우를 판단해야 한다. (정렬 소요시간) 이진 검색을 하기 위해 정렬을 하는데, 정렬 소요시간이 너무 크면 오히려 비효율적이다.
    - 버블 정렬 : 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법. (거품이(비교 및 교환이) 터지면서 위로 올라오는 (배열의 옆으로 이동하는) 방식)
        - 특징 : 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중합니다. 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있습니다.

        ```c
        Repeat n–1 times // (1) n-1 번
            For i from 0 to n–2 // (2) n-1 번
                If i'th and i+1'th elements out of order
                    Swap them
        ```

        - 실행시간

            중첩 루프를 돌아야 하고, n개의 값이 주어졌을 때 각 루프는 각각 (1) n-1번, (2) n-1 번 반복되므로 (n-1)*(n-1) = n^2-2n+1 번의 비교 및 교환이 필요합니다.

            → 여기서 가장 크기가 큰 요소는 n^2 이므로 위와 같은 코드로 작성한 버블 정렬 실행 시간의 상한은 O(n^2)이다. - 비효율적

            → 정렬이 되어 있는지 여부에 관계 없이 루프를 돌며 비교를 해야 하므로 위와 같은 코드로 작성한 버블 정렬의 실행 시간의 하한도 여전히 Ω(n^2)이 됩니다.

- 정렬 알고리즘 - selection sort
    - 선택 정렬 : 배열 안의 자료 중 가장 작은 수를 찾아 첫 번째 위치의 수와 교환해주는 방식의 정렬입니다.
        - 특징 : 선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가합니다. (n번의 내부 루프에서 각 item 중 가장 작은 수를 일일히 체크해야 함)

        ```c
        For i from 0 to n–1 // n번 반복
            Find smallest item between i'th item and last item // n번 비교
            Swap smallest item with i'th item
        ```

        - 실행시간

            여기서도 **두** 번의 루프를 돌아야 합니다. 바깥 루프에서는 숫자들을 처음부터 순서대로 방문하고, 안쪽 루프에서는 가장 작은 값을 찾아야 합니다.

            n개의 값이 주어졌을 때, n+(n-1)+(n-2)+...+1 번 (= n(n+1) / 2) 비교해야 함 

            → 따라서 소요 시간의 상한은 O(n^2)이 됩니다. 하한도 마찬가지로 Ω(n^2) 입니다. bubble sort과 동일합니다.

- 실행시간 단축 - 개선된 bubble sort
    - bubble sort에서 정렬이 모두 되어 있는 숫자 리스트가 주어진다면?

        ```c
        // Repeat n–1 times // 이미 완성이 되었는데 n-1 번 반복할 필요가 없다.
        Repeat until no swaps // 대체 (swap이 없다면 알고리즘 종료)

            For i from 0 to n–2
                If i'th and i+1'th elements out of order
                    Swap them
        ```

        - 실행시간

            1 2 3 4 5 6 7 8. 모두 정렬이 된 상태라고 가정하면, n-1번 비교하면 끝난다. 따라서 최종적으로 버블 정렬의 하한은 Ω(n)이 됩니다.

            상황에 따라서는 선택 정렬보다 더 빠른 방법이 되는 것이죠.

- 재귀 (Recursion)

    - 재귀 : 함수가 본인 스스로를 호출해서 사용

    - 구현 : 마리오 피라미드

    - 방법1. 중첩 루프

        ```c
        void draw(int h);

        int main(void)
        {
            int height = get_int("Height: "); // 사용자로부터 피라미드의 높이를 입력 받아 저장
            draw(height); // 피라미드 그리기
        }

        void draw(int h) // 함수 draw 구현
        {
            for (int i = 1; i <= h; i++) // 높이가 h인 피라미드 그리기
            {
                for (int j = 1; j <= i; j++) // 폭이 j인 한 층을 표현
                {
                    printf("#");
                }
                printf("\n");
            }
        }
        ```

    - 방법2. 재귀 함수

        중첩 루프를 보면, 사실 바깥쪽 루프는 안쪽 루프에서 수행하는 내용을 반복하는 것일 뿐입니다.
        따라서 바깥 쪽 루프를 없앤 draw함수를 만들고, 이를 ‘재귀적으로’ 호출하여 동일한 작업을 할 수 있습니다.
        (즉, '3층 피라미드'는 '2층 피라미드에서 한 층을 추가한 것'이라는 개념을 활용했다. 단, 0층 피라미드는 존재하지 않는다.)

        ```c
        void draw(int h);

        int main(void)
        {
            int height = get_int("Height: ");
            draw(height);
        }

        void draw(int h)
        {
            if (h == 0) // 1. 0층 피라미드라면 (시작점 조건문) -> 무한 반복을 방지한다. (하드코딩)
            {
                return; // 아무것도 안하겠다
            }

            draw(h - 1); // 2. 높이가 h-1인 피라미드 그리기

            for (int i = 0; i < h; i++) // 3. 피라미드에서 폭이 h인 한 층 그리기
            {
                printf("#"); // 예를 들어 h=4 이면 #### 출력 (i는 0에서 3까지 총 4번 작동)
            }
            printf("\n");
        }
        ```

        h라는 높이를 받았을 때, h-1 높이로 draw 함수를 먼저 호출하고, 그 후에 h 만큼의 #을 출력합니다. 여기서 내부적으로 호출된 draw 함수를 따라가다 보면 h = 0인 상황이 오게 됩니다. 따라서 그 때는 아무것도 출력을 하지 않도록 하는 **조건문을 추가**해줘야 합니다.

        이렇게 재귀를 사용하면 중첩 루프를 사용하지 않고도 하나의 함수로 동일한 작업을 수행할 수 있습니다.

        - [x]  함수의 실행 순서
        왜 출력이 # ## ### 순이지? ### ## # 가 아니라?
            - 모든 함수는 1줄씩 순서대로 처리되고 함수를 실행하면 그 함수가 끝날때 까지는 아랫줄은 실행이 되지 않는다.

                1) h=4일 때, 함수 호출 순서만 보자면 draw(3) -> draw(2) -> draw(1) -> draw(0) 이다.

                2) 하지만 각 draw(n)은 내부의 draw(n-1)이 끝날 때 까지는 for문이 실행되지 않는다.

                3) 따라서 출력 순서는 draw(0) → draw(1) -> draw(2) → draw(3) 이 된다.

                ```c
                // h=2 가정하면

                draw(2)
                {
                	h=0 이면 return
                	draw(1)
                	for ~ ##+줄바꿈 출력
                }

                -
                // 따라서 draw(1)이 통째로 해당 위치에 치환되는 것이다.
                // 그것을 시각적으로 나타내면

                draw(2)
                {
                	h=0 이면 return
                	draw(0)
                	#+줄바꿈 출력
                	for ~ ##+줄바꿈 출력
                }

                // 따라서 # ## 순서로 출력된다. (호출 순서는 반대임에도 불구하고)
                ```

- 정렬 알고리즘 - merge sort

    - 병합 정렬 : 원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬하는 방식입니다. ****이 과정은 재귀적으로 구현됩니다.

    - 특징 : 속도가 빠르지만, empty array를 써야하므로 메모리를 필요로 함

    ```c
    If only one item // 특수한 경우에 대해 하드코딩 해줌 (1개 뿐이면 sort 필요 없음)
    	return
    Else
    	sort left half of items  // 1. 왼쪽 정렬
    	sort right half of items // 2. 오른쪽 정렬
    	Merge sorted halves      // 3. 두 배열의 병합 (작은 요소를 왼쪽에 배치)
    ```

    - 과정 도식화

        7 | 4 | 5 | 2 | 6 | 3 | 8 | 1  → 가장 작은 부분 (숫자 1개)으로 나눠진 결과입니다.

        4   7 | 2   5 | 3   6 | 1   8  → 숫자 1개씩을 정렬하여 병합 (재배치)한 결과입니다.

        2   4   5   7 | 1   3   6   8  → 숫자 2개씩을 정렬하여 병합 (재배치)한 결과입니다.

        1   2   3   4   5   6   7   8  → 마지막으로 숫자 4개씩을 정렬하여 병합한 결과입니다.

    - 실행시간

        상한은 O(n log n) 입니다. 숫자들을 반으로 나누는 데는 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸리기 때문입니다.

        하한 또한 Ω(n log n) 입니다. 숫자들이 이미 정렬되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요하기 때문입니다.

    - [x]  3번쨰 단계인 Merge (병합하여 작은 요소부터 왼쪽으로 배치하는 기능)을 어떻게 구현?
        - [https://www.youtube.com/watch?v=QAyl79dCO_k](https://www.youtube.com/watch?v=QAyl79dCO_k)
        - 병합 정렬은 전체 n개의 배열을 n/2와 n/2로 쪼개서 각각 정렬한 후 다시 합치는 방식입니다. 이 때, 중요한 점은 병합할 두개의 배열 각각이 이미 정렬이 되어있다는 점입니다.

            예를 들어, A=[1, 3, 5], B=[2, 4, 6] 이 둘을 병합한다고 해보겠습니다. 1과 2를 비교하여 1이 더 작다는 결과를 얻었다면, 1은 더 이상 2보다 큰 B의 다른 원소들과 비교할  필요가 없어지는 것이죠.

            따라서 병합하는 과정에서 아무리 많아봐야 n번의 비교밖에 이뤄지지 않습니다.
            즉, 쪼개는 과정이 log n이고 합치는 과정이 n이 되어,  n*log n 에 수행될 수 있습니다.

# 5. Memory

- 메모리 주소 - 0x16진수
    - 16진수 hexadecimal

        123456789ABCDEF (F=15)

        → 10 (16^1*1 + 16^0*0 = 16)

        → FF (16^1*15 + 16^0*15 = 255)

        색상을 나타내는 RGB 등에 활용한다.

        prefix 0x를 사용한다.

    - 메모리 주소
    - int type 변수 n에 50이라는 값을 저장/출력해 봅시다. 이때 n은 int 타입이므로 컴퓨터의 메모리 어딘가에 4바이트 만큼의 자리를 차지하며 저장된다.
    *pointer : the address of a certain variable

        ```c
        int main(void)
        {
            int n = 50;
            printf("%p\n", &n);   // %p : pointer, & : the address of n
            printf("%i\n", *&n);  // * : go to the address of n
        }

        // =>
        // 0x7ffe00b3adbc  // 변수 n의 16진법으로 표현된 메모리의 주소 (포인터 값)
        // 50  // 해당 주소에 있는 값을 다시 읽음 (*로 & 연산자를 undo 시킴)
        ```

- 포인터 - int * (int의 address)
    - 새로운 자료형 int * 
    - 이 변수는 포인터 (int의 address)이고, 포인터가 가르키는 주소에 있는 값이 int type이라는 뜻이다.
    - address는 int에 할당할 수 없다. 포인터에만 할당 가능하다.
    - 포인터의 크기는 8 바이트이다. (64비트 시스템에서 현대 하드웨어 구조상)
    *'cpu의 기본 처리 bit수', 그리고 '운영체제의 채택 bit' 이 두 개의 요소에 의해 포인터의 바이트 크기가 정해지게 됩니다. 만약 cpu가 64bit이고 운영체제도 64bit라면 포인터의 바이트는 8바이트가 되며, cpu가 64bit이나 운영체제가 32bit라면 포인터는 4바이트가 됩니다.
    - 참고- 포인터의 operator (CS SNU)

        *p : returns the value pointed to by p (dereferencing operator)
        &n : returns the address of variable n

        ```c
        int main(void)
        {
           int n = 50;
           int *p = &n; // 변수 n의 주소를 *p라는 <포인터 변수>에 할당
           printf("%p\n", p); // p의 값 (n의 주소) -> 0x어쩌고 16진수 출력 // %p : address는 int에 할당할 수 없다. 포인터에만 할당 가능하다.
           printf("%i\n", *p); // p가 가르키고 있는 주소에 있는 값 (%i : p에 있는 값은 int type이므로) -> 50 출력
        }

        // *p : go to that address (p가 가르키는 주소)라는 의미 (역참조 연산자)
        ```

    - 실제 메모리

        실제 컴퓨터 메모리에서 변수 p는 아래와 같이 저장될 수 있습니다.
        p는 다른 메모리 공간에서 변수 n의 주소를 가지고 있습니다. 
        (보물찾기 지도처럼 주소 자체가 중요한 게 아니라, 변수 p가 가르키는 값 (변수 n의 값)으로 연결되는 것이 목적임)

        ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%206.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%206.png)

        즉, 아래 그림과 같이 실제로 p의 값(=n의 주소값)을 생각하지 않고, 추상적으로 단지 p가 n을 가리키고 있다는 것만 생각해도 됩니다.

        ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%207.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%207.png)

- String - 첫 문자를 가르키는 포인터 (char *)

    여태껏 String을 저장하기 위해 CS50 라이브러리에 포함된 string 자료형을 사용했습니다. 

    `string s = “EMMA”;` 변수 s에 “EMMA”라는 값을 저장해 봅시다.

    String은 결국 문자의 배열이고, s[0], s[1], s[2], … 와 같이 하나의 문자가 배열의 한 부분을 나타냅니다. 가장 마지막의 \0 (null terminator)은 String의 끝을 표시하는 약속입니다.

    ⇒ 여기서 변수 s는 결국 String을 가리키는 포인터가 됩니다. 즉, String의 가장 첫번째 문자(=주소 0x123에 있는 s[0])를 가리키게 됩니다. 그리고 %s로 출력하면 \0에서 자동으로 종료합니다.

    ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%208.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%208.png)

    즉, String은 배열 (Week2 때 배운 개념=선의의 거짓말)이 아니라 포인터였던 것이다!

    ```c
    // string s = “EMMA”; // 아래와 동일함
    char *s = "EMMA";
    ```

    - 보조바퀴 떼어내기

        ```c
        typedef struct  // struct 정의
        {
        	string name;
        	string number;
        }
        person; // 사용자가 정의한 새로운 data type인 struct의 name
        ```

        ```c
        // 실제 CS50 라이브러리를 보면 string 자료형은 아래와 같이 정의되어 있습니다.

        typedef char *string;

        1. typedef : 새로운 data type을 선언하겠다
        2. char * : 이 type은 char *(문자의 주소)가 될 것이다
        3. string : 이 type의 name은 string 이다

        // string 이라는 자료형은 실제로 존재한 것이 아니었다...!

        // CS50 라이브러리를 통해 사용했던 string (사용자가 정의한 새로운 type의 name)은
        // 사실은 char * 이라고 미리 정의해둔 것이었다.
        ```

        - [ ]  CS50 라이브러리에서만? 아니면 C언어에서만? 
        JS 이나 Swift에는 실제 data type으로 String이 존재하잖아..!
        - [x]  근데 C에도 %s 는 존재하잖아?
            - %s 자체가 첫번째 문자부터 null terminator까지 출력하는 기능임

    - 확인용

        ```c
        int main(void)
        {
            char *s = "EMMA";  
            printf("%s\n", s); // EMMA 출력
        		printf("%p\n", s); // string EMMA의 첫번째 문자 E의 주소를 출력 (string 자체가 포인터, 포인터 변수에는 주소가 할당되어 있다)

        		printf("%p\n", &s[0]); // E의 주소를 출력 (위와 동일한 결과)
        		printf("%p\n", &s[1]); // M의 주소를 출력 (1 바이트 away)

        		// 참고
        		printf("%p\n", &s); // 포인터 변수s의 주소를 출력 (안중요했던 그것)

        		printf("%c\n", *s);    // *s : s가 가르키고 있는 주소의 값 -> E 출력
        		printf("%c\n", s[0]);  // string의 index 0의 문자 -> E 출력 (위와 동일)
        		printf("%c\n", *(s+1); // 첫번째 문자+1 을 하면 두번째 문자 -> M 출력
        		printf("%c\n", s[1]);  // string의 index 1의 문자 -> M 출력 (위와 동일)
        }
        ```

        - syntactic sugar is syntax within a programming language that is designed to make things easier to read or to express.
        - clang이 개발자 편의을 위해 s[1]을 *(s+1)으로 바뀌준다.
        - pointer arithmatic (포인터 연산)은 주소를 가져와서 +1, +2... 등을 해줌

    - 문자열 비교

        ```c
        int main(void)
        {
        //  string s = get_string("s: ");   // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
        //  string t = get_string("t: ");

        char *s = get_string("s: "); // 위와 동일 (string 자체가 포인터이며, 포인터 변수는 첫문자의 주소를 저장함)
        char *t = get_string("t: ");

            if (s == t)    // 두 문자열을 비교 (각 문자들을 비교)
            {
                printf("Same\n");
            }
            else
            {
                printf("Different\n");
            }
        }

        // 확인용
        printf("%p\n", s); // s의 첫문자 E의 주소 -> 0xed76a0 출력
        printf("%p\n", t); // t의 첫문자 E의 주소 -> 0xed76e0 출력 (몇 바이트 떨어져 있음)

        -
        s: EMMA, t: EMMA
        => 
        Different 출력

        // string 자체가 포인터이기 때문 (두 포인터 변수의 메모리 주소가 다르기 때문)
        ```

        - [x]  %s (string 자체)값을 비교하는게 아니라, %p (주소)값을 비교하는 것인가?
            - 그렇다. string 자체가 포인터 (첫문자의 주소)이기 때문이다.
        - [ ]  왜 t의 주소가 ed76a0 + 5 (EMMA의 바이트) = ed76a5 가 아니지?

- String 복사 - malloc & free가 필요
    - 구현 - 사용자의 string 입력값을 받아 1) 복사하고, 2) 대문자로 변경

        ```c
        #include <ctype.h> // 함수 toupper가 정의된 라이브러리

        int main(void)
        {
        //    string s = get_string("s: ");
        //    string t = s;  // 1) 복사, 아래와 동일함

        		char *s = get_string("s: ");
        		char *t = s;  // 1) 복사 - string 첫문자의 주소가 복사됨 

            t[0] = toupper(t[0]);  // 2) 대문자로 변경

            printf("s: %s\n", s);
            printf("t: %s\n", t);
        }

        -
        s: emma
        =>
        Emma
        Emma
        ```

        - 결과 : 의도와 달리 s, t 모두 첫문자가 대문자가 됐다.
        → s를 복사해서 t에 할당할 때, 주소가 복사된 것이기 때문이다!

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%209.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%209.png)

        - 본래 의도대로 string 값 자체를 복사하려면?
            - 메모리를 추가로 사용하여 다른 주소에 복사해야 한다.
            - EMMA와 동일한 크기의 변수를 만들고, s의 문자를 하나씩 복사
            - 함수 malloc 를 활용 (memory allocate - 메모리 할당 기능)

                ```c
                int main(void)
                {
                		char *s = get_string("s: ");

                //	char *t = malloc(5) // 5 바이트를 할당 (EMMA \0)
                		char *t = malloc(strlen(s) + 1); // 입력값에 대해 동적으로 기능함
                    // malloc도 마찬가지로 할당한 메모리의 첫 바이트 주소를 가르킨다.
                    // 즉, 메모리의 일부를 가져오고, 그곳을 가르키는 포인터를 주는 것이다. (malloc의 return type은 포인터)

                		for (int i = 0, n = strlen(s) + 1; i < n; i++)
                		{
                			t[i] = s[i];
                		}

                    t[0] = toupper(t[0]);  // 2) 대문자로 변경

                    printf("s: %s\n", s);
                    printf("t: %s\n", t);
                }

                -
                s: emma
                =>
                emma
                Emma
                ```

                - [x]  null terminator를 복사하지 않으면?
                    - 의도하지 않은 garbage value까지 복사될 수 있다.
            - strcpy 함수를 활용하면 더 간단하다.

                ```c
                int main(void)
                {
                		char *s = get_string("s: ");

                		char *t = malloc(strlen(s) + 1); 

                		strcpy(t, s); // 위의 for문을 대체

                    t[0] = toupper(t[0]);  

                    printf("s: %s\n", s);
                    printf("t: %s\n", t);
                }

                -
                s: emma
                =>
                emma
                Emma
                ```

    - 메모리 할당과 해제 - malloc & free
        - malloc 함수를 이용하여 메모리를 할당한 후에는 free 함수를 이용하여 사용하지 않는 메모리를 해제해야 합니다.

            해제하지 않으면 메모리에 저장한 값은 쓰레기 값으로 남아 메모리 용량의 낭비가 발생하기 때문이다. 이것을 ‘memory leak (메모리 누수)’라고 한다.

        - valgrind 프로그램의 디버깅 기능을 활용한다.  
        - 에러 메시지 - "LEAK SUMMARY : definitely lost: 5 bytes in 1 blocks"

            ⇒ help50
            - Looks like your program leaked 5 bytes of memory. Did you forget to free memory that you allocated via malloc? 

        ```c
        int main(void)
        {
        		char *s = get_string("s: ");

        		char *t = malloc(strlen(s) + 1); 
        // malloc도 마찬가지로 할당한 메모리의 첫 바이트 주소를 가르킨다.
        // 즉, 메모리의 일부를 가져오고,그곳을 가르키는 포인터를 주는 것이다.

        		strcpy(t, s); // 위의 for문을 대체

            t[0] = toupper(t[0]);  

            printf("s: %s\n", s);
            printf("t: %s\n", t);

        		free(t);  // gomalloc에서 할당한 메모리를 해제한다.
        }
        ```

        - buffer overflow

            ```c
            #include <stdlib.h>

            void f(void)
            {
                int *x = malloc(10 * sizeof(int)); // *함수 sizeof : 자료형의 크기를 알려줌
                // 10*4 바이트 만큼의 메모리를 할당한다. 그리고 그 메모리의 주소를 포인터 변수 x에 저장한다.
                // 사실상 정수를 저장하는 메모리의 배열이다.

            //  x[10] = 0;
                // buffer overflow 의 예시이다. (buffer = array)
                // 40 바이트 = 10개의 정수를 저장할 수 있다. 따라서 x[0]~x[9]까지만 할당 가능하다.

            		x[9] = 0;

            		free(x);  // malloc에서 할당한 메모리를 해제한다.
            }

            int main(void)
            {
                f();
                return 0;
            }
            ```

            - valgrind 에러 메세지 ⇒

                - x[10] = 0 → "Invalid write of size 4"  // 즉, 4바이트 만큼 overflow 했다는 의미이다.
                   *write(쓰기) : changing the value
                   → 해결 - x[9] = 0; 으로 수정해줌

                - "HEAP SUMMARY: 40 bytes in 1 blocks are definitely lost in loss record."
                   → 해결 -  free(x); 를 추가하여 메모리를 해제시켜줌

- 메모리 교환 (스택, 힙) - 포인터가 필요
    - 각각 사이다와 콜라가 들어있는 컵 두 개를 떠올려봅시다. 만약 사이다와 콜라를 각각 다른 컵으로 바꿔 담고 싶으면 어떻게 해야 할까요? 
    교환을 도와줄 수 있는 새로운 컵이 잠시 필요하겠죠. 
    메모리에 저장된 값들을 교환할 때도 이와 비슷하게 temp 임시 공간이 필요합니다.
        - 함수 swap은 정수 a와 b를 입력받아 그 값을 바꾸는 일을 수행합니다.
        main 함수에서는 x = 1, y = 2를 입력하고, swap 함수를 통해 두 값을 바꾸려고 합니다. ⇒ 결과는 실패
        - 실패 원인은 교환하는 대상이 x, y 자체가 아닌 함수 내에서 새롭게 정의된 a, b라는 것이었습니다.
        a와 b는 각각 x와 y의 값을 복제하여 가집니다. 서로 다른 메모리 주소에 저장되는 것이죠.

            ```c
            void swap(int a, int b);  // swap 함수의 prototype

            int main(void)
            {
                int x = 1;  // 콜라
                int y = 2;  // 사이다

                printf("x is %i, y is %i\n", x, y);
                swap(x, y);  // 함수에 parameter를 전달할 때, 그 값의 복사본을 전달한다. 즉, swap 함수는 x,y 값의 복사본을 a,b로 가져와서 a,b를 바꾼 것이다.
                printf("x is %i, y is %i\n", x, y);
            }

            void swap(int a, int b)  // a와 b를 바꿔주는 기능을 구현 (O)
            {
                int tmp = a;  // 초기 논리 - a를 임시 메모리에 넣어놓고
                a = b;        // b를 빈 a자리에 넣고
                b = tmp;      // 임시 메모리에 있던 a를 빈자리 b에 다시 넣는다
            }

            // x is 1, y is 2 출력
            // x is 1, y is 2 출력 -> swap 실패
            ```

        - Quiz - 올바르게 고친다면?
            - x,y 값의 복사본이 아니라 x,y의 주소를 알려줘서 swap 함수가 그 주소로 가서 값을 바꾸도록 하면 된다.

                ```c
                void swap(int *a, int *b);  // swap 함수의 prototype

                int main(void)
                {
                    int x = 1;
                    int y = 2;

                    printf("x is %i, y is %i\n", x, y);
                    swap(&x, &y);  // 1. x,y의 주소를 전달
                    printf("x is %i, y is %i\n", x, y);
                }

                void swap(int *a, int *b)  // 2. 인자로 어떤 주소를 받았다. (주소는 포인터에만 할당 가능함)
                {                          // int *a : 정수의 주소를 받아서 할당하고, 포인터 변수 a 라고 부르겠다.
                    int tmp = *a; // 3. *a : go to that address (a가 가르키는 주소) -> x의 주소 -> 그 값인 1을 tmp에 저장한다.
                    *a = *b;      // 4. *b : go to that address (b가 가르키는 주소) -> y의 주소 -> 그 값인 2를 *a에 저장한다. (2를 a가 가르키는 주소인 x에 저장한다.)
                    *b = tmp;     // tmp의 값인 1을 *b에 저장한다. (1을 b가 가르키는 주소인 y에 저장한다.)
                }

                // x is 1, y is 2 출력
                // x is 2, y is 1 출력 -> swap 성공
                ```

    - 메모리의 Data type별 저장 구역
        - 메모리 안에 데이터 저장 구역이 나뉘어 있다.
        - 머신 코드 영역 : 프로그램이 실행될 때 그 프로그램이 (clang을 통해) 컴파일된 바이너리
        - 글로벌 영역 : 프로그램 안에서 저장된 전역 변수
        - 힙 (heap) 영역 : malloc으로 할당된 메모리의 데이터 (malloc을 호출하면 메모리를 이 영역에서 가져옴)
        - 스택 (stack) : 프로그램 내의 함수와 관련된 것 (함수가 호출될 때 함수의 지역변수가 쌓임)
        *이때 heap overflow 및 stack overflow로 인해 PC가 동작하지 않는 buffer overflow가 발생 가능하다.

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2010.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2010.png)

        - 위 코드에서 a, b, x, y, tmp (지역변수들) 모두 스택 영역에 저장되지만, 
        a, b에 할당된 값은 x, y 값의 복사본이므로 a, b가 바뀌어도 x, y는 변하지 않는다.
        - 즉, 
        1) 바닥 - main 함수를 호출하면 바닥에 스택 프레임이라는 공간이 주어지고, x, y 등 지역변수를 저장한다. main 함수의 모든 변수는 여기에 저장된다.
        2) 그 위 - main 함수가 swap 함수를 호출하면 해당 함수를 위한 메모리 영역이 main 위에 쌓인다. swap의 인자 a, b, 임수변수 tmp는 여기에 저장된다.
        3) 여기서 a, b, tmp 를 통해 실제로 a, b 값은 swap이 가능하다. (a, b에 할당된 값은 x, y 값의 복사본이고, 따라서 x,y는 아무런 영향을 받지 않는다.)
             그리고 swap 직후 swap 층은 사라진다. 
        결론적으로 x, y 값은 변하지 않았다.

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2011.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2011.png)

        - 따라서 아래와 같이 a와 b를 각각 x와 y를 가리키는 포인터로 지정함으로써 문제를 해결할 수 있습니다.
        포인터 a가 가르키는 x의 주소, 포인터 b가 가르키는 y의 주소에 가서 x,y의 값을 직접 변경한다.

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2012.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2012.png)

        - 참고 - stack detail

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2013.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2013.png)

- 파일 쓰기
    - 사용자에게 입력값 받기 (라이브러리 없이 get_string 직접 구현하기)
        - get_int

            ```c
            int main(void)
            {
                int x;
                printf("x: ");
                // x = get_int();   // 라이브러리 활용

                scanf("%i", &x);  // scanf : 특정 data type을 쓰면 해당 type으로 입력받는 함수 - 해당 값을 변수의 주소 &x에 저장한다
                printf("x: %i\n", x);
            }

            // swap 함수 때 &x, &y를 사용한 것과 동일한 이유이다.
            ```

        - get_string

            ```c
            int main(void)
            {
            //  char *s;    // 변수 s가 uninitialized 되어 에러 발생
                char s[5];  // => 수정 - "EMMA" 입력을 가정하고, 저장공간 5바이트를 할당한다.

                printf("s: ");
                scanf("%s", s);  // s는 그 자체로 포인터 (첫문자의 주소)이므로 &s가 아니라 s를 쓴다.
                printf("s: %s\n", s);
            }
            ```

    - 파일에 쓰기
        - 기능 - 사용자의 입력값을 파일 phonebook.csv 에 축적하는 방식으로 저장하는 프로그램
        - csv : comma separated value (쉼표로 분리된 값)

            ```c
            #include <cs50.h>
            #include <stdio.h>
            #include <string.h>

            int main(void)
            {
                // 1. open file
                FILE *file = fopen("phonebook.csv", "a"); 
                // fopen 함수 : 파일을 FILE이라는 자료형으로 불러온다. (포인터 변수 file를 선언)
                // 첫번째 인자는 "오픈할 파일명", 두번째 인자는 모드로 "r-읽기, w-쓰기, a-덧붙이기"를 의미한다.
                // fopen은 해당 파일을 가르키는 포인터를 반환한다. ???

                // 2. get strings from user
                char *name = get_string("Name: ");
                char *number = get_string("Number: ");  // 사용자를 통해 name과 number라는 문자열을 입력 받고 

                // 3. print (write) strings to file
                fprintf(file, "%s,%s\n", name, number);
                // fprintf 함수 /file printf/ : 파일 file에 내용 (name, number)을 출력한다.

                // 4. close file
                fclose(file);  // fclose 함수 : 작업을 마친 후에 파일의 작업을 종료해준다.
            }
            ```

- 파일 읽기
    - 기능 - 파일의 내용을 읽어서 파일 형식이 JPEG 이미지인지 검사하는 프로그램 (./jpeg)

        ```c
        #include <stdio.h>

        int main(int argc, char *argv[])
        {
        // 1. ensure user ran program with two words at prompt
            if (argc != 2)
            {
                return 1;
            }
        // 만약 argc가 2가 아니라면, 파일명이 미입력됐거나 파일명 외 다른 인자가 입력되었기 때문에 1(오류)을 리턴하고 프로그램을 종료한다.

        // 2. open and read file
            FILE *file = fopen(argv[1], "r");

            if (file == NULL)
            {
                return 1;
            }
        // 입력받은 파일명 argv[1]을 읽기(r) 모드로 불러온다.
        // 만약 파일이 열리지 않으면 fopen 함수는 NULL을 리턴하기 때문에 그 결과 1(오류)을 리턴하고 프로그램을 종료한다.

        // 3. read 3 bytes from file
            unsigned char bytes[3];   // unsigned : 음수 가능 -> 부호없는, 양수 아닌가?
            fread(bytes, 3, 1, file); // fread 함수의 각 인자는 (배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)을 의미한다.
            // 크기가 3 바이트인 문자 배열을 만들고, fread 함수를 통해 파일에서 첫 3바이트를 읽어온다.

        // 4. check if bytes are 0xff, 0xd8, 0xff (&& : and)
            if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
            {
                printf("Maybe\n");
            }
            else
            {
                printf("No\n");
            }
        // 읽어들인 각 바이트가 각각 0xFF, 0xD8, 0xFF 인지 확인한다.
        // 이는 JPEG 파일 형식을 정의할 때 만든 약속으로, JPEG 파일의 시작점에 포함되어 있어야 한다. 따라서 JPEG 파일인지 확인 가능하다.

            fclose(file);
        }

        -
        $ ./jpeg scr4/brian.jpg
        => maybe
        $ ./jpeg src4/car.gif
        => no
        ```

        - 참고 - 명령행 인자 (command-line arguments)
            - 프롬프트를 통해 사용자가 입력한 값
            *argc : argument count
            *argv : argument vector

                ```c
                $ ./argv David
                =>
                ```

                - argc == 2
                - argv[0] = ./argv (프롬프트 입력값 자체의 첫 문자열)
                argv[1] = David

# 6. Data Structure

*data structure : 메모리를 효율적으로 관리하기 위해 새로 정의하는 구조체. 일종의 메모리 레이아웃

- malloc & 포인터 복습
    - Quiz - 오류 발생 가능한 부분은 어디?

        ```c
        int main(void)
        {
            int *x; // 초기에 포인티 (포인터가 가르키는 것)를 지정하지 않음
            int *y;

            x = malloc(sizeof(int));  // sizeof : int 만큼의 메모리 크기를 알려줌 (4 바이트)
            // 그래서 4 바이트 만큼의 메모리 영역이 할당되고, 그 영역의 첫 주소를 반환해준다.
            // 그 주소를 포인터 변수 x에 저장한다.

            *x = 42; // go to x에 저장된 주소에 가서 -> 42를 저장한다.
            *y = 13; // 버그 발생 - 메모리 영역을 할당하지 않았음 (없거나 잘못된 주소로 접근 가능함)
        }
        ```

        - y는 포인터로만 선언되었을 뿐이지, 어디를 가리킬지에 대해서는 아직 정의가 되지 않았습니다. 따라서 초기화 되지 않은 *y는 프로그램 어딘가를 임의로 가리키고 있을 수도 있습니다. 따라서 그 곳에 13이라는 값을 저장하는 것이 오류를 발생시킬 수도 있는 것이다.
    - ver.2

        ```c
        int main(void)
        {
            int *x;
            int *y;

            x = malloc(sizeof(int));

            *x = 42;
        		
        		y = x;  // *** 변경 - x의 주소를 y에도 저장한다면? (왜 &y = &x 가 아니지? -> x,y 자체가 포인터 변수이므로)

            *y = 13;
        // y의 주소 = x의 주소로 가서 13을 override 한다.
        }
        ```

- Array 크기 조정

    - 구현 - 1,2,3 으로 구성된 배열에 4를 추가

    - 방법1 - 1,2,3 메모리 영역의 주변에 이미 할당된 값이 있을 수 있으므로 새로운 메모리 영역으로 옮겨줘야 한다.
    - 이전에 사용한 메모리는 버리거나 free() 를 실행한다. 
    - 배열의 크기 n만큼의 실행 시간이 소요됨 - O(n)

        ```swift
        #include <stdio.h>
        #include <stdlib.h>

        int main(void)
        {
            // 1. int 자료형 3개로 이루어진 포인터 변수 list를 선언하고 메모리 할당
            int *list = malloc(3 * sizeof(int));  
               // 1) malloc을 통해 메모리를 할당하고 해당 메모리의 첫주소를 반환해준다. (12바이트 덩어리의 주소)
               // 2) 해당 주소를 포인터 변수에 넣어준다.

            // 2. 포인터가 제대로 선언되었는지 확인 (메모리가 부족하면 malloc 실행 불가하므로 항상 체크해줌)
            if (list == NULL)
            {
                return 1;
            }

            // 3. list 배열의 각 인덱스에 값 저장
            list[0] = 1;  // 1~4th 바이트
            list[1] = 2;  // 5~8th 바이트
            list[2] = 3;  // 9~12th 바이트

            // 4. int 자료형 4개 크기의 포인터 변수 tmp를 선언하고 메모리 할당
            int *tmp = malloc(4 * sizeof(int));

            if (tmp == NULL)
            {
                return 1;
            }

            // 5. 기존 list의 값을 tmp로 복사 (copy integers from old array into new array)
            for (int i = 0; i < 3; i++) // 기존 integers가 3개 이므로
            {
                tmp[i] = list[i];
            }

            // 6. tmp 배열의 네 번째 값을 저장
            tmp[3] = 4;

            // 7. 기존 list의 메모리를 초기화
            free(list);

            // 8. list가 tmp와 같은 곳을 가리키도록 지정 (tmp 보다 list가 변수 이름으로 더 적절하므로 덮어쓰기 함)
            list = tmp;

            // 9. 새로운 배열 list의 값 확인
            for (int i = 0; i < 4; i++)
            {
                printf("%i\n", list[i]);
            }

            // 10. (신규) list의 메모리 초기화
            free(list);
        }
        ```

    - 방법2 - 함수 realloc 사용 (reallocate)

        ```swift
        #include <stdio.h>
        #include <stdlib.h>

        int main(void)
        {
            // 1. int 자료형 3개로 이루어진 포인터 변수 list를 선언하고 메모리 할당
            int *list = malloc(3 * sizeof(int));  
        			 // 1) malloc을 통해 메모리를 할당하고 해당 메모리의 첫주소를 반환해준다. (12바이트 덩어리의 주소)
        			 // 2) 해당 주소를 포인터 변수에 넣어준다.

            // 2. 포인터가 제대로 선언되었는지 확인 (메모리가 부족하면 malloc 실행 불가하므로 항상 체크해줌)
            if (list == NULL)
            {
                return 1;
            }

            // 3. list 배열의 각 인덱스에 값 저장
            list[0] = 1;  // 1~4th 바이트
            list[1] = 2;  // 5~8th 바이트
            list[2] = 3;  // 9~12th 바이트

            // 생략 - 4. int 자료형 4개 크기의 포인터 변수 tmp를 선언하고 메모리 할당
            int *tmp = malloc(4 * sizeof(int));

            if (tmp == NULL)
            {
                return 1;
            }

            // 생략 - 5. 기존 list의 값을 tmp로 복사 (copy integers from old array into new array)
            for (int i = 0; i < 3; i++) // 기존 integers가 3개 이므로
            {
                tmp[i] = list[i];
            }

        		// tmp 포인터에 메모리를 할당하고 list의 값 복사
            int *tmp = realloc(list, 4 * sizeof(int));  // realloc : 기존의 메모리 덩어리를 가져와서 크기를 조정한다.
            if (tmp == NULL)
            {
                return 1;
            }

            // 6. tmp 배열의 네 번째 값을 저장
            tmp[3] = 4;

            // 생략 - 7. 기존 list의 메모리를 초기화
            free(list);

            // 8. list가 tmp와 같은 곳을 가리키도록 지정 (tmp 보다 list가 변수 이름으로 더 적절하므로 덮어쓰기 함)
            list = tmp;

        		// 새로운 list의 네 번째 값 저장
        		list[3] = 4;

            // 새로운 배열 list의 값 확인
            for (int i = 0; i < 4; i++)
            {
                printf("%i\n", list[i]);
            }

            // list의 메모리 초기화
            free(list);
        }
        ```

        - 실질적으로 배열과 포인터는 같은 개념이다. 단, 배열은 컴파일러 기능 덕분에 free()를 안해도 자동으로 메모리가 해제된다.

- Linked List (연결 리스트) O(n)
    - 연결 리스트는 값들의 리스트를 저장하는 방법이고, data structure의 한 종류이다.
    - Linked List와 Array 비교
        - Array 
        - 단점 : 고정된 메모리 덩어리이며, 값 추가가 어려움 - 추가 메모리를 할당하고 기존 값을 이동해야 하므로 시간이 오래 걸림. insert 실행시간 O(n)
        - 장점 : [대괄호]로 문법적으로 쉽게 indexing, 
          임의 접근 (random access)으로 일정 시간에 접근 (constant time access) - index0,1,2 중간값에 즉시 접근 가능,
          임의 접근이 가능하므로 binary search 가능 - search 실행시간 O(log n) (단, 이미 정렬이 된 경우)
        - Linked List
        - 단점 : 임의 접근 불가 - 처음부터 끝까지 포인터를 따라 가야 값들을 비교 가능하며, 중간값으로 바로 갈수 없음,
          binary search 불가 - search 및 insert 실행시간 O(n)
        - 장점 : malloc을 통해 값 추가가 쉬움, 메모리 사용이 효율적임 (dynamic memory)
    - Linked List 개념
        - 연결 리스트 : 배열처럼 값을 메모리에 연속적으로 저장하지 않는다.
        value 뿐만아니라 포인터 (다음 요소를 가르킴 = next라고 부름, 최종 NULL-이것도 포인터)를 저장하므로 2배의 메모리가 필요하다.
        - 장점 : 데이터 추가 속도가 빠름, 메모리 공간 활용이 유연함 (메모리에 연속으로 저장하지 않아도 됨)
        - 단점 : 색인 접근이 불가하므로 검색 속도가 느림, 포인터를 사용하므로 접근 속도가 느림
        - node : 직사각형으로 나타내는 메모리 덩어리 (연결 리스트의 기본 단위)

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2014.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2014.png)

            - 1) node 정의

                ```swift
                typedef struct
                {
                	int number;
                	node *next;  // 다음 요소 (다음 node)에 해당하는 next를 가르킴 (node = <number+주소> 형태의 덩어리)
                }
                node; // 해당 struct의 이름

                // 에러 발생 - statements에 node를 사용해야 하는데 node struct의 정의가 마지막 줄에서 끝나므로 아래와 같이 수정 (struct -> struct node)
                ```

                ```swift
                typedef struct node
                {
                	int number;
                	struct node *next;  
                }
                node;

                // 1. 해당 자료구조의 모든 node struct는 number 변수와 next 포인터 변수로 구성되고,
                // 2. next 포인터는 node struct를 가르키도록 정의한다.

                -
                *참고 - 이렇게도 수정 가능
                typedef struct something
                {
                	int number;
                	struct something *next;  
                }
                node1; // node type의 struct에 대한 이름
                ```

    - 코딩 - 연결 리스트 구현
        - 2) 첫번째 node (number 및 next 필드)에 값 및 주소를 할당

            ```c
            #include <stdio.h>
            #include <stdlib.h>

            typedef struct node
            {
            	int number;
            	struct node *next;  
            }
            node;

            -
            int main(void)
            {
            node *list = NULL;  // list라는 node 포인터를 정의한다. 연결 리스트의 첫번째 node를 가르키는 기능이다. (초기값은 NULL로 지정)

            node *n = malloc(sizeof(node)); // 첫번째 node를 만든다. node 크기의 메모리를 할당하여 포인터 n에 넣어준다. (n은 node를 가르키는 포인터)
            if (n != NULL)  // n이 NULL이 아님을 체크 (예를 들어 메모리를 모두 사용중이면 할당 불가함)
            {
            n->number = 2;   // 첫번째 node의 number 및 next 필드에 값 및 주소를 할당한다. (*n).number 과 동일한 syntax
            n->next = NULL;  // 지금은 두번째 node가 없으므로 초기값은 NULL. (*n).next 과 동일한 syntax (다음 node가 없는 상황이므로 NULL 할당)
            }

            // (하단에 계속 추가)
            }
            ```

        - 3) list 포인터를 첫번째 node로 연결

            ```c
            list = n;  // n : 첫번째 node, 따라서 초기값이 NULL이었던 list는 이제 <첫번째 node 메모리 덩어리의 주소>를 값으로 가진다.
            ```

        - 4) 첫번째 node에서 두번째 node로 연결

            ```c
            // 두번째 node를 만들기 위해 n에 새로운 메모리를 재할당한다. (즉, n을 <임시변수>로 활용하여 새로운 메모리 주소를 가져오는 목적임) - ??? 새로운 변수를 선언해서 node를 만드는게 아니라?
            n = malloc(sizeof(node));  
            if (n != NULL) 
            {
            n->number = 3; 
            n->next = NULL;
            }

            // 임시 포인터 변수 tmp를 만들어 다음 주소를 가르킨다. (NULL을 찾을 때까지)
            node *tmp = list;  // tmp가 가르키는 곳을 list와 동일하도록 함
            while (tmp->next != NULL)  // while : (포인터가 가르키는 곳이 NULL이 아니다) 구문이 true이면 다음 코드를 실행
            {
            	tmp = tmp->next;  // tmp가 무엇을 가르키고 있든, 이제는 next 필드를 가르켜라 (자기 자신을 업데이트)
            }
            ```

            - [ ]  - ??? 새로운 변수를 선언해서 node를 만드는게 아니라?
        - 5) 참고 - list와 첫번째 node (number 값 2) 사이에 새로운 node (number 값 1)를 추가하고 싶다면?
        - 이때 기존의 list가 가르키는 주소를 먼저 바꾸면, 이후의 node를 추적할 수 없으므로
          새로운 node가 가르킬 주소를 먼저 지정해줘야 한다.

            ```c
            n = malloc(sizeof(node));  // 새로운 node를 만들기 위해 n에 새로운 메모리를 재할당한다.
            if (n != NULL) 
            {
            n->number = 1; 
            n->next = NULL;
            }

            n->next = list;  // 새로운 node가 가르키는 것을 기존 list (첫번째 node)와 동일하도록 함 (자기 자신을 업데이트)
            list = n;        // list가 가르키는 것을 새로운 node로 바꿔줌
            ```

        - 완성된 코드

            ```c
            #include <stdio.h>
            #include <stdlib.h>

            typedef struct node  //연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
            {
                int number;         //node 안에서 정수형 값이 저장되는 변수를 number로 지정합니다.
                struct node *next;  //다음 node의 주소를 가리키는 포인터를 *next로 지정합니다.
            }
            node;
            -

            int main(void)
            {
                // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫번째 node를 가리킬 것입니다. 
                // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
                node *list = NULL;

                // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가르킵니다.
                node *n = malloc(sizeof(node));
                if (n == NULL)
                {
                    return 1;
                }

                // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다.
                // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
                n->number = 1;

                // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
                n->next = NULL;

                // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
                list = n;

                // 이제 list에 두번째 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
                n = malloc(sizeof(node));
                if (n == NULL)
                {
                    return 1;
                }

                n->number = 2;
                n->next = NULL;

                // list가 가르키는 것은 첫번째 node입니다. 
                // 첫번째 node가 가르키는 것에 n (=두번째 node)을 할당합니다. (syntax) 
                list->next = n;  // list -> 첫번째 node -> 두번째 node 가 완성된 상태

                // 세번째 node를 연결하기 위해 n 에 다시 새로운 메모리를 할당합니다.
                n = malloc(sizeof(node));
                if (n == NULL)
                {
                    return 1;
                }

                n->number = 3;
                n->next = NULL;

                // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
                // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
                // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
                list->next->next = n;  // list -> 첫번째 node -> 두번째 node -> 세번째 node 가 완성된 상태

                // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
                // 마지막 node의 next에는 NULL이 저장되어 있으므로 이 것이 for 루프의 종료 조건이 됩니다.
                for (node *tmp = list; tmp != NULL; tmp = tmp->next) // 자기를 업데이트하는 방식 (list에서 시작해서 NULL 나올 때까지)
                {
                    printf("%i\n", tmp->number); // tmp가 가르키는 number 필드에 접근하여 출력함
                }

                // 메모리를 해제하기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
                while (list != NULL)
                {
                    node *tmp = list->next;
                    free(list);
                    list = tmp; // 자기를 업데이트하는 방식
                }
            }
            ```

            - [ ]  // 첫번째 node의 다음 node를 n 포인터로 지정합니다. ???
            list->next = n;

- Tree (트리) O(log n)
    - Tree : Linked List를 기반으로 한 새로운 data structure
    - 연결 리스트에서의 각 노드들의 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성되어 있다.
    - 가장 높은 층에서 트리가 시작되는 노드를 ‘루트 (root)’라고 합니다. 루트 노드는 다음 층의 노드들을 가리키고 있고, 이를 ‘자식 노드 (child node)’라고 합니다.
    - Array와 Linked List의 장점을 취함. ex) 가계도
    - 아래 그림의 트리는 구체적으로 ‘binary search 트리’ 입니다.
      각 노드가 구성되어 있는 구조를 살펴보면 일정한 규칙을 알 수 있습니다. 먼저 하나의 노드는 두 개의 자식 노드를 가집니다.
      또 왼쪽 자식 노드는 자신의 값 보다 작고, 오른쪽 자식 노드는 자신의 값보다 큽니다.
    - binary search 트리의 search 및 insert 실행시간 O(log n)
    - 재귀 (recursion)에 가장 적합한 방법 (data structure 그 자체가 재귀적이도록 만들 수 있음)

        ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2015.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2015.png)

    - 구현 - 트리에 있는 숫자 50을 재귀적으로 검색하는 binary search 기능

        ```c
        // binary search 트리의 노드 구조체 (포인터가 2개)
        typedef struct node
        {
        	int number;
        	struct node *left;   // 왼쪽 자식 node
        	struct node *right;  // 오른쪽 자식 node
        }
        node; 

        bool search (node *tree)  // tree 라는 node의 주소 (트리의 루트의 주소)를 받아서 search 한다. (Linked List는 첫번째 node부터 시작했듯이)
        {
        	if (tree == NULL) 
        	{
        		return false;
        	}
        	else if (50 < tree->number)  // 50 이 tree number보다 작다면 left를 search 해라.
        	{
        		return search (tree->left);
        	}
        	else if (50 > tree->number) // 50 이 tree number보다 크다면 right를 search 해라.
        	{
        		return search (tree->right);
        	}
        	else  // else ~~if (50 = tree->number)~~ 생략 가능
        	{
        		return true;
        	}
        }
        ```

        - [x]  // 왜 *tree == NULL 이 아니지?
            - tree == NULL 및 *tree == NULL는 동일함
            - n 에 메모리가 할당 안되면 n->number도 불가하다..!
- Hash Table (해시 테이블) ideal O(1), worst O(n)
    - Hash Table : 연결 리스트의 배열 (배열인데 그 안에 연결 리스트가 들어있는 구조)
        - 여러 값을 바구니에 나누는 상황. 각 값은 ‘해시 함수’를 통해 indexing (어떤 바구니에 담기는 지가 결정) 됩니다. 각 바구니에 담기는 값들은 그 바구니에서 새롭게 정의되는 연결 리스트로 이어집니다. 이와 같이 연결 리스트가 담긴 바구니가 여러 개 있는 것이 해시 테이블 입니다.
        - 해시 함수 : division method(분할 방법), multiplication method(곱셈 방법), digit folding(자릿수 접기), universal hashing(유니버설 해싱) 방법 등으로 만듦
        - ex) 해시 테이블에 저장되는 데이터가 '이름'이며, 해시 함수는 ‘이름의 가장 첫 글자’인 경우
        - 알파벳 개수인 총 26개의 포인터들이 생성되며 (세로로 26개의 Array - randon access 가능), 
          각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리킨다. (가로로 Linked List)
        - 만약 해시 함수가 이상적이라면, 최대한 많은 바구니를 만들어서 검색 시간은 ****O(1)이 됩니다.
        - 최악의 상황에는 하나의 바구니에 모든 값들이 담겨서 O(n)이 될 수도 있습니다.

            ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2016.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2016.png)

- Trie (트라이) O(1)
    - Trie : 각 node가 Array로 구성된 Tree 이다.
    - 장점 : search 실행시간이 '문자열의 길이'에 비례하므로 O(1)이다. (보통 이름이나 단어는 20자 이내의 문자로 구성되므로)
      *다른 data structure과 달리 '자료의 개수'와 상관 없다. (Harry가 속한 node들만 확인하므로)
    - 단점 : 메모리 소모가 크다
    - ex) 이름 (문자열 값)을 저장한다면, 이 node는 a-z의 값을 가지는 Array가 됩니다. 
    그리고 Array의 각 요소, 즉 알파벳은 다음 층의 node (a-z Array)를 가리킵니다.
    - Harry를 저장한다면, 루트의 H → child node 중 A가 없다면 새로운 node를 생성한다 → 반복하여 전체 알파벳을 저장함 (끝나면 green으로 표시)
      Hagrid, Harmone 과 적어도 2개의 node를 공유하므로 효율적이다.

        ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2017.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2017.png)

        ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2018.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2018.png)

- Stack (LIFO), Queue (FIFO), Dictionary

    ![Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2010.png](Harvard%20CS50%200e32dcfb8770467684a13302b0f3b0c8/Untitled%2010.png)

    - Queue (큐) : 값이 아래로 쌓이는 구조. 값을 넣고 뺄 때 ‘선입 선출’ 또는 ‘FIFO (first in first out)’라는 방식을 따른다.
    Array 또는 Linked List로 구현한다.
    - enqueue (get in line), dequeue (get out of line)
    - Stack : 값이 위로 쌓이는 구조. 값을 넣고 뺄 때 ‘후입 선출’ 또는 ‘LIFO (last in first out)’라는 방식을 따른다.
    Array 또는 Linked List로 구현한다.
    - ex) gmail inbox (메일함)
    - push (put an element on to the stack) & pop (remove the top of the element)
    - Dictionary : [key : value] 형태로 구성. ‘키’에 해당하는 ‘값’을 저장하고 읽어오는 것이다.
    일반적인 의미에서 ‘해시 테이블’과 동일한 개념이다.