# SNU 컴공개론학

Created: April 19, 2021 2:34 PM
Created By: hyoju son
Last Edited Time: July 11, 2021 11:55 PM
Property: 서울대_민상렬T
Type: CS

- Contents

    [https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K](https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K)

# 1. Bit, Data Type

- Digital System
    - Digital System : 표현하는 정보 심볼이 유한한 개수인 것이다. 
    그 중 심볼이 0,1만 있는 것이 Binary System이다. (0은 0~0.5V, 1은 2.4~2.9V-Volts) Computer는 binary digital system이다.
    - 정보의 기본 단위는 Bit (Binary Digit)이다.
    - 컴퓨터에서 취급할 데이터는 instruction (operation 대상), number, logical (bool), text (string), image (pixel) 등
    - PC = 메모리 (주소마다 binary data가 들어있음), CPU (Processor, Program Counter-다음에 수행해야할 instruction의 주소가 들어있음)
    *instruction : 어떤 주소에 있는 값을 연산하여 결과값을 어떤 주소에 할당해라 등이 해당된다. 다음에 실행될 instruction을 지정한다.
- Number
    - Two's Complement
        - 0의 표현방법이 2개임 (+0, -0)
        - solution : X + (-X) = 0을 성립시키는 -X의 값을 기준으로 함
        1's Complement + 1 (???)
    - Overflow
        - If operands(피연산자) are too big, then sum cannot be represented as an n-bit 2's comp number.
        - 실제로 2진수 연산과정에서 양수+양수=음수, 또는 음수+음수=양수 등 비정상적인 결과값이 나온다!
    - Fractions (소수)
        1. Fixed-Point : ex) 0.00000001. 단점은 0000...을 표현하기 위해 메모리 소모가 크다.
        2. Floating-Point : ex) F x 2^E (F: fraction, E: exponent-지수)
- 요약
- 메모리의 내용은 단순히 0,1의 패턴이다.
- 그것을 Program Counter가 가르키고 있으면 instruction으로 해석된다. ???
- 이 instruction은 서로 다른 메모리 주소에 있는 데이터를 참조하는데, 그 instruction이 integer로 간주하면 해당 데이터는 integer가 된다. (instruction에서 처리하는 데이터 타입은 integer, bit vector, floating point number, character 등이 있다.)
- 나머지 string, image, sound 등은 하드웨어에서 지원하는 내용 (RGB 등 입출력 장치의 해석)에 따라 지정된다.

# 2. Digital Logic Structure

- Memory
    - 메모리에는 몇 개의 칸 (locations)이 있고, 각 칸은 주소를 가진다. 
    메모리의 주소에 데이터를 저장한다.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png)

        - Address Space : 칸의 개수 (m개 bit로 구성된다고 가정하면 2^m 맞나??)
        - Addressability : 한 칸당 bits의 개수 (m개)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png)

    *참고 - CS는 2의 power를 자주 사용한다. 
    단위 k : 2^10 (1024, 원래는 1000), M : (2^10)*(2^10), G : (2^10)*(2^10)*(2^10)

- RAM (Random Access Memory)
    - 카세트 테이프와 달리 원하는 위치에 바로 접근이 가능하다.
    - DRAM (Dynamic) - PC의 메모리. slower but denser, bit storage decays. must be periodically refreshed.
    - SRAM (Static) - fast, maintains data as long as power applied.
    - DRAM, SRAM 모두 Volatile memory이다. (전원이 끊기면 모두 날아간다.)
    *non-Volatile memory : flash 메모리 (USB, SDD)
- 요약
- Levels of abstraction.
- MOS Transistor를 통해 CMOS gates (inverter, NAND/AND, NOR/OR)를 만들었다.
   - Combinational circuit - 그를 바탕으로 Decoder, Mux, Adder, PLA 등을 만들었다. 
   - Sequential circuite - 그를 바탕으로 R-S latch, Gated D latch를 만들고, Register, Memory를 만들었다.
   - Combinational/Sequential circuit의 building block을 이용하여 Finite State Machine을 만들었다.
- CMOS circuits (N,P 타입 반도체...)

# <Hardware>

# 3. Von Neumann Model (컴퓨터 구성)

- 1940년대 개발된 최초의 괜찮은 컴퓨터 (현재와 구성이 유사함)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png)

    - Memory

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png)

    - Processing Unit
        - Register : Processing Unit에서 operation을 수행할 때 필요한 데이터나 결과값을 임시로 저장할 저장공간 (temporary storage)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png)

    - I/O

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png)

    - Control Unit
        - PC를 통해 다음 실행될 instruction의 주소를 메모리에서 가져오고, 작업을 실행하기 위해 판단한다.
        - IR (Instruction Register) : 현재 instruction 자체를 가짐
        - PC (Program Counter) : 다음 instruction의 주소를 가짐

        *instruction : processing의 기본 단위. 연산, 데이터 이동 (Memory↔Register), 제어 등의 종류가 있다.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png)

# 4. LC-3

- ISA (Instruction Set Architecture)
    - specifies all of programmer-visible state (memory organization, register set) and operations (opcode, data type, addressing mode).
    - hardware (하드웨어 구현 시 필요한 모든 정보), software (머신러닝 개발을 위해 필요한 모든 정보)의 interface

# 5. Assembly Language

- Assembler : symbolic representation을 binary representation으로 바꿔주는 프로그램

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png)

    - Assembly language is "translated (동일한 기능으로 번역됨)" into machine language (object code) by two-pass assembler, whereas instructions in machine language are "interpreted (해석되어 실행됨)" by hardware.

# 6. I/O

- 어떻게 외부 데이터가 메모리로 들어오고, 메모리의 데이터가 외부로 나가는지
- Device
    - input device는 키보드, 마우스 등, output device는 모니터 등, 둘다 해당되는 것은 USB
    - I/O Controller
    - Control Register : CPU가 device에게 시킨 작업에 대해 필요한 명령이나 파라매터를 전달해줌 (write)
    - Status Register : device의 상태를 CPU에 보고함 (read)
    - Date Register : 데이터를 전달함 (메모리↔device)
    - Device Electronics : 실제 동작을 실행함. pixel to screen, bits to/from disk, characters from keyboard
    - Programming Interface
        - identify device register - Memory-mapped / special I/O instructions
        - 주로 Memory-mapped가 사용됨
        - transfer timing - Asynchronous (비동기적) / synchronous (동기적)
        - 대부분 비동기적. device가 보낼 데이터가 있는지 확인하거나 데이터를 받을 상태가 되었는지 확인하는 작업을 거침 (synchronizing, handshaking)
        - 동기적 : 일정 주기로 동일한 양의 데이터를 계속 device로 보내거나 받는 경우
        - transfer control - CPU (Polling) / device (interrupts)
        - 데이터 전달을 언제 실행할지 결정하는 방법
        - 대부분 Polling을 지원함
        - Polling : CPU keeps checking status register until new data arrives or device ready for next data.
        - Interrupt : Device needs a special signal to CPU when new data arrives or device ready for next data. (CPU가 그동안 다른 작업을 수행함. priority로 판단함)

# 7. Trap Routines, Subroutines

- OS (Operating System)이 관여하는 경우
    - system calls (via TRAP instruction)
    - Interrupts
    - Exception
- Subroutines
    - invoked via JSR or JSRR instruction (return address in R7)
    - arguments, return values, need to save/restore registers

# 8. Stack

- Stack은 Abstract data type이다. (Abstract : 내부 구현에 대한 자세한 내용은 감추고, interface를 통해 해당 자료구조를 buidling block으로 사용하는 것이다.)
- LIFO (last-in, first-out) 저장 구조이다.
- Main Operation은 Push&Pop이다. Push는 새로운 아이템을 stack에 더하는 것, Pop은 stack으로부터 아이템을 꺼내는 것이다.
- 메모리에서 stack의 구조

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png)

---

# <Software>

# 9. Programming in C

- C언어 : High-Level Language
    - System programming (Windowx, UNIX 등) 개발에도 사용된다.
    - 값을 담는 container에 symbolic name (변수명)을 부여 가능하다. 
    C 컴퍼일러가 변수를 memory에 옮기거나, 임시로 register로 옮기는 등의 작업을 해준다. (기존의 Assembly Language나 Machine Instruction은 register or memory location에 값을 저장한다. C는 register or memory location을 몰라도 된다.)
    - underlying ??? hardware에 대해 abstraction을 지원한다. (machine language의 High-Level abstraction을 제공한다.)
    operation은 instruction set architecture와 별개로 작동한다.
    - 변수 (register, memory location에 대한 abstraction)
    - operation (arithmetic, logic instruction에 대한 abstraction)
    - control structure (branch, jump instruction에 대한 abstraction)
    - 표현력이 풍부하고, 가독성 있음, 버그에 대한 safeguard 지원 (규칙을 enforce하도록 가이드 제공)한다.
- Translating High-Level Language
    1. Interpretation (실행을 위한 해석. 실제 machine instruction이 실행되는 것)
        - executes program statements
        - generally one line/command at a time, 전체 구조를 파악하지 않으므로 효율성이 낮음
        - debug, 변경, 중간결과 확인이 쉬움 (statement 단위로 수정 가능하므로)
        - 언어 - BASIC, LISP, Perl, Matlab, C-shell
    2. Compilation (High Level Language를 Machine Language로 전환)
        - High Level Language의 전체 statement를 machine language로 traslate 함 (실행하는게 아니라 executable program을 생성함)
        *CS50 - Asembly code를 object code로 변환하는 것은 어셈블 (Assemble) 단계
        - 전체 구조를 파악하고 있으므로 최적화 기회가 많고, 효율성이 높음
        - 변경 시 compilation을 다시 해야 함. debug가 어려움
        - 언어 - C, C++, Fortran, Pascal
    3. Interpretation&Compilation의 Hybrid
        - Java
        - Java language는 JVM (Java Virtual Machine) byte code로 컴파일된다.
        - JVM byte code는 1) interpreted 되어 실행되거나, 또는 2) native machine code로 compile되어 실행된다. - JIT (Just in Time, 코드가 실행될 때 컴파일) 또는 AOT (Ahead of Time, 코드가 실행되기 전에 컴파일) 컴파일러에 의해
        - Python
        - Python 프로그램은 byte code (Java Language 등)으로 converted된다. - PVM (Python Virtual Machine) for CPython, JVM for Jython에 의해
        - byte code는 native machine code로 interpreted 또는 compile된다. - JIT (Just in Time) 또는 AOT (Ahead of Time) 컴파일러에 의해
    - 예시

        ```swift
        func getZ (W: Int) {
        		X = W + W
        		Y = X + X
        		Z = Y + Y
        		print("Z")
        }

        라는 코드가 있을 때,
        1. interpreting하면, 한 줄씩 실행하여 Z를 계산한다.
        2. compile하면, 전체 코드를 분석하여 Z = 8W로 최적화하고 Z를 계산한다.
        ```

- Compiling C

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png)

    - Pre-processor
    - macro substitution
    - conditional compilation
    - source-level transformations (output is still C)
    - Compiler
    - generates object file (machine instruction)
    1) Source Code Analysis
        - Front-end, parses programs to identify its pieces (변수, 함수 등). C언어 코드를 분석해서 어떤 문법적 구조를 가지는지 파악함
        - depends on language (not on target machine)
    2) Code Generation
        - Back-end, generates machine code from analyzed source
        - may optimize machine code
        - depends on target machine (특정 instruction set architecture에 따라 machine code, machine instruction이 되므로)
    3) Symbol Table
        - map between symbolic names and items
        - Assembler의 Symbol Table과 유사하지만 보다 다양함
    - Linker
    - combine object files (including libraries) into executable image
    - 예시

        ```c
        #include <stdio.h> // 1) # : pre-processor에 의해 처리됨
        #define STOP 0 // 2)

        // description : counts down from user input to STOP
        main () // 3) function : main
        {
        		int counter; // 4) 변수 선언
        		int startPoint;

        		printf("Enter a positive number: "); // 5) prompt user for input (prompt를 통해 user에게 보여준다)
        		scanf("%d, &startPoint"); // 6) read into startPoint (user가 입력한 값을 read해서 startPoint 변수에 할당) *scanf : 변수 값을 input 받음

        		for (counter = startPoint; counter >= STOP; counter--)
        			printf("%d\n", counter); // 5) count down and print count 
        }
        ```

        1) pre-processor 단계로 해당 파일의 소스코드를 가져와서 대체한다.
            - Before compiling, copy contents of header file (stdio.h) into source code.
            - header file은 보통 상수, 변수, 함수 정의 등을 포함한다.
        2) pre-processor 단계로 String STOP을 String 0으로 대체한다.
            - Before compiling, replace all instances of the String "STOP" with the String "0"
            - Called as macro (macro substitution)
            - 실행하는 동안 변경되지 않는 값에 사용된다. 단, 프로그램이 reused될 때는 변경될 가능성이 있으므로 recompile해야 함
        3) 프로그램을 run하면 실행되는 함수이다.
        4) 변수를 선언한다.
             - symbolic name : counter, 값을 담을 컨테이너의 type : int 
               (data type을 컴파일러에 전달하여 얼마만큼의 공간을 할당할지 등을 interpret한다.)
        5) Output
            - String contains characters to print and formatting directions for variables. (변수 값을 어떤 type으로 출력할지)
            - 변수 counter를 %d (decimal integer) type으로 출력한다. 그리고 linefeed (\n)를 출력한다.
            - 예시) printf("%d %d\n", counter, startPoint - counter); // 변수 외에도 연산 값을 출력 가능하다.
            *formatting options - %x (hexadecibal integer), %c (ASCII character), %f (floating-point number)
        6) Input
            - String contains formatting directions for looking at input. 
            - %d type의 값을 read하여 변수 startPoint에 할당한다.
            - & (Ampersand)를 사용한다. (Pointer에서 설명)

# 10. *Variable, Operator

- 변수
- holds a value upon which a program acts
- an abstraction (즉, symbolic name) of a memory location, but its value is moved to a register when subject to an operation and moved back to memory when registers are full
   (실제 연산을 할 때 값이 memory에서 register로 이동함)
- 변수, 상수, 연산자 등으로 표현된 Expression은 연산을 통해 value를 구하며 (evaluate to a value), type을 가짐 
   (할당연산자 '='도 1) 할당 action을 수행하면서, 2) value를 가지며 해당 값은 "연산의 결과로 할당되는 값"임. C의 특징)
- Expression의 결과값을 area에 할당하는 것은 Statement임 (작업의 단위;)
   - simple statement `a = b + 1;`
   - compound statement `{ a = b + 1; b = c * d; }`
    - Scope
    - Compiler infers scope from where variable is declared. (컴파일러는 변수가 선언된 위치에서 범위를 추론한다.)
    - Global : accessed anywhere in program. declared outside of all blocks
    - Local : only accessible in a particular region. Variable is local to the block {} in which it is declared.
- 연산자
- predefined actions performed on values
- an abstraction of arithmetic/logic instructions
- 논리연산자 : Bool type의 결과값을 Int로 표현 (0=false, 1=true) 단, 피연산자를 취급할 때 0=false, 0외 모든 값=true로 인식함 (C의 특징)
- Precedence (우선 순위)
   - 연산자 우선순위는 */%이 6이고, +-이 7임 (숫자 적을수록 우선순위 높음)
- Associativity (결합 법칙)
   - Assignment associates right to left. (할당연산자의 결합 법칙은 우에서 좌임) 따라서 `y = x = 3;` 의 의미는 `y = (x = 3);`과 동일함 (3을 x에 할당하고, x를 y에 할당)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png)

- Symbol Table
- 컴파일러는 변수 관련 정보를 저장한다. (변수명, type, memory location (Offset), scope)
- 로컬변수 Storage (YT 50min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png)

    - 로컬변수는 user stack (activation record, stack frame)에 저장된다.
    - main 함수에 변수가 할당되면, memory의 stack 바닥부터 쌓인다. (main 함수의 stack 크기가 늘어난다.) 만약 다른 함수를 정의하면서 변수를 선언하면, 선언 순으로 stack에 그대로 쌓인다. 
    - main 함수가 호출되면, activation record가 stack에 쌓인다. ???
    *(12. Function 참고) activate record : procedure가 한 번 수행되기 위해 필요한 정보는 memory의 연속 블록을 사용하여 관리하는데, 이때 연속 블록을 의미함. 지역변수 및 그외 프로그램 수행에 필요한 정보.
    The activation record is temporary - it is allocated when the function is called (becomes active) and it is deallocated when the function returns (becomes inactive). Once an activation record is deallocated, the memory it occupied is available for use when new activation records are created.
    - Symbol Table "Offset"은 the base of the frame으로부터의 거리를 나타낸다.
    - R5 is the frame pointer. R5 holds address of the base of the current frame. (the base of the activation record)
    - A new frame is pushed on the run-time stack each time a function is called or a block is entered.
    - bc stack grows downward, R5 contains the highest address of the frame (*주의-frame base로 내려갈수록 address는 높아짐. 즉, 그림 상 위로 쌓는 형태로 보이지만, 실제로 변수가 할당되면 아래 방향의 메모리가 할당되면서 Stack이 아래로 늘어남), and variable offsets are <= 0. 
      (offset : R5가 가르치는 곳이 0, 그 윗칸부터 올라갈수록 -1, -2 ... -5가 됨)
- 프로그램 실행 시 memory (YT 55min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png)

    - Instructions 
    - 현재 실행되는 instruction은 PC (Program Counter)가 트래킹하고 있다.
    - Global data section
    - 모든 글로벌 변수가 저장된다. (엄밀히는 모든 static 변수)
    - R4는 beginning (시작 주소)을 가르킨다.
    - Run-time stack
    - 로컬변수 사용에 활용된다. (엄밀히는 automatic 변수)
    - R6는 top of stack (stack 최상단)을, R5는 top frame on stack (the base of the current frame, 현재 함수의 frame base) 을 가르킨다.
    - 개별 block에 new frame이 주어진다. (block exit, 즉 메모리가 free되면 사라진다.)
    *변수 선언 시 static이 없으면 automatic 변수이다. 해당 block에 들어가면 메모리가 allocate되고, block에서 나가면 free 된다.
    반면, static이 있으면 static 변수이다. block에 들어가고 나가는 것과 무관하게 프로그램 시작 시 allocate되고, 프로그램 종료 시 free 된다.
    ⇒ 따라서 'static 로컬변수'는 로컬변수이지만 Stack이 아니라 Global에 할당된다.
    - Offset : 저장공간의 시작점으로부터의 거리이다.
    - Global : LDR R1, R4, #4 // Global의 R4를 기준으로 access함
    - Local   : LDR R2, R5, #-3 // Stack의 R5를 기준으로 access함
- Variable & Memory Location
    - 변수는 항상 메모리에 저장된다.
    - 어떤 변수가 할당되면, memory location에 저장된다. 
    - instruction 수준에서는 store operation을 진행한다. (컴파일의 결과로 생성되는 instruction)
    - 컴파일러는 코드 최적화를 위해 변수를 register에 할당하려고 한다. 왜?
    - +, && 등 operation을 하려면 값이 (임시로라도) register에 있어야만 연산이 가능하다.
    - 성능 측면에서 register를 참조하는 것이 memory를 참조하는 것보다 더 빠르다.
    - 따라서 컴파일은 보통 메모리에 home location이 있고, 필요에 따라 (연산을 하거나 빠른 access가 필요할 때) register에 임시로 값을 이동시키는 최적화 작업을 수행한다.

# 11. Control Structure

- row level language - 보통 machine instruction은 sequential 하게 수행되고, conditional branch 또는 jump instruction에 의해 non-sequential하게 수행되기도 한다.
- high level language - Sequence, Conditional, Iterarion 등의 Control Structure가 있다.

1. Condition
    - `if (condition) action;`
    - condition : C expression, action : C statement;

        ```c
        if (x <= 10) {
        y = x + 1; // condition이 true이면 action (2개 statement)이 실행됨
        z = y + 1;
        }

        if (x <= 10) // {}가 없으면 condition 뒤의 1개 statement만 if문 소속으로 인식됨
        y = x + 1; // condition이 true이면 action (1개 statement)이 실행됨
        z = y + 1; // condition과 상관없이 항상 실행됨

        ```

    - `switch (expression) {caseconst1: action1;break;caseconst2: action2;break;default:action3;}`
    - break를 각 case에 추가하는 것이 바람직함. break가 없으면 const1 조건을 만족할 경우, case1에서 종료되지 않고 case2, default로 넘어가서 모두 실행되기 때문 (C의 단점)
    - const1을 만족하면 action1을 실행하고 종료, const2를 만족하면 action2를 실행하고 종료, 위의 모든 조건에서 false이면 default를 실행하고 종료 (break가 있으므로)
        - break
        - used only in switch or iteration statement
        - *passes control out of the smallest statement (loop or switch) containing it to the statement immediately following (break를 포함하는 실행문 (반복문 또는 switch문)의 제어를 바로 다음 실행문 (해당 반복문 또는 switch문 외부)으로 전달한다.)
        - usually used to exit a loop before terminating condition occurs (or to exit switch statement when case is done)
        - continue
        - used only in iteration statement
        - *terminates the execution of the loop body for this iteration (반복문의 해당 iteration의 실행문을 즉시 종료하고, 다음 iteration으로 넘어간다.)
        - loop expression is evaluated to see whether another iteration should be performed
        - if 'for loop', also executes the re-initializer (for문이면 re-initializer를 실행한 이후, 다음 iteration으로 넘어간다.)

            ```c
            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) continue;
            		printf("%d ", i);
            }
            // if문이 true이면 다음 iteration을 실행함 -> 20 이하의 홀수가 출력됨

            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) break;
            		printf("%d ", i);
            }
            // i = 0인 첫번째 iteration에서 break -> *for문 자체를 종료함
            ```

2. *Iteration
    - `while (test) loop_body;`
    - Executes loop_body as long as test evaluates to True (non-zero).
    - `for (init;test;re-init) statement;`
    - Executes loop_body as long as test evaluates to True (non-zero). Initialization and re-initialization code include in loop statement.
    - `init;while (test) {statement;re-init}` 구조와 동일하다.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png)

        ```c
        // Nested Loops

        for (mp1 = 0; mp1 < 10; mp1++) {      // 1) mp1 = 0이 먼저 들어가고
        		for (mp2 = 0; mp2 < 10; mp2++) {  // 2) mp2가 0에서 9까지 돌고나서, (다시 mp1 = 1이 들어가고, mp2가 0에서 9까지 돌고나서 ... 반복)
        				printf("%d\t", mp1 * mp2);
        		}
        		print("\n")
        } // prints a multiplication table.

        for (outer = 1; outer < 10; outer++) {
        		for (inner = 0; inner < outer; inner++) {  // outer 변수에 따라 내부 for문의 실행횟수가 결정되는 구조
        				sum += inner;
        		}
        }
        ```

    - For Vs. While
        - For loop : counter-based loop에 적합하다. (ex. 5번 count 동안 실행해라)
        - While loop : sentinel (보초병)-based loop에 적합하다. (ex. 특정 조건 동안 실행해라)
- Problem Solving in C
    - Stepwise Refinement 
    - machine instruction을 이용하면 machine language까지 내려가야 problem solving이 가능하지만,
       C에서는 C언어 자체로 problem solving이 가능하므로 작업이 쉽고 생산성이 좋다.

# 12. Function

- 장점
    - 자주 쓰는 기능을 subcompoment로 만든다. 이를 통해 compositional design이 가능하다.
    - 작업에 대한 abstraction을 지원한다.
    - hides low-level details (input, output 관계만 알면 사용 가능하다. 내부적으로 어떻게 구현이 되는지는 숨겨준다.)  
    - gives high-level structure to program, and make it easier to understand overall program flow
    - C Function
    - zero or multiple arguments passed in
    - single result returned (optional-output이 없는 경우도 있다.)
    - 다른 언어에서는 procedure, subroutine으로 부른다.
- Declaration & Call & Definition
    - [x]  왜 parameter가 선언할 때는 1개인데, 호출할 때는 2개가 들어가지?
        - f+g의 결과값이 parameter n의 argument로 전달된다.

    ```c
    // Declaration
    int Factorial(int n;) // prototype
    // 차례로 return type, Function Name, types/number of all arguments

    // Call (Invocation)
    a = x + Factorial(f + g) // 1) evaluate argument, 2) evaluate function, 3) use return value in expression.

    // Definition - 함수 구현과 관련된 low-level detail
    // - Declaration 내용 (State type, name/types of arguments 등)과 일치시킨다. (argument name을 동일하지 않게 부여 가능하지만, 비효율적이다.)
    int Factorial(int n) {
    		int i;
    		int result = 1;

    		for (i = 1; i <= n; i++)
    				result = result * i;

    		return result; // 값을 반환하고, gives control back to calling function (control은 함수 호출 지점으로 되돌아간다.)
    }  
    ```

    - Declaration이 필요한 이유
        - Definition 이전에 함수를 사용 가능하다. (C 특징)
        - 컴파일러는 return type, argument type/number를 알아야 한다.
        - Definition이 다른 파일에 들어있거나, 다른 개발자에 의해 작성된 것일 수 있다.
        - include a "header file" with function declarations only (함수 선언이 들어있는 헤더파일을 포함시킨다. 개별적으로 컴파일하고, 최종 실행 전에 link 해야 한다.)
- Implementing Function (YT 16min)
    - 함수 호출 시, 어떻게 machine instruction 수준에서 구현하는지

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png)

    - *Activation Record
    - 함수 정보 (argument, return value, 로컬변수 등)는 activation record에 담겨있다. (언제 생성??? 함수 선언 시? or 호출 시?
    - 함수가 호출될 때마다 해당 함수의 activation record가 run-time stack에 allocate된다.
    - 함수 Call 및 Return의 과정 🌴🌴🌴
    - 어떤 함수가 호출되면, 해당 함수는 Callee이고, 해당 함수를 호출한 지점은 Caller이다.
    1. Caller가 argument를 전달하기 위해 argument의 값을 복사해서 activation record에 push한다.
    2. Caller가 함수를 호출한다. 
    3. Callee는 자기 함수의 로컬변수를 allocate한다. (로컬변수를 포함한 activation record를 stack에 allocate한다. ???)
    4. Callee는 코드를 실행해서 return value를 구하고, return 값을 activation record의 해당 위치에 넣는다.
    5. Callee는 사용이 완료된 로컬변수를 free하고, 함수를 return 한다. ???
    6. Caller는 activation record에서 return값을 꺼내어 사용한다.
        - Argument values : allocated, set up, free - by Caller
        Return value : allocated, set up - by Callee / used, free - by Caller
        Return address : allocated, set up, free - by Callee
        dynamic link : allocated, set up, restore, free - by Callee
        local variables (엄밀히는 automatic variables) : allocated, set up, free - by Callee
    - (정리) Run-time Stack
    - *로컬변수는 run-time stack in an activation record에 저장된다.
    - 함수가 호출될 때마다 해당 함수의 activation record가 run-time stack에 allocate된다.
    - R5 (frame pointer)는 the beginning of a region of activation record (현재 함수 관련 로컬변수가 저장되어 있음)를 가르킨다.
    - 새로운 함수가 호출되면, activation record가 stack에 push된다.
       해당 함수가 return되면, activation records는 stack에서 pop off된다. 
       (함수 호출 및 return 과정이 LIFO이므로 activation record를 효율적으로 allocate/free 시킬 수 있다.) ???
        - *예시1 - 코드가 실행될 때 stack의 구조

            ```c
            int main() 
            {
            	int a; // 0. stack에 로컬변수가 allocate 됨
            	int b;
              // ...
            	b = Watt(a); // 1. Main 함수가 Watt 함수를 호출
            	b = Volta(a,b); // 5. Main 함수가 Volta 호출
            } // 7. main return

            int Watt(int a)
            {
            	int w; 
              // ...
            	w = Volta(w,10); // 2. Watt 함수가 Volta 함수를 호출
            	return w; // 4. Watt return -> 1
            }

            int Volta(int q, int r)
            {
            	int k;
            	int m;
              // ...
            	return k; // 3. Volta return -> 2 / 6. Volta return -> 1
            }
            ```

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png)

            1. (첫번째 그림) Main 함수가 실행되면, R5는 로컬변수 (a,b)의 base (최상위 주소)를 가르킨다. (로컬변수가 2개이므로 R5가 위에서 2번째를 가르킴) - 0. stack에 로컬변수가 allocate 됨
            R6는 stack 최상단을 가르킨다. 
            2. (두번째 그림) Main에서 Watt를 호출하고, Watt 함수가 실행되면, Watt의 activation record가 push된다. - 1. Main 함수가 Watt 함수를 호출
            R5는 로컬변수 (w)의 최상위 주소를 가르킨다. (로컬변수가 1개이므로 R5가 위에서 1번째를 가르킴) 
            R6는 stack 최상단을 가르킨다. 
            3. (세번째 그림) Main에서 Volta를 호출하고, Volta 함수가 실행되면, Volta의 activation record가 push된다. - 2. Watt 함수가 Volta 함수를 호출
            R5는 로컬변수 (k,m)의 최상위 주소를 가르킨다. (로컬변수가 2개이므로 R5가 위에서 2번째를 가르킴) 
            R6는 stack 최상단을 가르킨다. 

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png)

            4. (네번째 그림) Volta가 return하면, stack에서 free된다. (return control to Caller and pop) - 3. Volta return -> 2 
            5. (다섯번째 그림) Watt가 return하면, stack에서 free된다. - 4. Watt return -> 1
            6. (여섯번째 그림) Main에서 Watt를 호출하고, Watt 함수가 실행되면, Watt의 activation record가 push된다. - 5. Main 함수가 Volta 호출
                R5는 로컬변수 (w)의 최상위 주소를 가르킨다. (로컬변수가 1개이므로 R5가 위에서 1번째를 가르킴) 
                R6는 stack 최상단을 가르킨다. 
            7. (다시 다섯번째 그림) Volta가 return하면, stack에서 free된다. - 6. Volta return -> 1
            8. Main이 return하면, stack에서 free된다. - 7. main return
                이때 R5는 Main 함수를 호출한 System 초기화 routine???에서 로컬변수의 최상위 주소를 가르킨다.
                R6는 Main 아래줄 (stack 최상단)을 가르킨다.

            - 참고 - LC-3의 함수 호출 Implementation
                1. Caller pushes arguments (last to first)
                2. Caller invokes subroutine (JSR)
                3. Callee allocates return value, pushes R7 and R5
                4. Callee allocates space for local variables
                5. Callee executes function code
                6. Callee stores result into return value slot
                7. Callee pops local vars, pops R5, pops R7
                8. Callee returns (JMP R7)
                9. Caller loads return value and pops arguments
                10. Caller resumes computation
        - *예시2 - 코드가 실행될 때 activation record의 구조

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png)

            - 함수 FName을 호출하면, 그림과 같이 activation record이 생성된다.
            - 그림 상 아래부터 차례로 argument, return value (값을 구할 때까지 비워둠), return address, dynamic link (해당 함수를 호출한 Caller의 R5값), 로컬변수 순으로 locate된다.
            이때 R5는 로컬변수 중에서 최상위 주소를 가르킨다. R6는 stack 최상단을 가르킨다.
                - Offset은 R5를 기준으로 위쪽에 있으면 (-), 아래쪽에 있으면 (+) 값이다.
                즉, R5가 w를 가르키므로 w,x,y = 0, -1, -2 / a,b = 4,5 
                (Offset이 있으므로 load register 또는 store register를 통해 activation record의 각 요소에 모두 접근가능하다.)
                - Bookkeeping을 위한 3가지 요소
                - return value : space for value returned by function. return값이 없더라도 allocate 한다.
                - return address : 해당 function이 return하면 되돌아갈 주소. save pointer to next instruction in calling function. (convenient location to store R7 in case another function (JSR) is called. 다른 함수가 호출되면 주소가 사라지므로)
                - dynamic link : 해당 함수를 호출한 Caller의 R5값. FName이 return하면 해당 R5값을 다시 restore해야 하기 때문! caller's frame pointer. used to pop this activation record from stack

# 13. Testing/Debugging

- Debugging with high-level language
    - Debugging 측면에서 machine language와 high-level language은 목표가 동일하며 큰 차이가 없다.
    - Examine and set values in memory. 메모리의 값을 읽어본다. 값을 세팅해본다.
    - Execute portions of program. 프로그램 일부를 실행해본다.
    - Stop execution when/where desired. 원하는 시점/위치에서 프로그램을 중지해본다.
    - high-level language에서는
    - Examine and set variables (abstraction-memory location이 아니라 variable)
    - Trace, single-stepping and set breakpoints on statements, function calls (instruction이 아니라)
    - 필요 시 low-level tool도 사용한다.
- Error Type
    - Syntactic Error 
    - 문법적 오류. Input code is not legal
    - Caught by compiler
    - Semantic Error
    - legal code, 개발자가 의도하지 않은 방향으로 구현됨
    - 해결하기 어려우며 debugging tool이 필요함
    - Algorithmic Error
    - 프로그램 logic의 문제. 문제해결을 위한 개발자의 의도가 틀림
    - ex. Y2K bug (only allow 2 digits for year, assuming 19__)
- Testing
    - 실제 input을 주고, 그 결과를 관찰/확인하는 작업이다. 모든 경우의 수를 고려하는 것은 현실적으로 불가하다.
    - Black-Box Testing : program internals에 대해 아무것도 가정하지 않고, 임의의 input을 주는 방식. replies upon input/output specification. 자동화가 용이하나 경로가 한정됨
    - White-Box Testing : test coverage를 증가시켜 보완한 방식. 다양한 경로를 확인함. 필요 시 assertation을 사용함
- Debuggin Techniques
    - 주먹구구식 - Ad-Hoc
    - Insert printf statements to track flow and values
    - code explicitly checks for values out of expected range
    - Tool 사용 - Source-Level Debugger
    - Examine and set variable values
    - Tracing, breakpoints, single-stepping (ex. cloud9)
        - breakpoints
        - stop when a particular statement is reached (잠시 멈췄다가 진행 가능한 suspend의 개념) 함수의 entry 또는 exit에서 보통 stop하여 확인함
        - conditional breakpoint : stop if a var is equal to a specific value
        - watchpoint : stop when a var is set to a specific value
        - single-stepping
        - execute one statement at a time (단, '다음 stop (statement)'를 무엇으로 잡는지 기준이 필요)
        - step into : next statement is first inside function call (다음 stop은 호출된 함수의 첫번째 statement임)
        - step over : execute function without stopping (function 전체는 무시하고, function 바로 뒤의 statement가 다음 stop임)
        - step out : finish executing current function and stop on exit (현재 함수를 실행하고, exit 부분 (return 부분)이 다음 stop임)
        - Displaying Values
        - show value consistent with declared type of variable
- Programming for Correctness
- 애초에 프로그래밍할 때 정확히하는 것이 중요하다.
- Accurate Specificatiton, Modular Design (큰 문제를 작은 문제들로 쪼갠 Module을 만들고, module들을 componential하게 조합하여 프로그램을 구성) Defensive Programming (comment를 통한 documentation, consistent coding style, avoid global var)

# 14. Pointers, Array

- Pointer
    - 메모리에 있는 변수의 주소를 담고 있는 type이다.
    - allows us to indirectly access variables with their address (we can talk about their address rather than their value)
    - 주소가 필요한 이유 (YT 7min, 참고-CS50 Memory 1hr 10min)

        ```c
        // The function is supposed to swap the values of its arguments
        void swap(int firstVar, int secondVar)  // argument
        {
        	int temp = firstVar;
        	firstVar = secondVar;
          secondVar = tempVar;
        }

        int main(void)
        {
        int valueA = 3;
        int valueB = 4;
        swap(valueA, valueB)  // 함수 호출 - 하지만 실제로 valueA/B가 swap 되지 않음
        }
        ```

        - Swap 함수 호출 시 Stack

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png)

            - 함수 실행 이전
                - Caller (main 함수)의 로컬변수 valueA, valueB (argument 복사값 3,4)가 main의 AR 상단에 allocate 된다.
                - Caller의 로컬변수 valueA, valueB의 복사값 3,4가 Callee (swap 함수)의 argument firstVar, secondVar로 전달된다.
                - Callee의 argument (로컬변수X) firstVar, secondVar가 swap의 AR 하단에 allocate 된다. (엄밀히 호출 이후에 allocate 됨)
                또한 로컬변수 temp가 swap의 AR 상단에 allocate 된다.
                *AR (Activation Record)
            - 함수 실행 이후
                - 함수가 실행되면 swap의 argument firstVar, secondVar의 값이 swap 된다.
                실행이 완료되면 함수가 return 되고 AR이 pop 된다. (return type은 void임)
                - 의도했던 main의 로컬변수 valueA, valueB은 swap되지 않는다.
                - 결론적으로 Swap needs address of variables outside its own AR
            - 참고-CS50
            - 아랫줄이 main 함수, 윗줄이 swap 함수 stack frame이다.

                ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png)

- Array
    - a mechanism to group multiple elements of a homogeneous type
    - its element allocated sequentially in memory
    - ex. a[5] : declaration of an Int array with 5 elements

# 15. Recursion

# 16. I/O in C

# 17. Data Structure