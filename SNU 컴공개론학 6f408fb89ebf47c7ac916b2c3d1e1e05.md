# SNU ì»´ê³µê°œë¡ í•™

Created: April 19, 2021 2:34 PM
Created By: hyoju son
Last Edited Time: July 11, 2021 11:55 PM
Property: ì„œìš¸ëŒ€_ë¯¼ìƒë ¬T
Type: CS

- Contents

    [https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K](https://www.youtube.com/watch?v=vmWBCYs1rdU&list=PLpDJrhQ7qbNHjCGC42CrtGq1FXMskBi3K)

# 1. Bit, Data Type

- Digital System
    - Digital System : í‘œí˜„í•˜ëŠ” ì •ë³´ ì‹¬ë³¼ì´ ìœ í•œí•œ ê°œìˆ˜ì¸ ê²ƒì´ë‹¤. 
    ê·¸ ì¤‘ ì‹¬ë³¼ì´ 0,1ë§Œ ìˆëŠ” ê²ƒì´ Binary Systemì´ë‹¤. (0ì€ 0~0.5V, 1ì€ 2.4~2.9V-Volts) ComputerëŠ” binary digital systemì´ë‹¤.
    - ì •ë³´ì˜ ê¸°ë³¸ ë‹¨ìœ„ëŠ” Bit (Binary Digit)ì´ë‹¤.
    - ì»´í“¨í„°ì—ì„œ ì·¨ê¸‰í•  ë°ì´í„°ëŠ” instruction (operation ëŒ€ìƒ), number, logical (bool), text (string), image (pixel) ë“±
    - PC = ë©”ëª¨ë¦¬ (ì£¼ì†Œë§ˆë‹¤ binary dataê°€ ë“¤ì–´ìˆìŒ), CPU (Processor, Program Counter-ë‹¤ìŒì— ìˆ˜í–‰í•´ì•¼í•  instructionì˜ ì£¼ì†Œê°€ ë“¤ì–´ìˆìŒ)
    *instruction : ì–´ë–¤ ì£¼ì†Œì— ìˆëŠ” ê°’ì„ ì—°ì‚°í•˜ì—¬ ê²°ê³¼ê°’ì„ ì–´ë–¤ ì£¼ì†Œì— í• ë‹¹í•´ë¼ ë“±ì´ í•´ë‹¹ëœë‹¤. ë‹¤ìŒì— ì‹¤í–‰ë  instructionì„ ì§€ì •í•œë‹¤.
- Number
    - Two's Complement
        - 0ì˜ í‘œí˜„ë°©ë²•ì´ 2ê°œì„ (+0, -0)
        - solution : X + (-X) = 0ì„ ì„±ë¦½ì‹œí‚¤ëŠ” -Xì˜ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ í•¨
        1's Complement + 1 (???)
    - Overflow
        - If operands(í”¼ì—°ì‚°ì) are too big, then sum cannot be represented as an n-bit 2's comp number.
        - ì‹¤ì œë¡œ 2ì§„ìˆ˜ ì—°ì‚°ê³¼ì •ì—ì„œ ì–‘ìˆ˜+ì–‘ìˆ˜=ìŒìˆ˜, ë˜ëŠ” ìŒìˆ˜+ìŒìˆ˜=ì–‘ìˆ˜ ë“± ë¹„ì •ìƒì ì¸ ê²°ê³¼ê°’ì´ ë‚˜ì˜¨ë‹¤!
    - Fractions (ì†Œìˆ˜)
        1. Fixed-Point : ex) 0.00000001. ë‹¨ì ì€ 0000...ì„ í‘œí˜„í•˜ê¸° ìœ„í•´ ë©”ëª¨ë¦¬ ì†Œëª¨ê°€ í¬ë‹¤.
        2. Floating-Point : ex) F x 2^E (F: fraction, E: exponent-ì§€ìˆ˜)
- ìš”ì•½
- ë©”ëª¨ë¦¬ì˜ ë‚´ìš©ì€ ë‹¨ìˆœíˆ 0,1ì˜ íŒ¨í„´ì´ë‹¤.
- ê·¸ê²ƒì„ Program Counterê°€ ê°€ë¥´í‚¤ê³  ìˆìœ¼ë©´ instructionìœ¼ë¡œ í•´ì„ëœë‹¤. ???
- ì´ instructionì€ ì„œë¡œ ë‹¤ë¥¸ ë©”ëª¨ë¦¬ ì£¼ì†Œì— ìˆëŠ” ë°ì´í„°ë¥¼ ì°¸ì¡°í•˜ëŠ”ë°, ê·¸ instructionì´ integerë¡œ ê°„ì£¼í•˜ë©´ í•´ë‹¹ ë°ì´í„°ëŠ” integerê°€ ëœë‹¤. (instructionì—ì„œ ì²˜ë¦¬í•˜ëŠ” ë°ì´í„° íƒ€ì…ì€ integer, bit vector, floating point number, character ë“±ì´ ìˆë‹¤.)
- ë‚˜ë¨¸ì§€ string, image, sound ë“±ì€ í•˜ë“œì›¨ì–´ì—ì„œ ì§€ì›í•˜ëŠ” ë‚´ìš© (RGB ë“± ì…ì¶œë ¥ ì¥ì¹˜ì˜ í•´ì„)ì— ë”°ë¼ ì§€ì •ëœë‹¤.

# 2. Digital Logic Structure

- Memory
    - ë©”ëª¨ë¦¬ì—ëŠ” ëª‡ ê°œì˜ ì¹¸ (locations)ì´ ìˆê³ , ê° ì¹¸ì€ ì£¼ì†Œë¥¼ ê°€ì§„ë‹¤. 
    ë©”ëª¨ë¦¬ì˜ ì£¼ì†Œì— ë°ì´í„°ë¥¼ ì €ì¥í•œë‹¤.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled.png)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%201.png)

        - Address Space : ì¹¸ì˜ ê°œìˆ˜ (mê°œ bitë¡œ êµ¬ì„±ëœë‹¤ê³  ê°€ì •í•˜ë©´ 2^m ë§ë‚˜??)
        - Addressability : í•œ ì¹¸ë‹¹ bitsì˜ ê°œìˆ˜ (mê°œ)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%202.png)

    *ì°¸ê³  - CSëŠ” 2ì˜ powerë¥¼ ìì£¼ ì‚¬ìš©í•œë‹¤. 
    ë‹¨ìœ„ k : 2^10 (1024, ì›ë˜ëŠ” 1000), M : (2^10)*(2^10), G : (2^10)*(2^10)*(2^10)

- RAM (Random Access Memory)
    - ì¹´ì„¸íŠ¸ í…Œì´í”„ì™€ ë‹¬ë¦¬ ì›í•˜ëŠ” ìœ„ì¹˜ì— ë°”ë¡œ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤.
    - DRAM (Dynamic) - PCì˜ ë©”ëª¨ë¦¬. slower but denser, bit storage decays. must be periodically refreshed.
    - SRAM (Static) - fast, maintains data as long as power applied.
    - DRAM, SRAM ëª¨ë‘ Volatile memoryì´ë‹¤. (ì „ì›ì´ ëŠê¸°ë©´ ëª¨ë‘ ë‚ ì•„ê°„ë‹¤.)
    *non-Volatile memory : flash ë©”ëª¨ë¦¬ (USB, SDD)
- ìš”ì•½
- Levels of abstraction.
- MOS Transistorë¥¼ í†µí•´ CMOS gates (inverter, NAND/AND, NOR/OR)ë¥¼ ë§Œë“¤ì—ˆë‹¤.
   - Combinational circuit - ê·¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ Decoder, Mux, Adder, PLA ë“±ì„ ë§Œë“¤ì—ˆë‹¤. 
   - Sequential circuite - ê·¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ R-S latch, Gated D latchë¥¼ ë§Œë“¤ê³ , Register, Memoryë¥¼ ë§Œë“¤ì—ˆë‹¤.
   - Combinational/Sequential circuitì˜ building blockì„ ì´ìš©í•˜ì—¬ Finite State Machineì„ ë§Œë“¤ì—ˆë‹¤.
- CMOS circuits (N,P íƒ€ì… ë°˜ë„ì²´...)

# <Hardware>

# 3. Von Neumann Model (ì»´í“¨í„° êµ¬ì„±)

- 1940ë…„ëŒ€ ê°œë°œëœ ìµœì´ˆì˜ ê´œì°®ì€ ì»´í“¨í„° (í˜„ì¬ì™€ êµ¬ì„±ì´ ìœ ì‚¬í•¨)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%203.png)

    - Memory

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%204.png)

    - Processing Unit
        - Register : Processing Unitì—ì„œ operationì„ ìˆ˜í–‰í•  ë•Œ í•„ìš”í•œ ë°ì´í„°ë‚˜ ê²°ê³¼ê°’ì„ ì„ì‹œë¡œ ì €ì¥í•  ì €ì¥ê³µê°„ (temporary storage)

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%205.png)

    - I/O

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%206.png)

    - Control Unit
        - PCë¥¼ í†µí•´ ë‹¤ìŒ ì‹¤í–‰ë  instructionì˜ ì£¼ì†Œë¥¼ ë©”ëª¨ë¦¬ì—ì„œ ê°€ì ¸ì˜¤ê³ , ì‘ì—…ì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ íŒë‹¨í•œë‹¤.
        - IR (Instruction Register) : í˜„ì¬ instruction ìì²´ë¥¼ ê°€ì§
        - PC (Program Counter) : ë‹¤ìŒ instructionì˜ ì£¼ì†Œë¥¼ ê°€ì§

        *instruction : processingì˜ ê¸°ë³¸ ë‹¨ìœ„. ì—°ì‚°, ë°ì´í„° ì´ë™ (Memoryâ†”Register), ì œì–´ ë“±ì˜ ì¢…ë¥˜ê°€ ìˆë‹¤.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%207.png)

# 4. LC-3

- ISA (Instruction Set Architecture)
    - specifies all of programmer-visible state (memory organization, register set) and operations (opcode, data type, addressing mode).
    - hardware (í•˜ë“œì›¨ì–´ êµ¬í˜„ ì‹œ í•„ìš”í•œ ëª¨ë“  ì •ë³´), software (ë¨¸ì‹ ëŸ¬ë‹ ê°œë°œì„ ìœ„í•´ í•„ìš”í•œ ëª¨ë“  ì •ë³´)ì˜ interface

# 5. Assembly Language

- Assembler : symbolic representationì„ binary representationìœ¼ë¡œ ë°”ê¿”ì£¼ëŠ” í”„ë¡œê·¸ë¨

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%208.png)

    - Assembly language is "translated (ë™ì¼í•œ ê¸°ëŠ¥ìœ¼ë¡œ ë²ˆì—­ë¨)" into machine language (object code) by two-pass assembler, whereas instructions in machine language are "interpreted (í•´ì„ë˜ì–´ ì‹¤í–‰ë¨)" by hardware.

# 6. I/O

- ì–´ë–»ê²Œ ì™¸ë¶€ ë°ì´í„°ê°€ ë©”ëª¨ë¦¬ë¡œ ë“¤ì–´ì˜¤ê³ , ë©”ëª¨ë¦¬ì˜ ë°ì´í„°ê°€ ì™¸ë¶€ë¡œ ë‚˜ê°€ëŠ”ì§€
- Device
    - input deviceëŠ” í‚¤ë³´ë“œ, ë§ˆìš°ìŠ¤ ë“±, output deviceëŠ” ëª¨ë‹ˆí„° ë“±, ë‘˜ë‹¤ í•´ë‹¹ë˜ëŠ” ê²ƒì€ USB
    - I/O Controller
    - Control Register : CPUê°€ deviceì—ê²Œ ì‹œí‚¨ ì‘ì—…ì— ëŒ€í•´ í•„ìš”í•œ ëª…ë ¹ì´ë‚˜ íŒŒë¼ë§¤í„°ë¥¼ ì „ë‹¬í•´ì¤Œ (write)
    - Status Register : deviceì˜ ìƒíƒœë¥¼ CPUì— ë³´ê³ í•¨ (read)
    - Date Register : ë°ì´í„°ë¥¼ ì „ë‹¬í•¨ (ë©”ëª¨ë¦¬â†”device)
    - Device Electronics : ì‹¤ì œ ë™ì‘ì„ ì‹¤í–‰í•¨. pixel to screen, bits to/from disk, characters from keyboard
    - Programming Interface
        - identify device register - Memory-mapped / special I/O instructions
        - ì£¼ë¡œ Memory-mappedê°€ ì‚¬ìš©ë¨
        - transfer timing - Asynchronous (ë¹„ë™ê¸°ì ) / synchronous (ë™ê¸°ì )
        - ëŒ€ë¶€ë¶„ ë¹„ë™ê¸°ì . deviceê°€ ë³´ë‚¼ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê±°ë‚˜ ë°ì´í„°ë¥¼ ë°›ì„ ìƒíƒœê°€ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ì‘ì—…ì„ ê±°ì¹¨ (synchronizing, handshaking)
        - ë™ê¸°ì  : ì¼ì • ì£¼ê¸°ë¡œ ë™ì¼í•œ ì–‘ì˜ ë°ì´í„°ë¥¼ ê³„ì† deviceë¡œ ë³´ë‚´ê±°ë‚˜ ë°›ëŠ” ê²½ìš°
        - transfer control - CPU (Polling) / device (interrupts)
        - ë°ì´í„° ì „ë‹¬ì„ ì–¸ì œ ì‹¤í–‰í• ì§€ ê²°ì •í•˜ëŠ” ë°©ë²•
        - ëŒ€ë¶€ë¶„ Pollingì„ ì§€ì›í•¨
        - Polling : CPU keeps checking status register until new data arrives or device ready for next data.
        - Interrupt : Device needs a special signal to CPU when new data arrives or device ready for next data. (CPUê°€ ê·¸ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰í•¨. priorityë¡œ íŒë‹¨í•¨)

# 7. Trap Routines, Subroutines

- OS (Operating System)ì´ ê´€ì—¬í•˜ëŠ” ê²½ìš°
    - system calls (via TRAP instruction)
    - Interrupts
    - Exception
- Subroutines
    - invoked via JSR or JSRR instruction (return address in R7)
    - arguments, return values, need to save/restore registers

# 8. Stack

- Stackì€ Abstract data typeì´ë‹¤. (Abstract : ë‚´ë¶€ êµ¬í˜„ì— ëŒ€í•œ ìì„¸í•œ ë‚´ìš©ì€ ê°ì¶”ê³ , interfaceë¥¼ í†µí•´ í•´ë‹¹ ìë£Œêµ¬ì¡°ë¥¼ buidling blockìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.)
- LIFO (last-in, first-out) ì €ì¥ êµ¬ì¡°ì´ë‹¤.
- Main Operationì€ Push&Popì´ë‹¤. PushëŠ” ìƒˆë¡œìš´ ì•„ì´í…œì„ stackì— ë”í•˜ëŠ” ê²ƒ, Popì€ stackìœ¼ë¡œë¶€í„° ì•„ì´í…œì„ êº¼ë‚´ëŠ” ê²ƒì´ë‹¤.
- ë©”ëª¨ë¦¬ì—ì„œ stackì˜ êµ¬ì¡°

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%209.png)

---

# <Software>

# 9. Programming in C

- Cì–¸ì–´ : High-Level Language
    - System programming (Windowx, UNIX ë“±) ê°œë°œì—ë„ ì‚¬ìš©ëœë‹¤.
    - ê°’ì„ ë‹´ëŠ” containerì— symbolic name (ë³€ìˆ˜ëª…)ì„ ë¶€ì—¬ ê°€ëŠ¥í•˜ë‹¤. 
    C ì»´í¼ì¼ëŸ¬ê°€ ë³€ìˆ˜ë¥¼ memoryì— ì˜®ê¸°ê±°ë‚˜, ì„ì‹œë¡œ registerë¡œ ì˜®ê¸°ëŠ” ë“±ì˜ ì‘ì—…ì„ í•´ì¤€ë‹¤. (ê¸°ì¡´ì˜ Assembly Languageë‚˜ Machine Instructionì€ register or memory locationì— ê°’ì„ ì €ì¥í•œë‹¤. CëŠ” register or memory locationì„ ëª°ë¼ë„ ëœë‹¤.)
    - underlying ??? hardwareì— ëŒ€í•´ abstractionì„ ì§€ì›í•œë‹¤. (machine languageì˜ High-Level abstractionì„ ì œê³µí•œë‹¤.)
    operationì€ instruction set architectureì™€ ë³„ê°œë¡œ ì‘ë™í•œë‹¤.
    - ë³€ìˆ˜ (register, memory locationì— ëŒ€í•œ abstraction)
    - operation (arithmetic, logic instructionì— ëŒ€í•œ abstraction)
    - control structure (branch, jump instructionì— ëŒ€í•œ abstraction)
    - í‘œí˜„ë ¥ì´ í’ë¶€í•˜ê³ , ê°€ë…ì„± ìˆìŒ, ë²„ê·¸ì— ëŒ€í•œ safeguard ì§€ì› (ê·œì¹™ì„ enforceí•˜ë„ë¡ ê°€ì´ë“œ ì œê³µ)í•œë‹¤.
- Translating High-Level Language
    1. Interpretation (ì‹¤í–‰ì„ ìœ„í•œ í•´ì„. ì‹¤ì œ machine instructionì´ ì‹¤í–‰ë˜ëŠ” ê²ƒ)
        - executes program statements
        - generally one line/command at a time, ì „ì²´ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ íš¨ìœ¨ì„±ì´ ë‚®ìŒ
        - debug, ë³€ê²½, ì¤‘ê°„ê²°ê³¼ í™•ì¸ì´ ì‰¬ì›€ (statement ë‹¨ìœ„ë¡œ ìˆ˜ì • ê°€ëŠ¥í•˜ë¯€ë¡œ)
        - ì–¸ì–´ - BASIC, LISP, Perl, Matlab, C-shell
    2. Compilation (High Level Languageë¥¼ Machine Languageë¡œ ì „í™˜)
        - High Level Languageì˜ ì „ì²´ statementë¥¼ machine languageë¡œ traslate í•¨ (ì‹¤í–‰í•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ executable programì„ ìƒì„±í•¨)
        *CS50 - Asembly codeë¥¼ object codeë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì€ ì–´ì…ˆë¸” (Assemble) ë‹¨ê³„
        - ì „ì²´ êµ¬ì¡°ë¥¼ íŒŒì•…í•˜ê³  ìˆìœ¼ë¯€ë¡œ ìµœì í™” ê¸°íšŒê°€ ë§ê³ , íš¨ìœ¨ì„±ì´ ë†’ìŒ
        - ë³€ê²½ ì‹œ compilationì„ ë‹¤ì‹œ í•´ì•¼ í•¨. debugê°€ ì–´ë ¤ì›€
        - ì–¸ì–´ - C, C++, Fortran, Pascal
    3. Interpretation&Compilationì˜ Hybrid
        - Java
        - Java languageëŠ” JVM (Java Virtual Machine) byte codeë¡œ ì»´íŒŒì¼ëœë‹¤.
        - JVM byte codeëŠ” 1) interpreted ë˜ì–´ ì‹¤í–‰ë˜ê±°ë‚˜, ë˜ëŠ” 2) native machine codeë¡œ compileë˜ì–´ ì‹¤í–‰ëœë‹¤. - JIT (Just in Time, ì½”ë“œê°€ ì‹¤í–‰ë  ë•Œ ì»´íŒŒì¼) ë˜ëŠ” AOT (Ahead of Time, ì½”ë“œê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì»´íŒŒì¼) ì»´íŒŒì¼ëŸ¬ì— ì˜í•´
        - Python
        - Python í”„ë¡œê·¸ë¨ì€ byte code (Java Language ë“±)ìœ¼ë¡œ convertedëœë‹¤. - PVM (Python Virtual Machine) for CPython, JVM for Jythonì— ì˜í•´
        - byte codeëŠ” native machine codeë¡œ interpreted ë˜ëŠ” compileëœë‹¤. - JIT (Just in Time) ë˜ëŠ” AOT (Ahead of Time) ì»´íŒŒì¼ëŸ¬ì— ì˜í•´
    - ì˜ˆì‹œ

        ```swift
        func getZ (W: Int) {
        		X = W + W
        		Y = X + X
        		Z = Y + Y
        		print("Z")
        }

        ë¼ëŠ” ì½”ë“œê°€ ìˆì„ ë•Œ,
        1. interpretingí•˜ë©´, í•œ ì¤„ì”© ì‹¤í–‰í•˜ì—¬ Zë¥¼ ê³„ì‚°í•œë‹¤.
        2. compileí•˜ë©´, ì „ì²´ ì½”ë“œë¥¼ ë¶„ì„í•˜ì—¬ Z = 8Wë¡œ ìµœì í™”í•˜ê³  Zë¥¼ ê³„ì‚°í•œë‹¤.
        ```

- Compiling C

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2010.png)

    - Pre-processor
    - macro substitution
    - conditional compilation
    - source-level transformations (output is still C)
    - Compiler
    - generates object file (machine instruction)
    1) Source Code Analysis
        - Front-end, parses programs to identify its pieces (ë³€ìˆ˜, í•¨ìˆ˜ ë“±). Cì–¸ì–´ ì½”ë“œë¥¼ ë¶„ì„í•´ì„œ ì–´ë–¤ ë¬¸ë²•ì  êµ¬ì¡°ë¥¼ ê°€ì§€ëŠ”ì§€ íŒŒì•…í•¨
        - depends on language (not on target machine)
    2) Code Generation
        - Back-end, generates machine code from analyzed source
        - may optimize machine code
        - depends on target machine (íŠ¹ì • instruction set architectureì— ë”°ë¼ machine code, machine instructionì´ ë˜ë¯€ë¡œ)
    3) Symbol Table
        - map between symbolic names and items
        - Assemblerì˜ Symbol Tableê³¼ ìœ ì‚¬í•˜ì§€ë§Œ ë³´ë‹¤ ë‹¤ì–‘í•¨
    - Linker
    - combine object files (including libraries) into executable image
    - ì˜ˆì‹œ

        ```c
        #include <stdio.h> // 1) # : pre-processorì— ì˜í•´ ì²˜ë¦¬ë¨
        #define STOP 0 // 2)

        // description : counts down from user input to STOP
        main () // 3) function : main
        {
        		int counter; // 4) ë³€ìˆ˜ ì„ ì–¸
        		int startPoint;

        		printf("Enter a positive number: "); // 5) prompt user for input (promptë¥¼ í†µí•´ userì—ê²Œ ë³´ì—¬ì¤€ë‹¤)
        		scanf("%d, &startPoint"); // 6) read into startPoint (userê°€ ì…ë ¥í•œ ê°’ì„ readí•´ì„œ startPoint ë³€ìˆ˜ì— í• ë‹¹) *scanf : ë³€ìˆ˜ ê°’ì„ input ë°›ìŒ

        		for (counter = startPoint; counter >= STOP; counter--)
        			printf("%d\n", counter); // 5) count down and print count 
        }
        ```

        1) pre-processor ë‹¨ê³„ë¡œ í•´ë‹¹ íŒŒì¼ì˜ ì†ŒìŠ¤ì½”ë“œë¥¼ ê°€ì ¸ì™€ì„œ ëŒ€ì²´í•œë‹¤.
            - Before compiling, copy contents of header file (stdio.h) into source code.
            - header fileì€ ë³´í†µ ìƒìˆ˜, ë³€ìˆ˜, í•¨ìˆ˜ ì •ì˜ ë“±ì„ í¬í•¨í•œë‹¤.
        2) pre-processor ë‹¨ê³„ë¡œ String STOPì„ String 0ìœ¼ë¡œ ëŒ€ì²´í•œë‹¤.
            - Before compiling, replace all instances of the String "STOP" with the String "0"
            - Called as macro (macro substitution)
            - ì‹¤í–‰í•˜ëŠ” ë™ì•ˆ ë³€ê²½ë˜ì§€ ì•ŠëŠ” ê°’ì— ì‚¬ìš©ëœë‹¤. ë‹¨, í”„ë¡œê·¸ë¨ì´ reusedë  ë•ŒëŠ” ë³€ê²½ë  ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë¯€ë¡œ recompileí•´ì•¼ í•¨
        3) í”„ë¡œê·¸ë¨ì„ runí•˜ë©´ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
        4) ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
             - symbolic name : counter, ê°’ì„ ë‹´ì„ ì»¨í…Œì´ë„ˆì˜ type : int 
               (data typeì„ ì»´íŒŒì¼ëŸ¬ì— ì „ë‹¬í•˜ì—¬ ì–¼ë§ˆë§Œí¼ì˜ ê³µê°„ì„ í• ë‹¹í• ì§€ ë“±ì„ interpretí•œë‹¤.)
        5) Output
            - String contains characters to print and formatting directions for variables. (ë³€ìˆ˜ ê°’ì„ ì–´ë–¤ typeìœ¼ë¡œ ì¶œë ¥í• ì§€)
            - ë³€ìˆ˜ counterë¥¼ %d (decimal integer) typeìœ¼ë¡œ ì¶œë ¥í•œë‹¤. ê·¸ë¦¬ê³  linefeed (\n)ë¥¼ ì¶œë ¥í•œë‹¤.
            - ì˜ˆì‹œ) printf("%d %d\n", counter, startPoint - counter); // ë³€ìˆ˜ ì™¸ì—ë„ ì—°ì‚° ê°’ì„ ì¶œë ¥ ê°€ëŠ¥í•˜ë‹¤.
            *formatting options - %x (hexadecibal integer), %c (ASCII character), %f (floating-point number)
        6) Input
            - String contains formatting directions for looking at input. 
            - %d typeì˜ ê°’ì„ readí•˜ì—¬ ë³€ìˆ˜ startPointì— í• ë‹¹í•œë‹¤.
            - & (Ampersand)ë¥¼ ì‚¬ìš©í•œë‹¤. (Pointerì—ì„œ ì„¤ëª…)

# 10. *Variable, Operator

- ë³€ìˆ˜
- holds a value upon which a program acts
- an abstraction (ì¦‰, symbolic name) of a memory location, but its value is moved to a register when subject to an operation and moved back to memory when registers are full
   (ì‹¤ì œ ì—°ì‚°ì„ í•  ë•Œ ê°’ì´ memoryì—ì„œ registerë¡œ ì´ë™í•¨)
- ë³€ìˆ˜, ìƒìˆ˜, ì—°ì‚°ì ë“±ìœ¼ë¡œ í‘œí˜„ëœ Expressionì€ ì—°ì‚°ì„ í†µí•´ valueë¥¼ êµ¬í•˜ë©° (evaluate to a value), typeì„ ê°€ì§ 
   (í• ë‹¹ì—°ì‚°ì '='ë„ 1) í• ë‹¹ actionì„ ìˆ˜í–‰í•˜ë©´ì„œ, 2) valueë¥¼ ê°€ì§€ë©° í•´ë‹¹ ê°’ì€ "ì—°ì‚°ì˜ ê²°ê³¼ë¡œ í• ë‹¹ë˜ëŠ” ê°’"ì„. Cì˜ íŠ¹ì§•)
- Expressionì˜ ê²°ê³¼ê°’ì„ areaì— í• ë‹¹í•˜ëŠ” ê²ƒì€ Statementì„ (ì‘ì—…ì˜ ë‹¨ìœ„;)
   - simple statement `a = b + 1;`
   - compound statement `{ a = b + 1; b = c * d; }`
    - Scope
    - Compiler infers scope from where variable is declared. (ì»´íŒŒì¼ëŸ¬ëŠ” ë³€ìˆ˜ê°€ ì„ ì–¸ëœ ìœ„ì¹˜ì—ì„œ ë²”ìœ„ë¥¼ ì¶”ë¡ í•œë‹¤.)
    - Global : accessed anywhere in program. declared outside of all blocks
    - Local : only accessible in a particular region. Variable is local to the block {} in which it is declared.
- ì—°ì‚°ì
- predefined actions performed on values
- an abstraction of arithmetic/logic instructions
- ë…¼ë¦¬ì—°ì‚°ì : Bool typeì˜ ê²°ê³¼ê°’ì„ Intë¡œ í‘œí˜„ (0=false, 1=true) ë‹¨, í”¼ì—°ì‚°ìë¥¼ ì·¨ê¸‰í•  ë•Œ 0=false, 0ì™¸ ëª¨ë“  ê°’=trueë¡œ ì¸ì‹í•¨ (Cì˜ íŠ¹ì§•)
- Precedence (ìš°ì„  ìˆœìœ„)
   - ì—°ì‚°ì ìš°ì„ ìˆœìœ„ëŠ” */%ì´ 6ì´ê³ , +-ì´ 7ì„ (ìˆ«ì ì ì„ìˆ˜ë¡ ìš°ì„ ìˆœìœ„ ë†’ìŒ)
- Associativity (ê²°í•© ë²•ì¹™)
   - Assignment associates right to left. (í• ë‹¹ì—°ì‚°ìì˜ ê²°í•© ë²•ì¹™ì€ ìš°ì—ì„œ ì¢Œì„) ë”°ë¼ì„œ `y = x = 3;` ì˜ ì˜ë¯¸ëŠ” `y = (x = 3);`ê³¼ ë™ì¼í•¨ (3ì„ xì— í• ë‹¹í•˜ê³ , xë¥¼ yì— í• ë‹¹)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2011.png)

- Symbol Table
- ì»´íŒŒì¼ëŸ¬ëŠ” ë³€ìˆ˜ ê´€ë ¨ ì •ë³´ë¥¼ ì €ì¥í•œë‹¤. (ë³€ìˆ˜ëª…, type, memory location (Offset), scope)
- ë¡œì»¬ë³€ìˆ˜ Storage (YT 50min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2012.png)

    - ë¡œì»¬ë³€ìˆ˜ëŠ” user stack (activation record, stack frame)ì— ì €ì¥ëœë‹¤.
    - main í•¨ìˆ˜ì— ë³€ìˆ˜ê°€ í• ë‹¹ë˜ë©´, memoryì˜ stack ë°”ë‹¥ë¶€í„° ìŒ“ì¸ë‹¤. (main í•¨ìˆ˜ì˜ stack í¬ê¸°ê°€ ëŠ˜ì–´ë‚œë‹¤.) ë§Œì•½ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ì •ì˜í•˜ë©´ì„œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©´, ì„ ì–¸ ìˆœìœ¼ë¡œ stackì— ê·¸ëŒ€ë¡œ ìŒ“ì¸ë‹¤. 
    - main í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, activation recordê°€ stackì— ìŒ“ì¸ë‹¤. ???
    *(12. Function ì°¸ê³ ) activate record : procedureê°€ í•œ ë²ˆ ìˆ˜í–‰ë˜ê¸° ìœ„í•´ í•„ìš”í•œ ì •ë³´ëŠ” memoryì˜ ì—°ì† ë¸”ë¡ì„ ì‚¬ìš©í•˜ì—¬ ê´€ë¦¬í•˜ëŠ”ë°, ì´ë•Œ ì—°ì† ë¸”ë¡ì„ ì˜ë¯¸í•¨. ì§€ì—­ë³€ìˆ˜ ë° ê·¸ì™¸ í”„ë¡œê·¸ë¨ ìˆ˜í–‰ì— í•„ìš”í•œ ì •ë³´.
    The activation record is temporary - it is allocated when the function is called (becomes active) and it is deallocated when the function returns (becomes inactive). Once an activation record is deallocated, the memory it occupied is available for use when new activation records are created.
    - Symbol Table "Offset"ì€ the base of the frameìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.
    - R5 is the frame pointer. R5 holds address of the base of the current frame. (the base of the activation record)
    - A new frame is pushed on the run-time stack each time a function is called or a block is entered.
    - bc stack grows downward, R5 contains the highest address of the frame (*ì£¼ì˜-frame baseë¡œ ë‚´ë ¤ê°ˆìˆ˜ë¡ addressëŠ” ë†’ì•„ì§. ì¦‰, ê·¸ë¦¼ ìƒ ìœ„ë¡œ ìŒ“ëŠ” í˜•íƒœë¡œ ë³´ì´ì§€ë§Œ, ì‹¤ì œë¡œ ë³€ìˆ˜ê°€ í• ë‹¹ë˜ë©´ ì•„ë˜ ë°©í–¥ì˜ ë©”ëª¨ë¦¬ê°€ í• ë‹¹ë˜ë©´ì„œ Stackì´ ì•„ë˜ë¡œ ëŠ˜ì–´ë‚¨), and variable offsets are <= 0. 
      (offset : R5ê°€ ê°€ë¥´ì¹˜ëŠ” ê³³ì´ 0, ê·¸ ìœ—ì¹¸ë¶€í„° ì˜¬ë¼ê°ˆìˆ˜ë¡ -1, -2 ... -5ê°€ ë¨)
- í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì‹œ memory (YT 55min)

    ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2013.png)

    - Instructions 
    - í˜„ì¬ ì‹¤í–‰ë˜ëŠ” instructionì€ PC (Program Counter)ê°€ íŠ¸ë˜í‚¹í•˜ê³  ìˆë‹¤.
    - Global data section
    - ëª¨ë“  ê¸€ë¡œë²Œ ë³€ìˆ˜ê°€ ì €ì¥ëœë‹¤. (ì—„ë°€íˆëŠ” ëª¨ë“  static ë³€ìˆ˜)
    - R4ëŠ” beginning (ì‹œì‘ ì£¼ì†Œ)ì„ ê°€ë¥´í‚¨ë‹¤.
    - Run-time stack
    - ë¡œì»¬ë³€ìˆ˜ ì‚¬ìš©ì— í™œìš©ëœë‹¤. (ì—„ë°€íˆëŠ” automatic ë³€ìˆ˜)
    - R6ëŠ” top of stack (stack ìµœìƒë‹¨)ì„, R5ëŠ” top frame on stack (the base of the current frame, í˜„ì¬ í•¨ìˆ˜ì˜ frame base) ì„ ê°€ë¥´í‚¨ë‹¤.
    - ê°œë³„ blockì— new frameì´ ì£¼ì–´ì§„ë‹¤. (block exit, ì¦‰ ë©”ëª¨ë¦¬ê°€ freeë˜ë©´ ì‚¬ë¼ì§„ë‹¤.)
    *ë³€ìˆ˜ ì„ ì–¸ ì‹œ staticì´ ì—†ìœ¼ë©´ automatic ë³€ìˆ˜ì´ë‹¤. í•´ë‹¹ blockì— ë“¤ì–´ê°€ë©´ ë©”ëª¨ë¦¬ê°€ allocateë˜ê³ , blockì—ì„œ ë‚˜ê°€ë©´ free ëœë‹¤.
    ë°˜ë©´, staticì´ ìˆìœ¼ë©´ static ë³€ìˆ˜ì´ë‹¤. blockì— ë“¤ì–´ê°€ê³  ë‚˜ê°€ëŠ” ê²ƒê³¼ ë¬´ê´€í•˜ê²Œ í”„ë¡œê·¸ë¨ ì‹œì‘ ì‹œ allocateë˜ê³ , í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ free ëœë‹¤.
    â‡’ ë”°ë¼ì„œ 'static ë¡œì»¬ë³€ìˆ˜'ëŠ” ë¡œì»¬ë³€ìˆ˜ì´ì§€ë§Œ Stackì´ ì•„ë‹ˆë¼ Globalì— í• ë‹¹ëœë‹¤.
    - Offset : ì €ì¥ê³µê°„ì˜ ì‹œì‘ì ìœ¼ë¡œë¶€í„°ì˜ ê±°ë¦¬ì´ë‹¤.
    - Global : LDR R1, R4, #4 // Globalì˜ R4ë¥¼ ê¸°ì¤€ìœ¼ë¡œ accessí•¨
    - Local   : LDR R2, R5, #-3 // Stackì˜ R5ë¥¼ ê¸°ì¤€ìœ¼ë¡œ accessí•¨
- Variable & Memory Location
    - ë³€ìˆ˜ëŠ” í•­ìƒ ë©”ëª¨ë¦¬ì— ì €ì¥ëœë‹¤.
    - ì–´ë–¤ ë³€ìˆ˜ê°€ í• ë‹¹ë˜ë©´, memory locationì— ì €ì¥ëœë‹¤. 
    - instruction ìˆ˜ì¤€ì—ì„œëŠ” store operationì„ ì§„í–‰í•œë‹¤. (ì»´íŒŒì¼ì˜ ê²°ê³¼ë¡œ ìƒì„±ë˜ëŠ” instruction)
    - ì»´íŒŒì¼ëŸ¬ëŠ” ì½”ë“œ ìµœì í™”ë¥¼ ìœ„í•´ ë³€ìˆ˜ë¥¼ registerì— í• ë‹¹í•˜ë ¤ê³  í•œë‹¤. ì™œ?
    - +, && ë“± operationì„ í•˜ë ¤ë©´ ê°’ì´ (ì„ì‹œë¡œë¼ë„) registerì— ìˆì–´ì•¼ë§Œ ì—°ì‚°ì´ ê°€ëŠ¥í•˜ë‹¤.
    - ì„±ëŠ¥ ì¸¡ë©´ì—ì„œ registerë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ memoryë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒë³´ë‹¤ ë” ë¹ ë¥´ë‹¤.
    - ë”°ë¼ì„œ ì»´íŒŒì¼ì€ ë³´í†µ ë©”ëª¨ë¦¬ì— home locationì´ ìˆê³ , í•„ìš”ì— ë”°ë¼ (ì—°ì‚°ì„ í•˜ê±°ë‚˜ ë¹ ë¥¸ accessê°€ í•„ìš”í•  ë•Œ) registerì— ì„ì‹œë¡œ ê°’ì„ ì´ë™ì‹œí‚¤ëŠ” ìµœì í™” ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

# 11. Control Structure

- row level language - ë³´í†µ machine instructionì€ sequential í•˜ê²Œ ìˆ˜í–‰ë˜ê³ , conditional branch ë˜ëŠ” jump instructionì— ì˜í•´ non-sequentialí•˜ê²Œ ìˆ˜í–‰ë˜ê¸°ë„ í•œë‹¤.
- high level language - Sequence, Conditional, Iterarion ë“±ì˜ Control Structureê°€ ìˆë‹¤.

1. Condition
    - `if (condition) action;`
    - condition : C expression, action : C statement;

        ```c
        if (x <= 10) {
        y = x + 1; // conditionì´ trueì´ë©´ action (2ê°œ statement)ì´ ì‹¤í–‰ë¨
        z = y + 1;
        }

        if (x <= 10) // {}ê°€ ì—†ìœ¼ë©´ condition ë’¤ì˜ 1ê°œ statementë§Œ ifë¬¸ ì†Œì†ìœ¼ë¡œ ì¸ì‹ë¨
        y = x + 1; // conditionì´ trueì´ë©´ action (1ê°œ statement)ì´ ì‹¤í–‰ë¨
        z = y + 1; // conditionê³¼ ìƒê´€ì—†ì´ í•­ìƒ ì‹¤í–‰ë¨

        ```

    - `switch (expression) {caseconst1: action1;break;caseconst2: action2;break;default:action3;}`
    - breakë¥¼ ê° caseì— ì¶”ê°€í•˜ëŠ” ê²ƒì´ ë°”ëŒì§í•¨. breakê°€ ì—†ìœ¼ë©´ const1 ì¡°ê±´ì„ ë§Œì¡±í•  ê²½ìš°, case1ì—ì„œ ì¢…ë£Œë˜ì§€ ì•Šê³  case2, defaultë¡œ ë„˜ì–´ê°€ì„œ ëª¨ë‘ ì‹¤í–‰ë˜ê¸° ë•Œë¬¸ (Cì˜ ë‹¨ì )
    - const1ì„ ë§Œì¡±í•˜ë©´ action1ì„ ì‹¤í–‰í•˜ê³  ì¢…ë£Œ, const2ë¥¼ ë§Œì¡±í•˜ë©´ action2ë¥¼ ì‹¤í–‰í•˜ê³  ì¢…ë£Œ, ìœ„ì˜ ëª¨ë“  ì¡°ê±´ì—ì„œ falseì´ë©´ defaultë¥¼ ì‹¤í–‰í•˜ê³  ì¢…ë£Œ (breakê°€ ìˆìœ¼ë¯€ë¡œ)
        - break
        - used only in switch or iteration statement
        - *passes control out of the smallest statement (loop or switch) containing it to the statement immediately following (breakë¥¼ í¬í•¨í•˜ëŠ” ì‹¤í–‰ë¬¸ (ë°˜ë³µë¬¸ ë˜ëŠ” switchë¬¸)ì˜ ì œì–´ë¥¼ ë°”ë¡œ ë‹¤ìŒ ì‹¤í–‰ë¬¸ (í•´ë‹¹ ë°˜ë³µë¬¸ ë˜ëŠ” switchë¬¸ ì™¸ë¶€)ìœ¼ë¡œ ì „ë‹¬í•œë‹¤.)
        - usually used to exit a loop before terminating condition occurs (or to exit switch statement when case is done)
        - continue
        - used only in iteration statement
        - *terminates the execution of the loop body for this iteration (ë°˜ë³µë¬¸ì˜ í•´ë‹¹ iterationì˜ ì‹¤í–‰ë¬¸ì„ ì¦‰ì‹œ ì¢…ë£Œí•˜ê³ , ë‹¤ìŒ iterationìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.)
        - loop expression is evaluated to see whether another iteration should be performed
        - if 'for loop', also executes the re-initializer (forë¬¸ì´ë©´ re-initializerë¥¼ ì‹¤í–‰í•œ ì´í›„, ë‹¤ìŒ iterationìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.)

            ```c
            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) continue;
            		printf("%d ", i);
            }
            // ifë¬¸ì´ trueì´ë©´ ë‹¤ìŒ iterationì„ ì‹¤í–‰í•¨ -> 20 ì´í•˜ì˜ í™€ìˆ˜ê°€ ì¶œë ¥ë¨

            for (i = 0; i <= 20; i++) {
            		if (i % 2 == 0) break;
            		printf("%d ", i);
            }
            // i = 0ì¸ ì²«ë²ˆì§¸ iterationì—ì„œ break -> *forë¬¸ ìì²´ë¥¼ ì¢…ë£Œí•¨
            ```

2. *Iteration
    - `while (test) loop_body;`
    - Executes loop_body as long as test evaluates to True (non-zero).
    - `for (init;test;re-init) statement;`
    - Executes loop_body as long as test evaluates to True (non-zero). Initialization and re-initialization code include in loop statement.
    - `init;while (test) {statement;re-init}` êµ¬ì¡°ì™€ ë™ì¼í•˜ë‹¤.

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2014.png)

        ```c
        // Nested Loops

        for (mp1 = 0; mp1 < 10; mp1++) {      // 1) mp1 = 0ì´ ë¨¼ì € ë“¤ì–´ê°€ê³ 
        		for (mp2 = 0; mp2 < 10; mp2++) {  // 2) mp2ê°€ 0ì—ì„œ 9ê¹Œì§€ ëŒê³ ë‚˜ì„œ, (ë‹¤ì‹œ mp1 = 1ì´ ë“¤ì–´ê°€ê³ , mp2ê°€ 0ì—ì„œ 9ê¹Œì§€ ëŒê³ ë‚˜ì„œ ... ë°˜ë³µ)
        				printf("%d\t", mp1 * mp2);
        		}
        		print("\n")
        } // prints a multiplication table.

        for (outer = 1; outer < 10; outer++) {
        		for (inner = 0; inner < outer; inner++) {  // outer ë³€ìˆ˜ì— ë”°ë¼ ë‚´ë¶€ forë¬¸ì˜ ì‹¤í–‰íšŸìˆ˜ê°€ ê²°ì •ë˜ëŠ” êµ¬ì¡°
        				sum += inner;
        		}
        }
        ```

    - For Vs. While
        - For loop : counter-based loopì— ì í•©í•˜ë‹¤. (ex. 5ë²ˆ count ë™ì•ˆ ì‹¤í–‰í•´ë¼)
        - While loop : sentinel (ë³´ì´ˆë³‘)-based loopì— ì í•©í•˜ë‹¤. (ex. íŠ¹ì • ì¡°ê±´ ë™ì•ˆ ì‹¤í–‰í•´ë¼)
- Problem Solving in C
    - Stepwise Refinement 
    - machine instructionì„ ì´ìš©í•˜ë©´ machine languageê¹Œì§€ ë‚´ë ¤ê°€ì•¼ problem solvingì´ ê°€ëŠ¥í•˜ì§€ë§Œ,
       Cì—ì„œëŠ” Cì–¸ì–´ ìì²´ë¡œ problem solvingì´ ê°€ëŠ¥í•˜ë¯€ë¡œ ì‘ì—…ì´ ì‰½ê³  ìƒì‚°ì„±ì´ ì¢‹ë‹¤.

# 12. Function

- ì¥ì 
    - ìì£¼ ì“°ëŠ” ê¸°ëŠ¥ì„ subcompomentë¡œ ë§Œë“ ë‹¤. ì´ë¥¼ í†µí•´ compositional designì´ ê°€ëŠ¥í•˜ë‹¤.
    - ì‘ì—…ì— ëŒ€í•œ abstractionì„ ì§€ì›í•œë‹¤.
    - hides low-level details (input, output ê´€ê³„ë§Œ ì•Œë©´ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤. ë‚´ë¶€ì ìœ¼ë¡œ ì–´ë–»ê²Œ êµ¬í˜„ì´ ë˜ëŠ”ì§€ëŠ” ìˆ¨ê²¨ì¤€ë‹¤.)  
    - gives high-level structure to program, and make it easier to understand overall program flow
    - C Function
    - zero or multiple arguments passed in
    - single result returned (optional-outputì´ ì—†ëŠ” ê²½ìš°ë„ ìˆë‹¤.)
    - ë‹¤ë¥¸ ì–¸ì–´ì—ì„œëŠ” procedure, subroutineìœ¼ë¡œ ë¶€ë¥¸ë‹¤.
- Declaration & Call & Definition
    - [x]  ì™œ parameterê°€ ì„ ì–¸í•  ë•ŒëŠ” 1ê°œì¸ë°, í˜¸ì¶œí•  ë•ŒëŠ” 2ê°œê°€ ë“¤ì–´ê°€ì§€?
        - f+gì˜ ê²°ê³¼ê°’ì´ parameter nì˜ argumentë¡œ ì „ë‹¬ëœë‹¤.

    ```c
    // Declaration
    int Factorial(int n;) // prototype
    // ì°¨ë¡€ë¡œ return type, Function Name, types/number of all arguments

    // Call (Invocation)
    a = x + Factorial(f + g) // 1) evaluate argument, 2) evaluate function, 3) use return value in expression.

    // Definition - í•¨ìˆ˜ êµ¬í˜„ê³¼ ê´€ë ¨ëœ low-level detail
    // - Declaration ë‚´ìš© (State type, name/types of arguments ë“±)ê³¼ ì¼ì¹˜ì‹œí‚¨ë‹¤. (argument nameì„ ë™ì¼í•˜ì§€ ì•Šê²Œ ë¶€ì—¬ ê°€ëŠ¥í•˜ì§€ë§Œ, ë¹„íš¨ìœ¨ì ì´ë‹¤.)
    int Factorial(int n) {
    		int i;
    		int result = 1;

    		for (i = 1; i <= n; i++)
    				result = result * i;

    		return result; // ê°’ì„ ë°˜í™˜í•˜ê³ , gives control back to calling function (controlì€ í•¨ìˆ˜ í˜¸ì¶œ ì§€ì ìœ¼ë¡œ ë˜ëŒì•„ê°„ë‹¤.)
    }  
    ```

    - Declarationì´ í•„ìš”í•œ ì´ìœ 
        - Definition ì´ì „ì— í•¨ìˆ˜ë¥¼ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤. (C íŠ¹ì§•)
        - ì»´íŒŒì¼ëŸ¬ëŠ” return type, argument type/numberë¥¼ ì•Œì•„ì•¼ í•œë‹¤.
        - Definitionì´ ë‹¤ë¥¸ íŒŒì¼ì— ë“¤ì–´ìˆê±°ë‚˜, ë‹¤ë¥¸ ê°œë°œìì— ì˜í•´ ì‘ì„±ëœ ê²ƒì¼ ìˆ˜ ìˆë‹¤.
        - include a "header file" with function declarations only (í•¨ìˆ˜ ì„ ì–¸ì´ ë“¤ì–´ìˆëŠ” í—¤ë”íŒŒì¼ì„ í¬í•¨ì‹œí‚¨ë‹¤. ê°œë³„ì ìœ¼ë¡œ ì»´íŒŒì¼í•˜ê³ , ìµœì¢… ì‹¤í–‰ ì „ì— link í•´ì•¼ í•œë‹¤.)
- Implementing Function (YT 16min)
    - í•¨ìˆ˜ í˜¸ì¶œ ì‹œ, ì–´ë–»ê²Œ machine instruction ìˆ˜ì¤€ì—ì„œ êµ¬í˜„í•˜ëŠ”ì§€

        ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2015.png)

    - *Activation Record
    - í•¨ìˆ˜ ì •ë³´ (argument, return value, ë¡œì»¬ë³€ìˆ˜ ë“±)ëŠ” activation recordì— ë‹´ê²¨ìˆë‹¤. (ì–¸ì œ ìƒì„±??? í•¨ìˆ˜ ì„ ì–¸ ì‹œ? or í˜¸ì¶œ ì‹œ?
    - í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ í•´ë‹¹ í•¨ìˆ˜ì˜ activation recordê°€ run-time stackì— allocateëœë‹¤.
    - í•¨ìˆ˜ Call ë° Returnì˜ ê³¼ì • ğŸŒ´ğŸŒ´ğŸŒ´
    - ì–´ë–¤ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, í•´ë‹¹ í•¨ìˆ˜ëŠ” Calleeì´ê³ , í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ì§€ì ì€ Callerì´ë‹¤.
    1. Callerê°€ argumentë¥¼ ì „ë‹¬í•˜ê¸° ìœ„í•´ argumentì˜ ê°’ì„ ë³µì‚¬í•´ì„œ activation recordì— pushí•œë‹¤.
    2. Callerê°€ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤. 
    3. CalleeëŠ” ìê¸° í•¨ìˆ˜ì˜ ë¡œì»¬ë³€ìˆ˜ë¥¼ allocateí•œë‹¤. (ë¡œì»¬ë³€ìˆ˜ë¥¼ í¬í•¨í•œ activation recordë¥¼ stackì— allocateí•œë‹¤. ???)
    4. CalleeëŠ” ì½”ë“œë¥¼ ì‹¤í–‰í•´ì„œ return valueë¥¼ êµ¬í•˜ê³ , return ê°’ì„ activation recordì˜ í•´ë‹¹ ìœ„ì¹˜ì— ë„£ëŠ”ë‹¤.
    5. CalleeëŠ” ì‚¬ìš©ì´ ì™„ë£Œëœ ë¡œì»¬ë³€ìˆ˜ë¥¼ freeí•˜ê³ , í•¨ìˆ˜ë¥¼ return í•œë‹¤. ???
    6. CallerëŠ” activation recordì—ì„œ returnê°’ì„ êº¼ë‚´ì–´ ì‚¬ìš©í•œë‹¤.
        - Argument values : allocated, set up, free - by Caller
        Return value : allocated, set up - by Callee / used, free - by Caller
        Return address : allocated, set up, free - by Callee
        dynamic link : allocated, set up, restore, free - by Callee
        local variables (ì—„ë°€íˆëŠ” automatic variables) : allocated, set up, free - by Callee
    - (ì •ë¦¬) Run-time Stack
    - *ë¡œì»¬ë³€ìˆ˜ëŠ” run-time stack in an activation recordì— ì €ì¥ëœë‹¤.
    - í•¨ìˆ˜ê°€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ í•´ë‹¹ í•¨ìˆ˜ì˜ activation recordê°€ run-time stackì— allocateëœë‹¤.
    - R5 (frame pointer)ëŠ” the beginning of a region of activation record (í˜„ì¬ í•¨ìˆ˜ ê´€ë ¨ ë¡œì»¬ë³€ìˆ˜ê°€ ì €ì¥ë˜ì–´ ìˆìŒ)ë¥¼ ê°€ë¥´í‚¨ë‹¤.
    - ìƒˆë¡œìš´ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´, activation recordê°€ stackì— pushëœë‹¤.
       í•´ë‹¹ í•¨ìˆ˜ê°€ returnë˜ë©´, activation recordsëŠ” stackì—ì„œ pop offëœë‹¤. 
       (í•¨ìˆ˜ í˜¸ì¶œ ë° return ê³¼ì •ì´ LIFOì´ë¯€ë¡œ activation recordë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ allocate/free ì‹œí‚¬ ìˆ˜ ìˆë‹¤.) ???
        - *ì˜ˆì‹œ1 - ì½”ë“œê°€ ì‹¤í–‰ë  ë•Œ stackì˜ êµ¬ì¡°

            ```c
            int main() 
            {
            	int a; // 0. stackì— ë¡œì»¬ë³€ìˆ˜ê°€ allocate ë¨
            	int b;
              // ...
            	b = Watt(a); // 1. Main í•¨ìˆ˜ê°€ Watt í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            	b = Volta(a,b); // 5. Main í•¨ìˆ˜ê°€ Volta í˜¸ì¶œ
            } // 7. main return

            int Watt(int a)
            {
            	int w; 
              // ...
            	w = Volta(w,10); // 2. Watt í•¨ìˆ˜ê°€ Volta í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            	return w; // 4. Watt return -> 1
            }

            int Volta(int q, int r)
            {
            	int k;
            	int m;
              // ...
            	return k; // 3. Volta return -> 2 / 6. Volta return -> 1
            }
            ```

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2016.png)

            1. (ì²«ë²ˆì§¸ ê·¸ë¦¼) Main í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (a,b)ì˜ base (ìµœìƒìœ„ ì£¼ì†Œ)ë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 2ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 2ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) - 0. stackì— ë¡œì»¬ë³€ìˆ˜ê°€ allocate ë¨
            R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 
            2. (ë‘ë²ˆì§¸ ê·¸ë¦¼) Mainì—ì„œ Wattë¥¼ í˜¸ì¶œí•˜ê³ , Watt í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, Wattì˜ activation recordê°€ pushëœë‹¤. - 1. Main í•¨ìˆ˜ê°€ Watt í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (w)ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 1ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 1ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) 
            R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 
            3. (ì„¸ë²ˆì§¸ ê·¸ë¦¼) Mainì—ì„œ Voltaë¥¼ í˜¸ì¶œí•˜ê³ , Volta í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, Voltaì˜ activation recordê°€ pushëœë‹¤. - 2. Watt í•¨ìˆ˜ê°€ Volta í•¨ìˆ˜ë¥¼ í˜¸ì¶œ
            R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (k,m)ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 2ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 2ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) 
            R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2017.png)

            4. (ë„¤ë²ˆì§¸ ê·¸ë¦¼) Voltaê°€ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. (return control to Caller and pop) - 3. Volta return -> 2 
            5. (ë‹¤ì„¯ë²ˆì§¸ ê·¸ë¦¼) Wattê°€ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. - 4. Watt return -> 1
            6. (ì—¬ì„¯ë²ˆì§¸ ê·¸ë¦¼) Mainì—ì„œ Wattë¥¼ í˜¸ì¶œí•˜ê³ , Watt í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´, Wattì˜ activation recordê°€ pushëœë‹¤. - 5. Main í•¨ìˆ˜ê°€ Volta í˜¸ì¶œ
                R5ëŠ” ë¡œì»¬ë³€ìˆ˜ (w)ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. (ë¡œì»¬ë³€ìˆ˜ê°€ 1ê°œì´ë¯€ë¡œ R5ê°€ ìœ„ì—ì„œ 1ë²ˆì§¸ë¥¼ ê°€ë¥´í‚´) 
                R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤. 
            7. (ë‹¤ì‹œ ë‹¤ì„¯ë²ˆì§¸ ê·¸ë¦¼) Voltaê°€ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. - 6. Volta return -> 1
            8. Mainì´ returní•˜ë©´, stackì—ì„œ freeëœë‹¤. - 7. main return
                ì´ë•Œ R5ëŠ” Main í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ System ì´ˆê¸°í™” routine???ì—ì„œ ë¡œì»¬ë³€ìˆ˜ì˜ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤.
                R6ëŠ” Main ì•„ë˜ì¤„ (stack ìµœìƒë‹¨)ì„ ê°€ë¥´í‚¨ë‹¤.

            - ì°¸ê³  - LC-3ì˜ í•¨ìˆ˜ í˜¸ì¶œ Implementation
                1. Caller pushes arguments (last to first)
                2. Caller invokes subroutine (JSR)
                3. Callee allocates return value, pushes R7 and R5
                4. Callee allocates space for local variables
                5. Callee executes function code
                6. Callee stores result into return value slot
                7. Callee pops local vars, pops R5, pops R7
                8. Callee returns (JMP R7)
                9. Caller loads return value and pops arguments
                10. Caller resumes computation
        - *ì˜ˆì‹œ2 - ì½”ë“œê°€ ì‹¤í–‰ë  ë•Œ activation recordì˜ êµ¬ì¡°

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2018.png)

            - í•¨ìˆ˜ FNameì„ í˜¸ì¶œí•˜ë©´, ê·¸ë¦¼ê³¼ ê°™ì´ activation recordì´ ìƒì„±ëœë‹¤.
            - ê·¸ë¦¼ ìƒ ì•„ë˜ë¶€í„° ì°¨ë¡€ë¡œ argument, return value (ê°’ì„ êµ¬í•  ë•Œê¹Œì§€ ë¹„ì›Œë‘ ), return address, dynamic link (í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ Callerì˜ R5ê°’), ë¡œì»¬ë³€ìˆ˜ ìˆœìœ¼ë¡œ locateëœë‹¤.
            ì´ë•Œ R5ëŠ” ë¡œì»¬ë³€ìˆ˜ ì¤‘ì—ì„œ ìµœìƒìœ„ ì£¼ì†Œë¥¼ ê°€ë¥´í‚¨ë‹¤. R6ëŠ” stack ìµœìƒë‹¨ì„ ê°€ë¥´í‚¨ë‹¤.
                - Offsetì€ R5ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìœ„ìª½ì— ìˆìœ¼ë©´ (-), ì•„ë˜ìª½ì— ìˆìœ¼ë©´ (+) ê°’ì´ë‹¤.
                ì¦‰, R5ê°€ wë¥¼ ê°€ë¥´í‚¤ë¯€ë¡œ w,x,y = 0, -1, -2 / a,b = 4,5 
                (Offsetì´ ìˆìœ¼ë¯€ë¡œ load register ë˜ëŠ” store registerë¥¼ í†µí•´ activation recordì˜ ê° ìš”ì†Œì— ëª¨ë‘ ì ‘ê·¼ê°€ëŠ¥í•˜ë‹¤.)
                - Bookkeepingì„ ìœ„í•œ 3ê°€ì§€ ìš”ì†Œ
                - return value : space for value returned by function. returnê°’ì´ ì—†ë”ë¼ë„ allocate í•œë‹¤.
                - return address : í•´ë‹¹ functionì´ returní•˜ë©´ ë˜ëŒì•„ê°ˆ ì£¼ì†Œ. save pointer to next instruction in calling function. (convenient location to store R7 in case another function (JSR) is called. ë‹¤ë¥¸ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©´ ì£¼ì†Œê°€ ì‚¬ë¼ì§€ë¯€ë¡œ)
                - dynamic link : í•´ë‹¹ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ Callerì˜ R5ê°’. FNameì´ returní•˜ë©´ í•´ë‹¹ R5ê°’ì„ ë‹¤ì‹œ restoreí•´ì•¼ í•˜ê¸° ë•Œë¬¸! caller's frame pointer. used to pop this activation record from stack

# 13. Testing/Debugging

- Debugging with high-level language
    - Debugging ì¸¡ë©´ì—ì„œ machine languageì™€ high-level languageì€ ëª©í‘œê°€ ë™ì¼í•˜ë©° í° ì°¨ì´ê°€ ì—†ë‹¤.
    - Examine and set values in memory. ë©”ëª¨ë¦¬ì˜ ê°’ì„ ì½ì–´ë³¸ë‹¤. ê°’ì„ ì„¸íŒ…í•´ë³¸ë‹¤.
    - Execute portions of program. í”„ë¡œê·¸ë¨ ì¼ë¶€ë¥¼ ì‹¤í–‰í•´ë³¸ë‹¤.
    - Stop execution when/where desired. ì›í•˜ëŠ” ì‹œì /ìœ„ì¹˜ì—ì„œ í”„ë¡œê·¸ë¨ì„ ì¤‘ì§€í•´ë³¸ë‹¤.
    - high-level languageì—ì„œëŠ”
    - Examine and set variables (abstraction-memory locationì´ ì•„ë‹ˆë¼ variable)
    - Trace, single-stepping and set breakpoints on statements, function calls (instructionì´ ì•„ë‹ˆë¼)
    - í•„ìš” ì‹œ low-level toolë„ ì‚¬ìš©í•œë‹¤.
- Error Type
    - Syntactic Error 
    - ë¬¸ë²•ì  ì˜¤ë¥˜. Input code is not legal
    - Caught by compiler
    - Semantic Error
    - legal code, ê°œë°œìê°€ ì˜ë„í•˜ì§€ ì•Šì€ ë°©í–¥ìœ¼ë¡œ êµ¬í˜„ë¨
    - í•´ê²°í•˜ê¸° ì–´ë ¤ìš°ë©° debugging toolì´ í•„ìš”í•¨
    - Algorithmic Error
    - í”„ë¡œê·¸ë¨ logicì˜ ë¬¸ì œ. ë¬¸ì œí•´ê²°ì„ ìœ„í•œ ê°œë°œìì˜ ì˜ë„ê°€ í‹€ë¦¼
    - ex. Y2K bug (only allow 2 digits for year, assuming 19__)
- Testing
    - ì‹¤ì œ inputì„ ì£¼ê³ , ê·¸ ê²°ê³¼ë¥¼ ê´€ì°°/í™•ì¸í•˜ëŠ” ì‘ì—…ì´ë‹¤. ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ ê³ ë ¤í•˜ëŠ” ê²ƒì€ í˜„ì‹¤ì ìœ¼ë¡œ ë¶ˆê°€í•˜ë‹¤.
    - Black-Box Testing : program internalsì— ëŒ€í•´ ì•„ë¬´ê²ƒë„ ê°€ì •í•˜ì§€ ì•Šê³ , ì„ì˜ì˜ inputì„ ì£¼ëŠ” ë°©ì‹. replies upon input/output specification. ìë™í™”ê°€ ìš©ì´í•˜ë‚˜ ê²½ë¡œê°€ í•œì •ë¨
    - White-Box Testing : test coverageë¥¼ ì¦ê°€ì‹œì¼œ ë³´ì™„í•œ ë°©ì‹. ë‹¤ì–‘í•œ ê²½ë¡œë¥¼ í™•ì¸í•¨. í•„ìš” ì‹œ assertationì„ ì‚¬ìš©í•¨
- Debuggin Techniques
    - ì£¼ë¨¹êµ¬êµ¬ì‹ - Ad-Hoc
    - Insert printf statements to track flow and values
    - code explicitly checks for values out of expected range
    - Tool ì‚¬ìš© - Source-Level Debugger
    - Examine and set variable values
    - Tracing, breakpoints, single-stepping (ex. cloud9)
        - breakpoints
        - stop when a particular statement is reached (ì ì‹œ ë©ˆì·„ë‹¤ê°€ ì§„í–‰ ê°€ëŠ¥í•œ suspendì˜ ê°œë…) í•¨ìˆ˜ì˜ entry ë˜ëŠ” exitì—ì„œ ë³´í†µ stopí•˜ì—¬ í™•ì¸í•¨
        - conditional breakpoint : stop if a var is equal to a specific value
        - watchpoint : stop when a var is set to a specific value
        - single-stepping
        - execute one statement at a time (ë‹¨, 'ë‹¤ìŒ stop (statement)'ë¥¼ ë¬´ì—‡ìœ¼ë¡œ ì¡ëŠ”ì§€ ê¸°ì¤€ì´ í•„ìš”)
        - step into : next statement is first inside function call (ë‹¤ìŒ stopì€ í˜¸ì¶œëœ í•¨ìˆ˜ì˜ ì²«ë²ˆì§¸ statementì„)
        - step over : execute function without stopping (function ì „ì²´ëŠ” ë¬´ì‹œí•˜ê³ , function ë°”ë¡œ ë’¤ì˜ statementê°€ ë‹¤ìŒ stopì„)
        - step out : finish executing current function and stop on exit (í˜„ì¬ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³ , exit ë¶€ë¶„ (return ë¶€ë¶„)ì´ ë‹¤ìŒ stopì„)
        - Displaying Values
        - show value consistent with declared type of variable
- Programming for Correctness
- ì• ì´ˆì— í”„ë¡œê·¸ë˜ë°í•  ë•Œ ì •í™•íˆí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.
- Accurate Specificatiton, Modular Design (í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë“¤ë¡œ ìª¼ê°  Moduleì„ ë§Œë“¤ê³ , moduleë“¤ì„ componentialí•˜ê²Œ ì¡°í•©í•˜ì—¬ í”„ë¡œê·¸ë¨ì„ êµ¬ì„±) Defensive Programming (commentë¥¼ í†µí•œ documentation, consistent coding style, avoid global var)

# 14. Pointers, Array

- Pointer
    - ë©”ëª¨ë¦¬ì— ìˆëŠ” ë³€ìˆ˜ì˜ ì£¼ì†Œë¥¼ ë‹´ê³  ìˆëŠ” typeì´ë‹¤.
    - allows us to indirectly access variables with their address (we can talk about their address rather than their value)
    - ì£¼ì†Œê°€ í•„ìš”í•œ ì´ìœ  (YT 7min, ì°¸ê³ -CS50 Memory 1hr 10min)

        ```c
        // The function is supposed to swap the values of its arguments
        void swap(int firstVar, int secondVar)  // argument
        {
        	int temp = firstVar;
        	firstVar = secondVar;
          secondVar = tempVar;
        }

        int main(void)
        {
        int valueA = 3;
        int valueB = 4;
        swap(valueA, valueB)  // í•¨ìˆ˜ í˜¸ì¶œ - í•˜ì§€ë§Œ ì‹¤ì œë¡œ valueA/Bê°€ swap ë˜ì§€ ì•ŠìŒ
        }
        ```

        - Swap í•¨ìˆ˜ í˜¸ì¶œ ì‹œ Stack

            ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2019.png)

            - í•¨ìˆ˜ ì‹¤í–‰ ì´ì „
                - Caller (main í•¨ìˆ˜)ì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueB (argument ë³µì‚¬ê°’ 3,4)ê°€ mainì˜ AR ìƒë‹¨ì— allocate ëœë‹¤.
                - Callerì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueBì˜ ë³µì‚¬ê°’ 3,4ê°€ Callee (swap í•¨ìˆ˜)ì˜ argument firstVar, secondVarë¡œ ì „ë‹¬ëœë‹¤.
                - Calleeì˜ argument (ë¡œì»¬ë³€ìˆ˜X) firstVar, secondVarê°€ swapì˜ AR í•˜ë‹¨ì— allocate ëœë‹¤. (ì—„ë°€íˆ í˜¸ì¶œ ì´í›„ì— allocate ë¨)
                ë˜í•œ ë¡œì»¬ë³€ìˆ˜ tempê°€ swapì˜ AR ìƒë‹¨ì— allocate ëœë‹¤.
                *AR (Activation Record)
            - í•¨ìˆ˜ ì‹¤í–‰ ì´í›„
                - í•¨ìˆ˜ê°€ ì‹¤í–‰ë˜ë©´ swapì˜ argument firstVar, secondVarì˜ ê°’ì´ swap ëœë‹¤.
                ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´ í•¨ìˆ˜ê°€ return ë˜ê³  ARì´ pop ëœë‹¤. (return typeì€ voidì„)
                - ì˜ë„í–ˆë˜ mainì˜ ë¡œì»¬ë³€ìˆ˜ valueA, valueBì€ swapë˜ì§€ ì•ŠëŠ”ë‹¤.
                - ê²°ë¡ ì ìœ¼ë¡œ Swap needs address of variables outside its own AR
            - ì°¸ê³ -CS50
            - ì•„ë«ì¤„ì´ main í•¨ìˆ˜, ìœ—ì¤„ì´ swap í•¨ìˆ˜ stack frameì´ë‹¤.

                ![SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png](SNU%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%A9%E1%86%BC%E1%84%80%E1%85%A2%E1%84%85%E1%85%A9%E1%86%AB%E1%84%92%E1%85%A1%E1%86%A8%206f408fb89ebf47c7ac916b2c3d1e1e05/Untitled%2020.png)

- Array
    - a mechanism to group multiple elements of a homogeneous type
    - its element allocated sequentially in memory
    - ex. a[5] : declaration of an Int array with 5 elements

# 15. Recursion

# 16. I/O in C

# 17. Data Structure